
RTOS_HH.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001b12  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000012  00800060  00001b12  00001ba6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000064d  00800072  00800072  00001bb8  2**0
                  ALLOC
  3 .stab         00000b10  00000000  00000000  00001bb8  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000274  00000000  00000000  000026c8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000001e0  00000000  00000000  00002940  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002666  00000000  00000000  00002b20  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000beb  00000000  00000000  00005186  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001005  00000000  00000000  00005d71  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000818  00000000  00000000  00006d78  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000ef1  00000000  00000000  00007590  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001fcb  00000000  00000000  00008481  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000090  00000000  00000000  0000a44c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 91 05 	jmp	0xb22	; 0xb22 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e2 e1       	ldi	r30, 0x12	; 18
      68:	fb e1       	ldi	r31, 0x1B	; 27
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	a2 37       	cpi	r26, 0x72	; 114
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	16 e0       	ldi	r17, 0x06	; 6
      78:	a2 e7       	ldi	r26, 0x72	; 114
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	af 3b       	cpi	r26, 0xBF	; 191
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 34 01 	call	0x268	; 0x268 <main>
      8a:	0c 94 87 0d 	jmp	0x1b0e	; 0x1b0e <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <initLEDport>:
#define MAX_LED_NR 7

void initLEDport()
{
  // All PORTC pins are outputs 
  DDRC = 0b11111111;
      92:	8f ef       	ldi	r24, 0xFF	; 255
      94:	84 bb       	out	0x14, r24	; 20
  // Turn off all LEDs
  PORTC = 0xFF;     
      96:	85 bb       	out	0x15, r24	; 21
}
      98:	08 95       	ret

0000009a <writeAllLEDs>:
void writeAllLEDs(unsigned char pattern)
{
  // Fetch the parameter, invert all bits, and send to LEDs
  // The bits has to be inverted, because HW dictates 
  // a 0 will turn ON a LED
  PORTC = ~pattern;   
      9a:	80 95       	com	r24
      9c:	85 bb       	out	0x15, r24	; 21
}
      9e:	08 95       	ret

000000a0 <turnOnLED>:
void turnOnLED(unsigned char led_nr)
{
// Local variable
unsigned char mask;
  // We only have to do anything, if led_nr < 8
  if (led_nr <= MAX_LED_NR)
      a0:	88 30       	cpi	r24, 0x08	; 8
      a2:	68 f4       	brcc	.+26     	; 0xbe <turnOnLED+0x1e>
  {
    // Create mask based on the parameter (led_nr)
    mask = ~(0b00000001 << led_nr);
    // Turn ON the actual LED (the rest are unchanged)
    PORTC = PORTC & mask;
      a4:	45 b3       	in	r20, 0x15	; 21
unsigned char mask;
  // We only have to do anything, if led_nr < 8
  if (led_nr <= MAX_LED_NR)
  {
    // Create mask based on the parameter (led_nr)
    mask = ~(0b00000001 << led_nr);
      a6:	21 e0       	ldi	r18, 0x01	; 1
      a8:	30 e0       	ldi	r19, 0x00	; 0
      aa:	b9 01       	movw	r22, r18
      ac:	02 c0       	rjmp	.+4      	; 0xb2 <turnOnLED+0x12>
      ae:	66 0f       	add	r22, r22
      b0:	77 1f       	adc	r23, r23
      b2:	8a 95       	dec	r24
      b4:	e2 f7       	brpl	.-8      	; 0xae <turnOnLED+0xe>
      b6:	cb 01       	movw	r24, r22
      b8:	80 95       	com	r24
    // Turn ON the actual LED (the rest are unchanged)
    PORTC = PORTC & mask;
      ba:	84 23       	and	r24, r20
      bc:	85 bb       	out	0x15, r24	; 21
      be:	08 95       	ret

000000c0 <turnOffLED>:
void turnOffLED(unsigned char led_nr)
{
// Local variable
unsigned char mask;
  // We only have to do anything, if led_nr < 8
  if (led_nr <= MAX_LED_NR)
      c0:	88 30       	cpi	r24, 0x08	; 8
      c2:	60 f4       	brcc	.+24     	; 0xdc <turnOffLED+0x1c>
  {
    // Create mask based on the parameter (led_nr)
    mask = 0b00000001 << led_nr;
    // Turn OFF the actual LED (the rest are unchanged)
    PORTC = PORTC | mask;
      c4:	45 b3       	in	r20, 0x15	; 21
unsigned char mask;
  // We only have to do anything, if led_nr < 8
  if (led_nr <= MAX_LED_NR)
  {
    // Create mask based on the parameter (led_nr)
    mask = 0b00000001 << led_nr;
      c6:	21 e0       	ldi	r18, 0x01	; 1
      c8:	30 e0       	ldi	r19, 0x00	; 0
      ca:	b9 01       	movw	r22, r18
      cc:	02 c0       	rjmp	.+4      	; 0xd2 <turnOffLED+0x12>
      ce:	66 0f       	add	r22, r22
      d0:	77 1f       	adc	r23, r23
      d2:	8a 95       	dec	r24
      d4:	e2 f7       	brpl	.-8      	; 0xce <turnOffLED+0xe>
      d6:	cb 01       	movw	r24, r22
    // Turn OFF the actual LED (the rest are unchanged)
    PORTC = PORTC | mask;
      d8:	84 2b       	or	r24, r20
      da:	85 bb       	out	0x15, r24	; 21
      dc:	08 95       	ret

000000de <toggleLED>:
void toggleLED(unsigned char led_nr)
{
// Local variable
unsigned char mask;
  // We only have to do anything, if led_nr < 8
  if (led_nr <= MAX_LED_NR)
      de:	88 30       	cpi	r24, 0x08	; 8
      e0:	60 f4       	brcc	.+24     	; 0xfa <toggleLED+0x1c>
  {
    // Create mask based on the parameter (led_nr)
    mask = 0b00000001 << led_nr;
    // Toggle the actual LED (the rest are unchanged)
    PORTC = PORTC ^ mask;
      e2:	45 b3       	in	r20, 0x15	; 21
unsigned char mask;
  // We only have to do anything, if led_nr < 8
  if (led_nr <= MAX_LED_NR)
  {
    // Create mask based on the parameter (led_nr)
    mask = 0b00000001 << led_nr;
      e4:	21 e0       	ldi	r18, 0x01	; 1
      e6:	30 e0       	ldi	r19, 0x00	; 0
      e8:	b9 01       	movw	r22, r18
      ea:	02 c0       	rjmp	.+4      	; 0xf0 <toggleLED+0x12>
      ec:	66 0f       	add	r22, r22
      ee:	77 1f       	adc	r23, r23
      f0:	8a 95       	dec	r24
      f2:	e2 f7       	brpl	.-8      	; 0xec <toggleLED+0xe>
      f4:	cb 01       	movw	r24, r22
    // Toggle the actual LED (the rest are unchanged)
    PORTC = PORTC ^ mask;
      f6:	84 27       	eor	r24, r20
      f8:	85 bb       	out	0x15, r24	; 21
      fa:	08 95       	ret

000000fc <initSwitchPort>:

// Prepare the switch port
void initSwitchPort()
{
  // Switch port (PA pins) = All inputs
  DDRA = 0;	
      fc:	1a ba       	out	0x1a, r1	; 26
}
      fe:	08 95       	ret

00000100 <switchStatus>:

// Reads all switches at a time
unsigned char switchStatus()
{
  return (~PINA);	
     100:	89 b3       	in	r24, 0x19	; 25
}
     102:	80 95       	com	r24
     104:	08 95       	ret

00000106 <switchOn>:
// Returns TRUE, if the switch having the number
// "switch_nr" is activated - otherwise return FALSE
unsigned char switchOn(unsigned char switch_nr)
{
unsigned char mask;
  if (switch_nr <= MAX_SWITCH_NR)
     106:	88 30       	cpi	r24, 0x08	; 8
     108:	70 f4       	brcc	.+28     	; 0x126 <switchOn+0x20>
  {
    mask = 0b00000001 << switch_nr;
    return (~PINA & mask);
     10a:	49 b3       	in	r20, 0x19	; 25
unsigned char switchOn(unsigned char switch_nr)
{
unsigned char mask;
  if (switch_nr <= MAX_SWITCH_NR)
  {
    mask = 0b00000001 << switch_nr;
     10c:	21 e0       	ldi	r18, 0x01	; 1
     10e:	30 e0       	ldi	r19, 0x00	; 0
     110:	b9 01       	movw	r22, r18
     112:	02 c0       	rjmp	.+4      	; 0x118 <switchOn+0x12>
     114:	66 0f       	add	r22, r22
     116:	77 1f       	adc	r23, r23
     118:	8a 95       	dec	r24
     11a:	e2 f7       	brpl	.-8      	; 0x114 <switchOn+0xe>
     11c:	cb 01       	movw	r24, r22
    return (~PINA & mask);
     11e:	94 2f       	mov	r25, r20
     120:	90 95       	com	r25
     122:	89 23       	and	r24, r25
     124:	08 95       	ret
  }
  else
    return 0;	
     126:	80 e0       	ldi	r24, 0x00	; 0
} 
     128:	08 95       	ret

0000012a <InitUART>:
Parameters:
	BaudRate: Wanted Baud Rate.
	Databits: Wanted number of Data Bits.
*************************************************************************/
void InitUART(unsigned long BaudRate, unsigned char DataBit)
{
     12a:	0f 93       	push	r16
     12c:	1f 93       	push	r17
     12e:	dc 01       	movw	r26, r24
     130:	cb 01       	movw	r24, r22
unsigned int TempUBRR;

  if ((BaudRate >= 110) && (BaudRate <= 115200) && (DataBit >=5) && (DataBit <= 8))
     132:	8c 01       	movw	r16, r24
     134:	9d 01       	movw	r18, r26
     136:	0e 56       	subi	r16, 0x6E	; 110
     138:	10 40       	sbci	r17, 0x00	; 0
     13a:	20 40       	sbci	r18, 0x00	; 0
     13c:	30 40       	sbci	r19, 0x00	; 0
     13e:	03 39       	cpi	r16, 0x93	; 147
     140:	51 ec       	ldi	r21, 0xC1	; 193
     142:	15 07       	cpc	r17, r21
     144:	51 e0       	ldi	r21, 0x01	; 1
     146:	25 07       	cpc	r18, r21
     148:	50 e0       	ldi	r21, 0x00	; 0
     14a:	35 07       	cpc	r19, r21
     14c:	60 f5       	brcc	.+88     	; 0x1a6 <InitUART+0x7c>
     14e:	45 30       	cpi	r20, 0x05	; 5
     150:	50 f1       	brcs	.+84     	; 0x1a6 <InitUART+0x7c>
     152:	49 30       	cpi	r20, 0x09	; 9
     154:	40 f5       	brcc	.+80     	; 0x1a6 <InitUART+0x7c>
  { 
    // "Normal" clock, no multiprocessor mode (= default)
    UCSRA = 0b00100000;
     156:	20 e2       	ldi	r18, 0x20	; 32
     158:	2b b9       	out	0x0b, r18	; 11
    // No interrupts enabled
    // Receiver enabled
    // Transmitter enabled
    // No 9 bit operation
    UCSRB = 0b00011000;	
     15a:	28 e1       	ldi	r18, 0x18	; 24
     15c:	2a b9       	out	0x0a, r18	; 10
    // Asynchronous operation, 1 stop bit, no parity
    // Bit7 always has to be 1
    // Bit 2 and bit 1 controls the number of databits
    UCSRC = 0b10000000 | (DataBit-5)<<1;
     15e:	24 2f       	mov	r18, r20
     160:	30 e0       	ldi	r19, 0x00	; 0
     162:	25 50       	subi	r18, 0x05	; 5
     164:	30 40       	sbci	r19, 0x00	; 0
     166:	22 0f       	add	r18, r18
     168:	33 1f       	adc	r19, r19
     16a:	20 68       	ori	r18, 0x80	; 128
     16c:	20 bd       	out	0x20, r18	; 32
    // Set Baud Rate according to the parameter BaudRate:
    // Select Baud Rate (first store "UBRRH--UBRRL" in local 16-bit variable,
    //                   then write the two 8-bit registers separately):
    TempUBRR = XTAL/(16*BaudRate) - 1;
     16e:	88 0f       	add	r24, r24
     170:	99 1f       	adc	r25, r25
     172:	aa 1f       	adc	r26, r26
     174:	bb 1f       	adc	r27, r27
     176:	88 0f       	add	r24, r24
     178:	99 1f       	adc	r25, r25
     17a:	aa 1f       	adc	r26, r26
     17c:	bb 1f       	adc	r27, r27
     17e:	9c 01       	movw	r18, r24
     180:	ad 01       	movw	r20, r26
     182:	22 0f       	add	r18, r18
     184:	33 1f       	adc	r19, r19
     186:	44 1f       	adc	r20, r20
     188:	55 1f       	adc	r21, r21
     18a:	22 0f       	add	r18, r18
     18c:	33 1f       	adc	r19, r19
     18e:	44 1f       	adc	r20, r20
     190:	55 1f       	adc	r21, r21
     192:	60 e0       	ldi	r22, 0x00	; 0
     194:	70 e4       	ldi	r23, 0x40	; 64
     196:	88 e3       	ldi	r24, 0x38	; 56
     198:	90 e0       	ldi	r25, 0x00	; 0
     19a:	0e 94 01 0d 	call	0x1a02	; 0x1a02 <__udivmodsi4>
     19e:	21 50       	subi	r18, 0x01	; 1
     1a0:	30 40       	sbci	r19, 0x00	; 0
    // Write upper part of UBRR
    UBRRH = TempUBRR >> 8;
     1a2:	30 bd       	out	0x20, r19	; 32
    // Write lower part of UBRR
    UBRRL = TempUBRR;
     1a4:	29 b9       	out	0x09, r18	; 9
  }  
}
     1a6:	1f 91       	pop	r17
     1a8:	0f 91       	pop	r16
     1aa:	08 95       	ret

000001ac <CharReady>:
  Returns 0 (FALSE), if the UART has NOT received a new character.
  Returns value <> 0 (TRUE), if the UART HAS received a new character.
*************************************************************************/
unsigned char CharReady()
{
   return UCSRA & (1<<7);
     1ac:	8b b1       	in	r24, 0x0b	; 11
}
     1ae:	80 78       	andi	r24, 0x80	; 128
     1b0:	08 95       	ret

000001b2 <ReadChar>:
Then this character is returned.
*************************************************************************/
char ReadChar()
{
  // Wait for new character received
  while ( (UCSRA & (1<<7)) == 0 )
     1b2:	5f 9b       	sbis	0x0b, 7	; 11
     1b4:	fe cf       	rjmp	.-4      	; 0x1b2 <ReadChar>
  {}                        
  // Then return it
  return UDR;
     1b6:	8c b1       	in	r24, 0x0c	; 12
}
     1b8:	08 95       	ret

000001ba <SendChar>:
	Ch : Character for sending. 
*************************************************************************/
void SendChar(char Ch)
{
  // Wait for transmitter register empty (ready for new character)
  while ( (UCSRA & (1<<5)) == 0 )
     1ba:	5d 9b       	sbis	0x0b, 5	; 11
     1bc:	fe cf       	rjmp	.-4      	; 0x1ba <SendChar>
  {}
  // Then send the character
  UDR = Ch;
     1be:	8c b9       	out	0x0c, r24	; 12
}
     1c0:	08 95       	ret

000001c2 <SendString>:
Sends 0-terminated string.
Parameter:
   String: Pointer to the string. 
*************************************************************************/
void SendString(char* String)
{
     1c2:	cf 93       	push	r28
     1c4:	df 93       	push	r29
     1c6:	ec 01       	movw	r28, r24
  // Repeat untill zero-termination
  while (*String != 0)
     1c8:	88 81       	ld	r24, Y
     1ca:	88 23       	and	r24, r24
     1cc:	31 f0       	breq	.+12     	; 0x1da <SendString+0x18>
/*************************************************************************
Sends 0-terminated string.
Parameter:
   String: Pointer to the string. 
*************************************************************************/
void SendString(char* String)
     1ce:	21 96       	adiw	r28, 0x01	; 1
{
  // Repeat untill zero-termination
  while (*String != 0)
  {
    // Send the character pointed to by "String"
    SendChar(*String);
     1d0:	0e 94 dd 00 	call	0x1ba	; 0x1ba <SendChar>
   String: Pointer to the string. 
*************************************************************************/
void SendString(char* String)
{
  // Repeat untill zero-termination
  while (*String != 0)
     1d4:	89 91       	ld	r24, Y+
     1d6:	88 23       	and	r24, r24
     1d8:	d9 f7       	brne	.-10     	; 0x1d0 <SendString+0xe>
    // Send the character pointed to by "String"
    SendChar(*String);
    // Advance the pointer one step
    String++;
  }
}
     1da:	df 91       	pop	r29
     1dc:	cf 91       	pop	r28
     1de:	08 95       	ret

000001e0 <SendInteger>:
Makes use of the C standard library <stdlib.h>.
Parameter:
      Number: The integer to be converted and send. 
*************************************************************************/
void SendInteger(int Number)
{
     1e0:	cf 93       	push	r28
     1e2:	df 93       	push	r29
     1e4:	cd b7       	in	r28, 0x3d	; 61
     1e6:	de b7       	in	r29, 0x3e	; 62
     1e8:	27 97       	sbiw	r28, 0x07	; 7
     1ea:	0f b6       	in	r0, 0x3f	; 63
     1ec:	f8 94       	cli
     1ee:	de bf       	out	0x3e, r29	; 62
     1f0:	0f be       	out	0x3f, r0	; 63
     1f2:	cd bf       	out	0x3d, r28	; 61
char array[7];
  // Convert the integer to an ASCII string (array), radix = 10 
  itoa(Number, array, 10);
     1f4:	be 01       	movw	r22, r28
     1f6:	6f 5f       	subi	r22, 0xFF	; 255
     1f8:	7f 4f       	sbci	r23, 0xFF	; 255
     1fa:	4a e0       	ldi	r20, 0x0A	; 10
     1fc:	50 e0       	ldi	r21, 0x00	; 0
     1fe:	0e 94 42 0d 	call	0x1a84	; 0x1a84 <itoa>
  // - then send the string
  SendString(array);
     202:	ce 01       	movw	r24, r28
     204:	01 96       	adiw	r24, 0x01	; 1
     206:	0e 94 e1 00 	call	0x1c2	; 0x1c2 <SendString>
}
     20a:	27 96       	adiw	r28, 0x07	; 7
     20c:	0f b6       	in	r0, 0x3f	; 63
     20e:	f8 94       	cli
     210:	de bf       	out	0x3e, r29	; 62
     212:	0f be       	out	0x3f, r0	; 63
     214:	cd bf       	out	0x3d, r28	; 61
     216:	df 91       	pop	r29
     218:	cf 91       	pop	r28
     21a:	08 95       	ret

0000021c <vLEDFlashTask2>:
    vTaskDelayUntil(&xLastWakeTime,1000);
  }
}

void vLEDFlashTask2( void *pvParameters )
{
     21c:	cf 93       	push	r28
     21e:	df 93       	push	r29
     220:	00 d0       	rcall	.+0      	; 0x222 <vLEDFlashTask2+0x6>
     222:	cd b7       	in	r28, 0x3d	; 61
     224:	de b7       	in	r29, 0x3e	; 62
portTickType xLastWakeTime;
xLastWakeTime=xTaskGetTickCount();
     226:	0e 94 28 0a 	call	0x1450	; 0x1450 <xTaskGetTickCount>
     22a:	9a 83       	std	Y+2, r25	; 0x02
     22c:	89 83       	std	Y+1, r24	; 0x01
  while(1)
  {
    toggleLED(1);
     22e:	81 e0       	ldi	r24, 0x01	; 1
     230:	0e 94 6f 00 	call	0xde	; 0xde <toggleLED>
    vTaskDelayUntil(&xLastWakeTime,500);
     234:	ce 01       	movw	r24, r28
     236:	01 96       	adiw	r24, 0x01	; 1
     238:	64 ef       	ldi	r22, 0xF4	; 244
     23a:	71 e0       	ldi	r23, 0x01	; 1
     23c:	0e 94 b0 0b 	call	0x1760	; 0x1760 <vTaskDelayUntil>
     240:	f6 cf       	rjmp	.-20     	; 0x22e <vLEDFlashTask2+0x12>

00000242 <vLEDFlashTask1>:
#include "FreeRTOS.h"
#include "task.h"
#include "led.h"

void vLEDFlashTask1( void *pvParameters )
{
     242:	cf 93       	push	r28
     244:	df 93       	push	r29
     246:	00 d0       	rcall	.+0      	; 0x248 <vLEDFlashTask1+0x6>
     248:	cd b7       	in	r28, 0x3d	; 61
     24a:	de b7       	in	r29, 0x3e	; 62
portTickType xLastWakeTime;
xLastWakeTime=xTaskGetTickCount();
     24c:	0e 94 28 0a 	call	0x1450	; 0x1450 <xTaskGetTickCount>
     250:	9a 83       	std	Y+2, r25	; 0x02
     252:	89 83       	std	Y+1, r24	; 0x01
  while(1)
  {
    toggleLED(0);
     254:	80 e0       	ldi	r24, 0x00	; 0
     256:	0e 94 6f 00 	call	0xde	; 0xde <toggleLED>
    vTaskDelayUntil(&xLastWakeTime,1000);
     25a:	ce 01       	movw	r24, r28
     25c:	01 96       	adiw	r24, 0x01	; 1
     25e:	68 ee       	ldi	r22, 0xE8	; 232
     260:	73 e0       	ldi	r23, 0x03	; 3
     262:	0e 94 b0 0b 	call	0x1760	; 0x1760 <vTaskDelayUntil>
     266:	f6 cf       	rjmp	.-20     	; 0x254 <vLEDFlashTask1+0x12>

00000268 <main>:
  }
}

int main(void)
{
  initLEDport();
     268:	0e 94 49 00 	call	0x92	; 0x92 <initLEDport>
  xTaskCreate( vLEDFlashTask1, ( signed char * ) "LED1", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
     26c:	81 e2       	ldi	r24, 0x21	; 33
     26e:	91 e0       	ldi	r25, 0x01	; 1
     270:	60 e6       	ldi	r22, 0x60	; 96
     272:	70 e0       	ldi	r23, 0x00	; 0
     274:	45 e5       	ldi	r20, 0x55	; 85
     276:	50 e0       	ldi	r21, 0x00	; 0
     278:	20 e0       	ldi	r18, 0x00	; 0
     27a:	30 e0       	ldi	r19, 0x00	; 0
     27c:	00 e0       	ldi	r16, 0x00	; 0
     27e:	ee 24       	eor	r14, r14
     280:	ff 24       	eor	r15, r15
     282:	cc 24       	eor	r12, r12
     284:	dd 24       	eor	r13, r13
     286:	aa 24       	eor	r10, r10
     288:	bb 24       	eor	r11, r11
     28a:	0e 94 f9 08 	call	0x11f2	; 0x11f2 <xTaskGenericCreate>
  xTaskCreate( vLEDFlashTask2, ( signed char * ) "LED2", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );	
     28e:	8e e0       	ldi	r24, 0x0E	; 14
     290:	91 e0       	ldi	r25, 0x01	; 1
     292:	65 e6       	ldi	r22, 0x65	; 101
     294:	70 e0       	ldi	r23, 0x00	; 0
     296:	45 e5       	ldi	r20, 0x55	; 85
     298:	50 e0       	ldi	r21, 0x00	; 0
     29a:	20 e0       	ldi	r18, 0x00	; 0
     29c:	30 e0       	ldi	r19, 0x00	; 0
     29e:	0e 94 f9 08 	call	0x11f2	; 0x11f2 <xTaskGenericCreate>
  vTaskStartScheduler();
     2a2:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <vTaskStartScheduler>
     2a6:	ff cf       	rjmp	.-2      	; 0x2a6 <main+0x3e>

000002a8 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
     2a8:	af 92       	push	r10
     2aa:	bf 92       	push	r11
     2ac:	cf 92       	push	r12
     2ae:	df 92       	push	r13
     2b0:	ef 92       	push	r14
     2b2:	ff 92       	push	r15
     2b4:	0f 93       	push	r16
     2b6:	1f 93       	push	r17
     2b8:	cf 93       	push	r28
     2ba:	df 93       	push	r29
     2bc:	6c 01       	movw	r12, r24
     2be:	e6 2e       	mov	r14, r22
     2c0:	f4 2e       	mov	r15, r20
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
     2c2:	8a e1       	ldi	r24, 0x1A	; 26
     2c4:	90 e0       	ldi	r25, 0x00	; 0
     2c6:	0e 94 94 05 	call	0xb28	; 0xb28 <pvPortMalloc>
     2ca:	8c 01       	movw	r16, r24
	if( pxCoRoutine )
     2cc:	00 97       	sbiw	r24, 0x00	; 0
     2ce:	09 f4       	brne	.+2      	; 0x2d2 <xCoRoutineCreate+0x2a>
     2d0:	62 c0       	rjmp	.+196    	; 0x396 <xCoRoutineCreate+0xee>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     2d2:	80 91 72 00 	lds	r24, 0x0072
     2d6:	90 91 73 00 	lds	r25, 0x0073
     2da:	00 97       	sbiw	r24, 0x00	; 0
     2dc:	39 f5       	brne	.+78     	; 0x32c <xCoRoutineCreate+0x84>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     2de:	10 93 73 00 	sts	0x0073, r17
     2e2:	00 93 72 00 	sts	0x0072, r16
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
     2e6:	c5 e7       	ldi	r28, 0x75	; 117
     2e8:	d0 e0       	ldi	r29, 0x00	; 0
     2ea:	ce 01       	movw	r24, r28
     2ec:	0e 94 79 03 	call	0x6f2	; 0x6f2 <vListInitialise>
     2f0:	ce 01       	movw	r24, r28
     2f2:	09 96       	adiw	r24, 0x09	; 9
     2f4:	0e 94 79 03 	call	0x6f2	; 0x6f2 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
     2f8:	c7 e8       	ldi	r28, 0x87	; 135
     2fa:	d0 e0       	ldi	r29, 0x00	; 0
     2fc:	ce 01       	movw	r24, r28
     2fe:	0e 94 79 03 	call	0x6f2	; 0x6f2 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
     302:	0f 2e       	mov	r0, r31
     304:	f0 e9       	ldi	r31, 0x90	; 144
     306:	af 2e       	mov	r10, r31
     308:	f0 e0       	ldi	r31, 0x00	; 0
     30a:	bf 2e       	mov	r11, r31
     30c:	f0 2d       	mov	r31, r0
     30e:	c5 01       	movw	r24, r10
     310:	0e 94 79 03 	call	0x6f2	; 0x6f2 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
     314:	89 e9       	ldi	r24, 0x99	; 153
     316:	90 e0       	ldi	r25, 0x00	; 0
     318:	0e 94 79 03 	call	0x6f2	; 0x6f2 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     31c:	d0 93 a3 00 	sts	0x00A3, r29
     320:	c0 93 a2 00 	sts	0x00A2, r28
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     324:	b0 92 a5 00 	sts	0x00A5, r11
     328:	a0 92 a4 00 	sts	0x00A4, r10
     32c:	ce 2d       	mov	r28, r14
     32e:	e1 10       	cpse	r14, r1
     330:	c1 e0       	ldi	r28, 0x01	; 1
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     332:	f8 01       	movw	r30, r16
     334:	11 8e       	std	Z+25, r1	; 0x19
     336:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     338:	c6 8b       	std	Z+22, r28	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     33a:	f7 8a       	std	Z+23, r15	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     33c:	c1 92       	st	Z+, r12
     33e:	d1 92       	st	Z+, r13
     340:	7f 01       	movw	r14, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     342:	cf 01       	movw	r24, r30
     344:	0e 94 87 03 	call	0x70e	; 0x70e <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     348:	c8 01       	movw	r24, r16
     34a:	0c 96       	adiw	r24, 0x0c	; 12
     34c:	0e 94 87 03 	call	0x70e	; 0x70e <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     350:	f8 01       	movw	r30, r16
     352:	11 87       	std	Z+9, r17	; 0x09
     354:	00 87       	std	Z+8, r16	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     356:	13 8b       	std	Z+19, r17	; 0x13
     358:	02 8b       	std	Z+18, r16	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
     35a:	81 e0       	ldi	r24, 0x01	; 1
     35c:	90 e0       	ldi	r25, 0x00	; 0
     35e:	8c 1b       	sub	r24, r28
     360:	91 09       	sbc	r25, r1
     362:	95 87       	std	Z+13, r25	; 0x0d
     364:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     366:	86 89       	ldd	r24, Z+22	; 0x16
     368:	90 91 74 00 	lds	r25, 0x0074
     36c:	98 17       	cp	r25, r24
     36e:	10 f4       	brcc	.+4      	; 0x374 <xCoRoutineCreate+0xcc>
     370:	80 93 74 00 	sts	0x0074, r24
     374:	90 e0       	ldi	r25, 0x00	; 0
     376:	9c 01       	movw	r18, r24
     378:	22 0f       	add	r18, r18
     37a:	33 1f       	adc	r19, r19
     37c:	22 0f       	add	r18, r18
     37e:	33 1f       	adc	r19, r19
     380:	22 0f       	add	r18, r18
     382:	33 1f       	adc	r19, r19
     384:	82 0f       	add	r24, r18
     386:	93 1f       	adc	r25, r19
     388:	8b 58       	subi	r24, 0x8B	; 139
     38a:	9f 4f       	sbci	r25, 0xFF	; 255
     38c:	b7 01       	movw	r22, r14
     38e:	0e 94 8b 03 	call	0x716	; 0x716 <vListInsertEnd>

		xReturn = pdPASS;
     392:	81 e0       	ldi	r24, 0x01	; 1
     394:	01 c0       	rjmp	.+2      	; 0x398 <xCoRoutineCreate+0xf0>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     396:	8f ef       	ldi	r24, 0xFF	; 255
	}
	
	return xReturn;	
}
     398:	df 91       	pop	r29
     39a:	cf 91       	pop	r28
     39c:	1f 91       	pop	r17
     39e:	0f 91       	pop	r16
     3a0:	ff 90       	pop	r15
     3a2:	ef 90       	pop	r14
     3a4:	df 90       	pop	r13
     3a6:	cf 90       	pop	r12
     3a8:	bf 90       	pop	r11
     3aa:	af 90       	pop	r10
     3ac:	08 95       	ret

000003ae <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
     3ae:	0f 93       	push	r16
     3b0:	1f 93       	push	r17
     3b2:	cf 93       	push	r28
     3b4:	df 93       	push	r29
     3b6:	8b 01       	movw	r16, r22
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     3b8:	c0 91 a6 00 	lds	r28, 0x00A6
     3bc:	d0 91 a7 00 	lds	r29, 0x00A7
     3c0:	c8 0f       	add	r28, r24
     3c2:	d9 1f       	adc	r29, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     3c4:	80 91 72 00 	lds	r24, 0x0072
     3c8:	90 91 73 00 	lds	r25, 0x0073
     3cc:	02 96       	adiw	r24, 0x02	; 2
     3ce:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     3d2:	e0 91 72 00 	lds	r30, 0x0072
     3d6:	f0 91 73 00 	lds	r31, 0x0073
     3da:	d3 83       	std	Z+3, r29	; 0x03
     3dc:	c2 83       	std	Z+2, r28	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     3de:	80 91 a6 00 	lds	r24, 0x00A6
     3e2:	90 91 a7 00 	lds	r25, 0x00A7
     3e6:	c8 17       	cp	r28, r24
     3e8:	d9 07       	cpc	r29, r25
     3ea:	50 f4       	brcc	.+20     	; 0x400 <vCoRoutineAddToDelayedList+0x52>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     3ec:	bf 01       	movw	r22, r30
     3ee:	6e 5f       	subi	r22, 0xFE	; 254
     3f0:	7f 4f       	sbci	r23, 0xFF	; 255
     3f2:	80 91 a4 00 	lds	r24, 0x00A4
     3f6:	90 91 a5 00 	lds	r25, 0x00A5
     3fa:	0e 94 b4 03 	call	0x768	; 0x768 <vListInsert>
     3fe:	09 c0       	rjmp	.+18     	; 0x412 <vCoRoutineAddToDelayedList+0x64>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     400:	bf 01       	movw	r22, r30
     402:	6e 5f       	subi	r22, 0xFE	; 254
     404:	7f 4f       	sbci	r23, 0xFF	; 255
     406:	80 91 a2 00 	lds	r24, 0x00A2
     40a:	90 91 a3 00 	lds	r25, 0x00A3
     40e:	0e 94 b4 03 	call	0x768	; 0x768 <vListInsert>
	}

	if( pxEventList )
     412:	01 15       	cp	r16, r1
     414:	11 05       	cpc	r17, r1
     416:	49 f0       	breq	.+18     	; 0x42a <vCoRoutineAddToDelayedList+0x7c>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     418:	60 91 72 00 	lds	r22, 0x0072
     41c:	70 91 73 00 	lds	r23, 0x0073
     420:	64 5f       	subi	r22, 0xF4	; 244
     422:	7f 4f       	sbci	r23, 0xFF	; 255
     424:	c8 01       	movw	r24, r16
     426:	0e 94 b4 03 	call	0x768	; 0x768 <vListInsert>
	}
}
     42a:	df 91       	pop	r29
     42c:	cf 91       	pop	r28
     42e:	1f 91       	pop	r17
     430:	0f 91       	pop	r16
     432:	08 95       	ret

00000434 <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     434:	cf 92       	push	r12
     436:	df 92       	push	r13
     438:	ef 92       	push	r14
     43a:	ff 92       	push	r15
     43c:	0f 93       	push	r16
     43e:	1f 93       	push	r17
     440:	cf 93       	push	r28
     442:	df 93       	push	r29
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     444:	80 91 99 00 	lds	r24, 0x0099
     448:	88 23       	and	r24, r24
     44a:	b9 f1       	breq	.+110    	; 0x4ba <vCoRoutineSchedule+0x86>
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     44c:	0f 2e       	mov	r0, r31
     44e:	fe e9       	ldi	r31, 0x9E	; 158
     450:	ef 2e       	mov	r14, r31
     452:	f0 e0       	ldi	r31, 0x00	; 0
     454:	ff 2e       	mov	r15, r31
     456:	f0 2d       	mov	r31, r0
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     458:	0f 2e       	mov	r0, r31
     45a:	f9 e9       	ldi	r31, 0x99	; 153
     45c:	cf 2e       	mov	r12, r31
     45e:	f0 e0       	ldi	r31, 0x00	; 0
     460:	df 2e       	mov	r13, r31
     462:	f0 2d       	mov	r31, r0
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     464:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     466:	d7 01       	movw	r26, r14
     468:	ed 91       	ld	r30, X+
     46a:	fc 91       	ld	r31, X
     46c:	c6 81       	ldd	r28, Z+6	; 0x06
     46e:	d7 81       	ldd	r29, Z+7	; 0x07
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     470:	ce 01       	movw	r24, r28
     472:	0c 96       	adiw	r24, 0x0c	; 12
     474:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <vListRemove>
		}
		portENABLE_INTERRUPTS();
     478:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     47a:	8e 01       	movw	r16, r28
     47c:	0e 5f       	subi	r16, 0xFE	; 254
     47e:	1f 4f       	sbci	r17, 0xFF	; 255
     480:	c8 01       	movw	r24, r16
     482:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
     486:	8e 89       	ldd	r24, Y+22	; 0x16
     488:	90 91 74 00 	lds	r25, 0x0074
     48c:	98 17       	cp	r25, r24
     48e:	10 f4       	brcc	.+4      	; 0x494 <vCoRoutineSchedule+0x60>
     490:	80 93 74 00 	sts	0x0074, r24
     494:	90 e0       	ldi	r25, 0x00	; 0
     496:	9c 01       	movw	r18, r24
     498:	22 0f       	add	r18, r18
     49a:	33 1f       	adc	r19, r19
     49c:	22 0f       	add	r18, r18
     49e:	33 1f       	adc	r19, r19
     4a0:	22 0f       	add	r18, r18
     4a2:	33 1f       	adc	r19, r19
     4a4:	82 0f       	add	r24, r18
     4a6:	93 1f       	adc	r25, r19
     4a8:	8b 58       	subi	r24, 0x8B	; 139
     4aa:	9f 4f       	sbci	r25, 0xFF	; 255
     4ac:	b8 01       	movw	r22, r16
     4ae:	0e 94 8b 03 	call	0x716	; 0x716 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     4b2:	f6 01       	movw	r30, r12
     4b4:	80 81       	ld	r24, Z
     4b6:	88 23       	and	r24, r24
     4b8:	a9 f6       	brne	.-86     	; 0x464 <vCoRoutineSchedule+0x30>

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     4ba:	0e 94 28 0a 	call	0x1450	; 0x1450 <xTaskGetTickCount>
     4be:	20 91 a8 00 	lds	r18, 0x00A8
     4c2:	30 91 a9 00 	lds	r19, 0x00A9
     4c6:	82 1b       	sub	r24, r18
     4c8:	93 0b       	sbc	r25, r19
     4ca:	90 93 ab 00 	sts	0x00AB, r25
     4ce:	80 93 aa 00 	sts	0x00AA, r24
     4d2:	74 c0       	rjmp	.+232    	; 0x5bc <vCoRoutineSchedule+0x188>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
     4d4:	20 91 a6 00 	lds	r18, 0x00A6
     4d8:	30 91 a7 00 	lds	r19, 0x00A7
     4dc:	2f 5f       	subi	r18, 0xFF	; 255
     4de:	3f 4f       	sbci	r19, 0xFF	; 255
     4e0:	30 93 a7 00 	sts	0x00A7, r19
     4e4:	20 93 a6 00 	sts	0x00A6, r18
		xPassedTicks--;
     4e8:	01 97       	sbiw	r24, 0x01	; 1
     4ea:	90 93 ab 00 	sts	0x00AB, r25
     4ee:	80 93 aa 00 	sts	0x00AA, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     4f2:	21 15       	cp	r18, r1
     4f4:	31 05       	cpc	r19, r1
     4f6:	81 f4       	brne	.+32     	; 0x518 <vCoRoutineSchedule+0xe4>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     4f8:	80 91 a2 00 	lds	r24, 0x00A2
     4fc:	90 91 a3 00 	lds	r25, 0x00A3
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     500:	20 91 a4 00 	lds	r18, 0x00A4
     504:	30 91 a5 00 	lds	r19, 0x00A5
     508:	30 93 a3 00 	sts	0x00A3, r19
     50c:	20 93 a2 00 	sts	0x00A2, r18
			pxOverflowDelayedCoRoutineList = pxTemp;
     510:	90 93 a5 00 	sts	0x00A5, r25
     514:	80 93 a4 00 	sts	0x00A4, r24
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     518:	e0 91 a2 00 	lds	r30, 0x00A2
     51c:	f0 91 a3 00 	lds	r31, 0x00A3
     520:	80 81       	ld	r24, Z
     522:	88 23       	and	r24, r24
     524:	09 f4       	brne	.+2      	; 0x528 <vCoRoutineSchedule+0xf4>
     526:	4a c0       	rjmp	.+148    	; 0x5bc <vCoRoutineSchedule+0x188>
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     528:	05 80       	ldd	r0, Z+5	; 0x05
     52a:	f6 81       	ldd	r31, Z+6	; 0x06
     52c:	e0 2d       	mov	r30, r0
     52e:	c6 81       	ldd	r28, Z+6	; 0x06
     530:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     532:	2a 81       	ldd	r18, Y+2	; 0x02
     534:	3b 81       	ldd	r19, Y+3	; 0x03
     536:	80 91 a6 00 	lds	r24, 0x00A6
     53a:	90 91 a7 00 	lds	r25, 0x00A7
     53e:	82 17       	cp	r24, r18
     540:	93 07       	cpc	r25, r19
     542:	78 f4       	brcc	.+30     	; 0x562 <vCoRoutineSchedule+0x12e>
     544:	3b c0       	rjmp	.+118    	; 0x5bc <vCoRoutineSchedule+0x188>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     546:	05 80       	ldd	r0, Z+5	; 0x05
     548:	f6 81       	ldd	r31, Z+6	; 0x06
     54a:	e0 2d       	mov	r30, r0
     54c:	c6 81       	ldd	r28, Z+6	; 0x06
     54e:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     550:	2a 81       	ldd	r18, Y+2	; 0x02
     552:	3b 81       	ldd	r19, Y+3	; 0x03
     554:	80 91 a6 00 	lds	r24, 0x00A6
     558:	90 91 a7 00 	lds	r25, 0x00A7
     55c:	82 17       	cp	r24, r18
     55e:	93 07       	cpc	r25, r19
     560:	68 f1       	brcs	.+90     	; 0x5bc <vCoRoutineSchedule+0x188>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
     562:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
     564:	8e 01       	movw	r16, r28
     566:	0e 5f       	subi	r16, 0xFE	; 254
     568:	1f 4f       	sbci	r17, 0xFF	; 255
     56a:	c8 01       	movw	r24, r16
     56c:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
     570:	8c 89       	ldd	r24, Y+20	; 0x14
     572:	9d 89       	ldd	r25, Y+21	; 0x15
     574:	00 97       	sbiw	r24, 0x00	; 0
     576:	21 f0       	breq	.+8      	; 0x580 <vCoRoutineSchedule+0x14c>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
     578:	ce 01       	movw	r24, r28
     57a:	0c 96       	adiw	r24, 0x0c	; 12
     57c:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     580:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
     582:	8e 89       	ldd	r24, Y+22	; 0x16
     584:	90 91 74 00 	lds	r25, 0x0074
     588:	98 17       	cp	r25, r24
     58a:	10 f4       	brcc	.+4      	; 0x590 <vCoRoutineSchedule+0x15c>
     58c:	80 93 74 00 	sts	0x0074, r24
     590:	90 e0       	ldi	r25, 0x00	; 0
     592:	9c 01       	movw	r18, r24
     594:	22 0f       	add	r18, r18
     596:	33 1f       	adc	r19, r19
     598:	22 0f       	add	r18, r18
     59a:	33 1f       	adc	r19, r19
     59c:	22 0f       	add	r18, r18
     59e:	33 1f       	adc	r19, r19
     5a0:	82 0f       	add	r24, r18
     5a2:	93 1f       	adc	r25, r19
     5a4:	8b 58       	subi	r24, 0x8B	; 139
     5a6:	9f 4f       	sbci	r25, 0xFF	; 255
     5a8:	b8 01       	movw	r22, r16
     5aa:	0e 94 8b 03 	call	0x716	; 0x716 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     5ae:	e0 91 a2 00 	lds	r30, 0x00A2
     5b2:	f0 91 a3 00 	lds	r31, 0x00A3
     5b6:	80 81       	ld	r24, Z
     5b8:	88 23       	and	r24, r24
     5ba:	29 f6       	brne	.-118    	; 0x546 <vCoRoutineSchedule+0x112>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     5bc:	80 91 aa 00 	lds	r24, 0x00AA
     5c0:	90 91 ab 00 	lds	r25, 0x00AB
     5c4:	00 97       	sbiw	r24, 0x00	; 0
     5c6:	09 f0       	breq	.+2      	; 0x5ca <vCoRoutineSchedule+0x196>
     5c8:	85 cf       	rjmp	.-246    	; 0x4d4 <vCoRoutineSchedule+0xa0>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
     5ca:	80 91 a6 00 	lds	r24, 0x00A6
     5ce:	90 91 a7 00 	lds	r25, 0x00A7
     5d2:	90 93 a9 00 	sts	0x00A9, r25
     5d6:	80 93 a8 00 	sts	0x00A8, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     5da:	20 91 74 00 	lds	r18, 0x0074
     5de:	82 2f       	mov	r24, r18
     5e0:	90 e0       	ldi	r25, 0x00	; 0
     5e2:	fc 01       	movw	r30, r24
     5e4:	ee 0f       	add	r30, r30
     5e6:	ff 1f       	adc	r31, r31
     5e8:	ee 0f       	add	r30, r30
     5ea:	ff 1f       	adc	r31, r31
     5ec:	ee 0f       	add	r30, r30
     5ee:	ff 1f       	adc	r31, r31
     5f0:	e8 0f       	add	r30, r24
     5f2:	f9 1f       	adc	r31, r25
     5f4:	eb 58       	subi	r30, 0x8B	; 139
     5f6:	ff 4f       	sbci	r31, 0xFF	; 255
     5f8:	30 81       	ld	r19, Z
     5fa:	33 23       	and	r19, r19
     5fc:	d9 f4       	brne	.+54     	; 0x634 <vCoRoutineSchedule+0x200>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     5fe:	22 23       	and	r18, r18
     600:	31 f4       	brne	.+12     	; 0x60e <vCoRoutineSchedule+0x1da>
     602:	47 c0       	rjmp	.+142    	; 0x692 <vCoRoutineSchedule+0x25e>
     604:	22 23       	and	r18, r18
     606:	19 f4       	brne	.+6      	; 0x60e <vCoRoutineSchedule+0x1da>
     608:	20 93 74 00 	sts	0x0074, r18
     60c:	42 c0       	rjmp	.+132    	; 0x692 <vCoRoutineSchedule+0x25e>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
     60e:	21 50       	subi	r18, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     610:	82 2f       	mov	r24, r18
     612:	90 e0       	ldi	r25, 0x00	; 0
     614:	fc 01       	movw	r30, r24
     616:	ee 0f       	add	r30, r30
     618:	ff 1f       	adc	r31, r31
     61a:	ee 0f       	add	r30, r30
     61c:	ff 1f       	adc	r31, r31
     61e:	ee 0f       	add	r30, r30
     620:	ff 1f       	adc	r31, r31
     622:	e8 0f       	add	r30, r24
     624:	f9 1f       	adc	r31, r25
     626:	eb 58       	subi	r30, 0x8B	; 139
     628:	ff 4f       	sbci	r31, 0xFF	; 255
     62a:	30 81       	ld	r19, Z
     62c:	33 23       	and	r19, r19
     62e:	51 f3       	breq	.-44     	; 0x604 <vCoRoutineSchedule+0x1d0>
     630:	20 93 74 00 	sts	0x0074, r18
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     634:	fc 01       	movw	r30, r24
     636:	ee 0f       	add	r30, r30
     638:	ff 1f       	adc	r31, r31
     63a:	ee 0f       	add	r30, r30
     63c:	ff 1f       	adc	r31, r31
     63e:	ee 0f       	add	r30, r30
     640:	ff 1f       	adc	r31, r31
     642:	8e 0f       	add	r24, r30
     644:	9f 1f       	adc	r25, r31
     646:	fc 01       	movw	r30, r24
     648:	eb 58       	subi	r30, 0x8B	; 139
     64a:	ff 4f       	sbci	r31, 0xFF	; 255
     64c:	a1 81       	ldd	r26, Z+1	; 0x01
     64e:	b2 81       	ldd	r27, Z+2	; 0x02
     650:	12 96       	adiw	r26, 0x02	; 2
     652:	0d 90       	ld	r0, X+
     654:	bc 91       	ld	r27, X
     656:	a0 2d       	mov	r26, r0
     658:	b2 83       	std	Z+2, r27	; 0x02
     65a:	a1 83       	std	Z+1, r26	; 0x01
     65c:	cf 01       	movw	r24, r30
     65e:	03 96       	adiw	r24, 0x03	; 3
     660:	a8 17       	cp	r26, r24
     662:	b9 07       	cpc	r27, r25
     664:	31 f4       	brne	.+12     	; 0x672 <vCoRoutineSchedule+0x23e>
     666:	12 96       	adiw	r26, 0x02	; 2
     668:	8d 91       	ld	r24, X+
     66a:	9c 91       	ld	r25, X
     66c:	13 97       	sbiw	r26, 0x03	; 3
     66e:	92 83       	std	Z+2, r25	; 0x02
     670:	81 83       	std	Z+1, r24	; 0x01
     672:	01 80       	ldd	r0, Z+1	; 0x01
     674:	f2 81       	ldd	r31, Z+2	; 0x02
     676:	e0 2d       	mov	r30, r0
     678:	a6 81       	ldd	r26, Z+6	; 0x06
     67a:	b7 81       	ldd	r27, Z+7	; 0x07
     67c:	b0 93 73 00 	sts	0x0073, r27
     680:	a0 93 72 00 	sts	0x0072, r26

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     684:	ed 91       	ld	r30, X+
     686:	fc 91       	ld	r31, X
     688:	11 97       	sbiw	r26, 0x01	; 1
     68a:	cd 01       	movw	r24, r26
     68c:	57 96       	adiw	r26, 0x17	; 23
     68e:	6c 91       	ld	r22, X
     690:	09 95       	icall

	return;
}
     692:	df 91       	pop	r29
     694:	cf 91       	pop	r28
     696:	1f 91       	pop	r17
     698:	0f 91       	pop	r16
     69a:	ff 90       	pop	r15
     69c:	ef 90       	pop	r14
     69e:	df 90       	pop	r13
     6a0:	cf 90       	pop	r12
     6a2:	08 95       	ret

000006a4 <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
     6a4:	0f 93       	push	r16
     6a6:	1f 93       	push	r17
     6a8:	cf 93       	push	r28
     6aa:	df 93       	push	r29
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     6ac:	dc 01       	movw	r26, r24
     6ae:	15 96       	adiw	r26, 0x05	; 5
     6b0:	ed 91       	ld	r30, X+
     6b2:	fc 91       	ld	r31, X
     6b4:	16 97       	sbiw	r26, 0x06	; 6
     6b6:	06 81       	ldd	r16, Z+6	; 0x06
     6b8:	17 81       	ldd	r17, Z+7	; 0x07
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     6ba:	e8 01       	movw	r28, r16
     6bc:	2c 96       	adiw	r28, 0x0c	; 12
     6be:	ce 01       	movw	r24, r28
     6c0:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     6c4:	89 e9       	ldi	r24, 0x99	; 153
     6c6:	90 e0       	ldi	r25, 0x00	; 0
     6c8:	be 01       	movw	r22, r28
     6ca:	0e 94 8b 03 	call	0x716	; 0x716 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
     6ce:	e0 91 72 00 	lds	r30, 0x0072
     6d2:	f0 91 73 00 	lds	r31, 0x0073
	{
		xReturn = pdTRUE;
     6d6:	81 e0       	ldi	r24, 0x01	; 1
     6d8:	d8 01       	movw	r26, r16
     6da:	56 96       	adiw	r26, 0x16	; 22
     6dc:	2c 91       	ld	r18, X
     6de:	56 97       	sbiw	r26, 0x16	; 22
     6e0:	96 89       	ldd	r25, Z+22	; 0x16
     6e2:	29 17       	cp	r18, r25
     6e4:	08 f4       	brcc	.+2      	; 0x6e8 <xCoRoutineRemoveFromEventList+0x44>
     6e6:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
     6e8:	df 91       	pop	r29
     6ea:	cf 91       	pop	r28
     6ec:	1f 91       	pop	r17
     6ee:	0f 91       	pop	r16
     6f0:	08 95       	ret

000006f2 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     6f2:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     6f4:	03 96       	adiw	r24, 0x03	; 3
     6f6:	92 83       	std	Z+2, r25	; 0x02
     6f8:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     6fa:	2f ef       	ldi	r18, 0xFF	; 255
     6fc:	3f ef       	ldi	r19, 0xFF	; 255
     6fe:	34 83       	std	Z+4, r19	; 0x04
     700:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     702:	96 83       	std	Z+6, r25	; 0x06
     704:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     706:	90 87       	std	Z+8, r25	; 0x08
     708:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     70a:	10 82       	st	Z, r1
}
     70c:	08 95       	ret

0000070e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     70e:	fc 01       	movw	r30, r24
     710:	11 86       	std	Z+9, r1	; 0x09
     712:	10 86       	std	Z+8, r1	; 0x08
}
     714:	08 95       	ret

00000716 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     716:	cf 93       	push	r28
     718:	df 93       	push	r29
     71a:	ec 01       	movw	r28, r24
     71c:	fb 01       	movw	r30, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     71e:	89 81       	ldd	r24, Y+1	; 0x01
     720:	9a 81       	ldd	r25, Y+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
     722:	dc 01       	movw	r26, r24
     724:	12 96       	adiw	r26, 0x02	; 2
     726:	2d 91       	ld	r18, X+
     728:	3c 91       	ld	r19, X
     72a:	13 97       	sbiw	r26, 0x03	; 3
     72c:	33 83       	std	Z+3, r19	; 0x03
     72e:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
     730:	29 81       	ldd	r18, Y+1	; 0x01
     732:	3a 81       	ldd	r19, Y+2	; 0x02
     734:	35 83       	std	Z+5, r19	; 0x05
     736:	24 83       	std	Z+4, r18	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     738:	12 96       	adiw	r26, 0x02	; 2
     73a:	2d 91       	ld	r18, X+
     73c:	3c 91       	ld	r19, X
     73e:	13 97       	sbiw	r26, 0x03	; 3
     740:	d9 01       	movw	r26, r18
     742:	15 96       	adiw	r26, 0x05	; 5
     744:	7c 93       	st	X, r23
     746:	6e 93       	st	-X, r22
     748:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     74a:	dc 01       	movw	r26, r24
     74c:	13 96       	adiw	r26, 0x03	; 3
     74e:	7c 93       	st	X, r23
     750:	6e 93       	st	-X, r22
     752:	12 97       	sbiw	r26, 0x02	; 2
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     754:	7a 83       	std	Y+2, r23	; 0x02
     756:	69 83       	std	Y+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     758:	d1 87       	std	Z+9, r29	; 0x09
     75a:	c0 87       	std	Z+8, r28	; 0x08

	( pxList->uxNumberOfItems )++;
     75c:	88 81       	ld	r24, Y
     75e:	8f 5f       	subi	r24, 0xFF	; 255
     760:	88 83       	st	Y, r24
}
     762:	df 91       	pop	r29
     764:	cf 91       	pop	r28
     766:	08 95       	ret

00000768 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     768:	cf 93       	push	r28
     76a:	df 93       	push	r29
     76c:	ac 01       	movw	r20, r24
     76e:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     770:	28 81       	ld	r18, Y
     772:	39 81       	ldd	r19, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     774:	8f ef       	ldi	r24, 0xFF	; 255
     776:	2f 3f       	cpi	r18, 0xFF	; 255
     778:	38 07       	cpc	r19, r24
     77a:	21 f4       	brne	.+8      	; 0x784 <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     77c:	fa 01       	movw	r30, r20
     77e:	a7 81       	ldd	r26, Z+7	; 0x07
     780:	b0 85       	ldd	r27, Z+8	; 0x08
     782:	18 c0       	rjmp	.+48     	; 0x7b4 <vListInsert+0x4c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     784:	da 01       	movw	r26, r20
     786:	13 96       	adiw	r26, 0x03	; 3
     788:	fa 01       	movw	r30, r20
     78a:	85 81       	ldd	r24, Z+5	; 0x05
     78c:	96 81       	ldd	r25, Z+6	; 0x06
     78e:	fc 01       	movw	r30, r24
     790:	80 81       	ld	r24, Z
     792:	91 81       	ldd	r25, Z+1	; 0x01
     794:	28 17       	cp	r18, r24
     796:	39 07       	cpc	r19, r25
     798:	68 f0       	brcs	.+26     	; 0x7b4 <vListInsert+0x4c>
     79a:	12 96       	adiw	r26, 0x02	; 2
     79c:	0d 90       	ld	r0, X+
     79e:	bc 91       	ld	r27, X
     7a0:	a0 2d       	mov	r26, r0
     7a2:	12 96       	adiw	r26, 0x02	; 2
     7a4:	ed 91       	ld	r30, X+
     7a6:	fc 91       	ld	r31, X
     7a8:	13 97       	sbiw	r26, 0x03	; 3
     7aa:	80 81       	ld	r24, Z
     7ac:	91 81       	ldd	r25, Z+1	; 0x01
     7ae:	28 17       	cp	r18, r24
     7b0:	39 07       	cpc	r19, r25
     7b2:	98 f7       	brcc	.-26     	; 0x79a <vListInsert+0x32>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     7b4:	12 96       	adiw	r26, 0x02	; 2
     7b6:	ed 91       	ld	r30, X+
     7b8:	fc 91       	ld	r31, X
     7ba:	13 97       	sbiw	r26, 0x03	; 3
     7bc:	fb 83       	std	Y+3, r31	; 0x03
     7be:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     7c0:	d5 83       	std	Z+5, r29	; 0x05
     7c2:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     7c4:	bd 83       	std	Y+5, r27	; 0x05
     7c6:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     7c8:	13 96       	adiw	r26, 0x03	; 3
     7ca:	dc 93       	st	X, r29
     7cc:	ce 93       	st	-X, r28
     7ce:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     7d0:	59 87       	std	Y+9, r21	; 0x09
     7d2:	48 87       	std	Y+8, r20	; 0x08

	( pxList->uxNumberOfItems )++;
     7d4:	fa 01       	movw	r30, r20
     7d6:	80 81       	ld	r24, Z
     7d8:	8f 5f       	subi	r24, 0xFF	; 255
     7da:	80 83       	st	Z, r24
}
     7dc:	df 91       	pop	r29
     7de:	cf 91       	pop	r28
     7e0:	08 95       	ret

000007e2 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     7e2:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     7e4:	a2 81       	ldd	r26, Z+2	; 0x02
     7e6:	b3 81       	ldd	r27, Z+3	; 0x03
     7e8:	84 81       	ldd	r24, Z+4	; 0x04
     7ea:	95 81       	ldd	r25, Z+5	; 0x05
     7ec:	15 96       	adiw	r26, 0x05	; 5
     7ee:	9c 93       	st	X, r25
     7f0:	8e 93       	st	-X, r24
     7f2:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     7f4:	a4 81       	ldd	r26, Z+4	; 0x04
     7f6:	b5 81       	ldd	r27, Z+5	; 0x05
     7f8:	82 81       	ldd	r24, Z+2	; 0x02
     7fa:	93 81       	ldd	r25, Z+3	; 0x03
     7fc:	13 96       	adiw	r26, 0x03	; 3
     7fe:	9c 93       	st	X, r25
     800:	8e 93       	st	-X, r24
     802:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     804:	a0 85       	ldd	r26, Z+8	; 0x08
     806:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     808:	11 96       	adiw	r26, 0x01	; 1
     80a:	8d 91       	ld	r24, X+
     80c:	9c 91       	ld	r25, X
     80e:	12 97       	sbiw	r26, 0x02	; 2
     810:	8e 17       	cp	r24, r30
     812:	9f 07       	cpc	r25, r31
     814:	31 f4       	brne	.+12     	; 0x822 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     816:	84 81       	ldd	r24, Z+4	; 0x04
     818:	95 81       	ldd	r25, Z+5	; 0x05
     81a:	12 96       	adiw	r26, 0x02	; 2
     81c:	9c 93       	st	X, r25
     81e:	8e 93       	st	-X, r24
     820:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
     822:	11 86       	std	Z+9, r1	; 0x09
     824:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     826:	8c 91       	ld	r24, X
     828:	81 50       	subi	r24, 0x01	; 1
     82a:	8c 93       	st	X, r24
}
     82c:	08 95       	ret

0000082e <pxPortInitialiseStack>:
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     82e:	21 e1       	ldi	r18, 0x11	; 17
     830:	fc 01       	movw	r30, r24
     832:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
     834:	31 97       	sbiw	r30, 0x01	; 1
     836:	32 e2       	ldi	r19, 0x22	; 34
     838:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
     83a:	fc 01       	movw	r30, r24
     83c:	32 97       	sbiw	r30, 0x02	; 2
     83e:	a3 e3       	ldi	r26, 0x33	; 51
     840:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     842:	fc 01       	movw	r30, r24
     844:	33 97       	sbiw	r30, 0x03	; 3
     846:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     848:	fc 01       	movw	r30, r24
     84a:	34 97       	sbiw	r30, 0x04	; 4
     84c:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
     84e:	fc 01       	movw	r30, r24
     850:	35 97       	sbiw	r30, 0x05	; 5
     852:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     854:	fc 01       	movw	r30, r24
     856:	36 97       	sbiw	r30, 0x06	; 6
     858:	60 e8       	ldi	r22, 0x80	; 128
     85a:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
     85c:	fc 01       	movw	r30, r24
     85e:	37 97       	sbiw	r30, 0x07	; 7
     860:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
     862:	fc 01       	movw	r30, r24
     864:	38 97       	sbiw	r30, 0x08	; 8
     866:	62 e0       	ldi	r22, 0x02	; 2
     868:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
     86a:	fc 01       	movw	r30, r24
     86c:	39 97       	sbiw	r30, 0x09	; 9
     86e:	63 e0       	ldi	r22, 0x03	; 3
     870:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
     872:	fc 01       	movw	r30, r24
     874:	3a 97       	sbiw	r30, 0x0a	; 10
     876:	64 e0       	ldi	r22, 0x04	; 4
     878:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
     87a:	fc 01       	movw	r30, r24
     87c:	3b 97       	sbiw	r30, 0x0b	; 11
     87e:	65 e0       	ldi	r22, 0x05	; 5
     880:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
     882:	fc 01       	movw	r30, r24
     884:	3c 97       	sbiw	r30, 0x0c	; 12
     886:	66 e0       	ldi	r22, 0x06	; 6
     888:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
     88a:	fc 01       	movw	r30, r24
     88c:	3d 97       	sbiw	r30, 0x0d	; 13
     88e:	67 e0       	ldi	r22, 0x07	; 7
     890:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
     892:	fc 01       	movw	r30, r24
     894:	3e 97       	sbiw	r30, 0x0e	; 14
     896:	68 e0       	ldi	r22, 0x08	; 8
     898:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
     89a:	fc 01       	movw	r30, r24
     89c:	3f 97       	sbiw	r30, 0x0f	; 15
     89e:	69 e0       	ldi	r22, 0x09	; 9
     8a0:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
     8a2:	fc 01       	movw	r30, r24
     8a4:	70 97       	sbiw	r30, 0x10	; 16
     8a6:	60 e1       	ldi	r22, 0x10	; 16
     8a8:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
     8aa:	fc 01       	movw	r30, r24
     8ac:	71 97       	sbiw	r30, 0x11	; 17
     8ae:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
     8b0:	fc 01       	movw	r30, r24
     8b2:	72 97       	sbiw	r30, 0x12	; 18
     8b4:	22 e1       	ldi	r18, 0x12	; 18
     8b6:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
     8b8:	fc 01       	movw	r30, r24
     8ba:	73 97       	sbiw	r30, 0x13	; 19
     8bc:	23 e1       	ldi	r18, 0x13	; 19
     8be:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
     8c0:	fc 01       	movw	r30, r24
     8c2:	74 97       	sbiw	r30, 0x14	; 20
     8c4:	24 e1       	ldi	r18, 0x14	; 20
     8c6:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
     8c8:	fc 01       	movw	r30, r24
     8ca:	75 97       	sbiw	r30, 0x15	; 21
     8cc:	25 e1       	ldi	r18, 0x15	; 21
     8ce:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
     8d0:	fc 01       	movw	r30, r24
     8d2:	76 97       	sbiw	r30, 0x16	; 22
     8d4:	26 e1       	ldi	r18, 0x16	; 22
     8d6:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
     8d8:	fc 01       	movw	r30, r24
     8da:	77 97       	sbiw	r30, 0x17	; 23
     8dc:	27 e1       	ldi	r18, 0x17	; 23
     8de:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
     8e0:	fc 01       	movw	r30, r24
     8e2:	78 97       	sbiw	r30, 0x18	; 24
     8e4:	28 e1       	ldi	r18, 0x18	; 24
     8e6:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
     8e8:	fc 01       	movw	r30, r24
     8ea:	79 97       	sbiw	r30, 0x19	; 25
     8ec:	29 e1       	ldi	r18, 0x19	; 25
     8ee:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
     8f0:	fc 01       	movw	r30, r24
     8f2:	7a 97       	sbiw	r30, 0x1a	; 26
     8f4:	20 e2       	ldi	r18, 0x20	; 32
     8f6:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
     8f8:	fc 01       	movw	r30, r24
     8fa:	7b 97       	sbiw	r30, 0x1b	; 27
     8fc:	21 e2       	ldi	r18, 0x21	; 33
     8fe:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
     900:	fc 01       	movw	r30, r24
     902:	7c 97       	sbiw	r30, 0x1c	; 28
     904:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
     906:	fc 01       	movw	r30, r24
     908:	7d 97       	sbiw	r30, 0x1d	; 29
     90a:	23 e2       	ldi	r18, 0x23	; 35
     90c:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     90e:	fc 01       	movw	r30, r24
     910:	7e 97       	sbiw	r30, 0x1e	; 30
     912:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     914:	fc 01       	movw	r30, r24
     916:	7f 97       	sbiw	r30, 0x1f	; 31
     918:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
     91a:	fc 01       	movw	r30, r24
     91c:	b0 97       	sbiw	r30, 0x20	; 32
     91e:	26 e2       	ldi	r18, 0x26	; 38
     920:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
     922:	fc 01       	movw	r30, r24
     924:	b1 97       	sbiw	r30, 0x21	; 33
     926:	27 e2       	ldi	r18, 0x27	; 39
     928:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
     92a:	fc 01       	movw	r30, r24
     92c:	b2 97       	sbiw	r30, 0x22	; 34
     92e:	28 e2       	ldi	r18, 0x28	; 40
     930:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
     932:	fc 01       	movw	r30, r24
     934:	b3 97       	sbiw	r30, 0x23	; 35
     936:	29 e2       	ldi	r18, 0x29	; 41
     938:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
     93a:	fc 01       	movw	r30, r24
     93c:	b4 97       	sbiw	r30, 0x24	; 36
     93e:	20 e3       	ldi	r18, 0x30	; 48
     940:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
     942:	fc 01       	movw	r30, r24
     944:	b5 97       	sbiw	r30, 0x25	; 37
     946:	21 e3       	ldi	r18, 0x31	; 49
     948:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
     94a:	86 97       	sbiw	r24, 0x26	; 38
}
     94c:	08 95       	ret

0000094e <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	OCR1AH = ucHighByte;
     94e:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = ucLowByte;
     950:	88 e3       	ldi	r24, 0x38	; 56
     952:	8a bd       	out	0x2a, r24	; 42

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
     954:	8b e0       	ldi	r24, 0x0B	; 11
     956:	8e bd       	out	0x2e, r24	; 46

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
     958:	89 b7       	in	r24, 0x39	; 57
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     95a:	80 61       	ori	r24, 0x10	; 16
	TIMSK = ucLowByte;
     95c:	89 bf       	out	0x39, r24	; 57
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     95e:	a0 91 8a 06 	lds	r26, 0x068A
     962:	b0 91 8b 06 	lds	r27, 0x068B
     966:	cd 91       	ld	r28, X+
     968:	cd bf       	out	0x3d, r28	; 61
     96a:	dd 91       	ld	r29, X+
     96c:	de bf       	out	0x3e, r29	; 62
     96e:	ff 91       	pop	r31
     970:	ef 91       	pop	r30
     972:	df 91       	pop	r29
     974:	cf 91       	pop	r28
     976:	bf 91       	pop	r27
     978:	af 91       	pop	r26
     97a:	9f 91       	pop	r25
     97c:	8f 91       	pop	r24
     97e:	7f 91       	pop	r23
     980:	6f 91       	pop	r22
     982:	5f 91       	pop	r21
     984:	4f 91       	pop	r20
     986:	3f 91       	pop	r19
     988:	2f 91       	pop	r18
     98a:	1f 91       	pop	r17
     98c:	0f 91       	pop	r16
     98e:	ff 90       	pop	r15
     990:	ef 90       	pop	r14
     992:	df 90       	pop	r13
     994:	cf 90       	pop	r12
     996:	bf 90       	pop	r11
     998:	af 90       	pop	r10
     99a:	9f 90       	pop	r9
     99c:	8f 90       	pop	r8
     99e:	7f 90       	pop	r7
     9a0:	6f 90       	pop	r6
     9a2:	5f 90       	pop	r5
     9a4:	4f 90       	pop	r4
     9a6:	3f 90       	pop	r3
     9a8:	2f 90       	pop	r2
     9aa:	1f 90       	pop	r1
     9ac:	0f 90       	pop	r0
     9ae:	0f be       	out	0x3f, r0	; 63
     9b0:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     9b2:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
     9b4:	81 e0       	ldi	r24, 0x01	; 1
     9b6:	08 95       	ret

000009b8 <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     9b8:	08 95       	ret

000009ba <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     9ba:	0f 92       	push	r0
     9bc:	0f b6       	in	r0, 0x3f	; 63
     9be:	f8 94       	cli
     9c0:	0f 92       	push	r0
     9c2:	1f 92       	push	r1
     9c4:	11 24       	eor	r1, r1
     9c6:	2f 92       	push	r2
     9c8:	3f 92       	push	r3
     9ca:	4f 92       	push	r4
     9cc:	5f 92       	push	r5
     9ce:	6f 92       	push	r6
     9d0:	7f 92       	push	r7
     9d2:	8f 92       	push	r8
     9d4:	9f 92       	push	r9
     9d6:	af 92       	push	r10
     9d8:	bf 92       	push	r11
     9da:	cf 92       	push	r12
     9dc:	df 92       	push	r13
     9de:	ef 92       	push	r14
     9e0:	ff 92       	push	r15
     9e2:	0f 93       	push	r16
     9e4:	1f 93       	push	r17
     9e6:	2f 93       	push	r18
     9e8:	3f 93       	push	r19
     9ea:	4f 93       	push	r20
     9ec:	5f 93       	push	r21
     9ee:	6f 93       	push	r22
     9f0:	7f 93       	push	r23
     9f2:	8f 93       	push	r24
     9f4:	9f 93       	push	r25
     9f6:	af 93       	push	r26
     9f8:	bf 93       	push	r27
     9fa:	cf 93       	push	r28
     9fc:	df 93       	push	r29
     9fe:	ef 93       	push	r30
     a00:	ff 93       	push	r31
     a02:	a0 91 8a 06 	lds	r26, 0x068A
     a06:	b0 91 8b 06 	lds	r27, 0x068B
     a0a:	0d b6       	in	r0, 0x3d	; 61
     a0c:	0d 92       	st	X+, r0
     a0e:	0e b6       	in	r0, 0x3e	; 62
     a10:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     a12:	0e 94 fa 0b 	call	0x17f4	; 0x17f4 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     a16:	a0 91 8a 06 	lds	r26, 0x068A
     a1a:	b0 91 8b 06 	lds	r27, 0x068B
     a1e:	cd 91       	ld	r28, X+
     a20:	cd bf       	out	0x3d, r28	; 61
     a22:	dd 91       	ld	r29, X+
     a24:	de bf       	out	0x3e, r29	; 62
     a26:	ff 91       	pop	r31
     a28:	ef 91       	pop	r30
     a2a:	df 91       	pop	r29
     a2c:	cf 91       	pop	r28
     a2e:	bf 91       	pop	r27
     a30:	af 91       	pop	r26
     a32:	9f 91       	pop	r25
     a34:	8f 91       	pop	r24
     a36:	7f 91       	pop	r23
     a38:	6f 91       	pop	r22
     a3a:	5f 91       	pop	r21
     a3c:	4f 91       	pop	r20
     a3e:	3f 91       	pop	r19
     a40:	2f 91       	pop	r18
     a42:	1f 91       	pop	r17
     a44:	0f 91       	pop	r16
     a46:	ff 90       	pop	r15
     a48:	ef 90       	pop	r14
     a4a:	df 90       	pop	r13
     a4c:	cf 90       	pop	r12
     a4e:	bf 90       	pop	r11
     a50:	af 90       	pop	r10
     a52:	9f 90       	pop	r9
     a54:	8f 90       	pop	r8
     a56:	7f 90       	pop	r7
     a58:	6f 90       	pop	r6
     a5a:	5f 90       	pop	r5
     a5c:	4f 90       	pop	r4
     a5e:	3f 90       	pop	r3
     a60:	2f 90       	pop	r2
     a62:	1f 90       	pop	r1
     a64:	0f 90       	pop	r0
     a66:	0f be       	out	0x3f, r0	; 63
     a68:	0f 90       	pop	r0

	asm volatile ( "ret" );
     a6a:	08 95       	ret

00000a6c <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     a6c:	0f 92       	push	r0
     a6e:	0f b6       	in	r0, 0x3f	; 63
     a70:	f8 94       	cli
     a72:	0f 92       	push	r0
     a74:	1f 92       	push	r1
     a76:	11 24       	eor	r1, r1
     a78:	2f 92       	push	r2
     a7a:	3f 92       	push	r3
     a7c:	4f 92       	push	r4
     a7e:	5f 92       	push	r5
     a80:	6f 92       	push	r6
     a82:	7f 92       	push	r7
     a84:	8f 92       	push	r8
     a86:	9f 92       	push	r9
     a88:	af 92       	push	r10
     a8a:	bf 92       	push	r11
     a8c:	cf 92       	push	r12
     a8e:	df 92       	push	r13
     a90:	ef 92       	push	r14
     a92:	ff 92       	push	r15
     a94:	0f 93       	push	r16
     a96:	1f 93       	push	r17
     a98:	2f 93       	push	r18
     a9a:	3f 93       	push	r19
     a9c:	4f 93       	push	r20
     a9e:	5f 93       	push	r21
     aa0:	6f 93       	push	r22
     aa2:	7f 93       	push	r23
     aa4:	8f 93       	push	r24
     aa6:	9f 93       	push	r25
     aa8:	af 93       	push	r26
     aaa:	bf 93       	push	r27
     aac:	cf 93       	push	r28
     aae:	df 93       	push	r29
     ab0:	ef 93       	push	r30
     ab2:	ff 93       	push	r31
     ab4:	a0 91 8a 06 	lds	r26, 0x068A
     ab8:	b0 91 8b 06 	lds	r27, 0x068B
     abc:	0d b6       	in	r0, 0x3d	; 61
     abe:	0d 92       	st	X+, r0
     ac0:	0e b6       	in	r0, 0x3e	; 62
     ac2:	0d 92       	st	X+, r0
	vTaskIncrementTick();
     ac4:	0e 94 3a 0a 	call	0x1474	; 0x1474 <vTaskIncrementTick>
	vTaskSwitchContext();
     ac8:	0e 94 fa 0b 	call	0x17f4	; 0x17f4 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     acc:	a0 91 8a 06 	lds	r26, 0x068A
     ad0:	b0 91 8b 06 	lds	r27, 0x068B
     ad4:	cd 91       	ld	r28, X+
     ad6:	cd bf       	out	0x3d, r28	; 61
     ad8:	dd 91       	ld	r29, X+
     ada:	de bf       	out	0x3e, r29	; 62
     adc:	ff 91       	pop	r31
     ade:	ef 91       	pop	r30
     ae0:	df 91       	pop	r29
     ae2:	cf 91       	pop	r28
     ae4:	bf 91       	pop	r27
     ae6:	af 91       	pop	r26
     ae8:	9f 91       	pop	r25
     aea:	8f 91       	pop	r24
     aec:	7f 91       	pop	r23
     aee:	6f 91       	pop	r22
     af0:	5f 91       	pop	r21
     af2:	4f 91       	pop	r20
     af4:	3f 91       	pop	r19
     af6:	2f 91       	pop	r18
     af8:	1f 91       	pop	r17
     afa:	0f 91       	pop	r16
     afc:	ff 90       	pop	r15
     afe:	ef 90       	pop	r14
     b00:	df 90       	pop	r13
     b02:	cf 90       	pop	r12
     b04:	bf 90       	pop	r11
     b06:	af 90       	pop	r10
     b08:	9f 90       	pop	r9
     b0a:	8f 90       	pop	r8
     b0c:	7f 90       	pop	r7
     b0e:	6f 90       	pop	r6
     b10:	5f 90       	pop	r5
     b12:	4f 90       	pop	r4
     b14:	3f 90       	pop	r3
     b16:	2f 90       	pop	r2
     b18:	1f 90       	pop	r1
     b1a:	0f 90       	pop	r0
     b1c:	0f be       	out	0x3f, r0	; 63
     b1e:	0f 90       	pop	r0

	asm volatile ( "ret" );
     b20:	08 95       	ret

00000b22 <__vector_7>:
//	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
//	void SIG_OUTPUT_COMPARE1A( void )
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     b22:	0e 94 36 05 	call	0xa6c	; 0xa6c <vPortYieldFromTick>
		asm volatile ( "reti" );
     b26:	18 95       	reti

00000b28 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     b28:	0f 93       	push	r16
     b2a:	1f 93       	push	r17
     b2c:	cf 93       	push	r28
     b2e:	df 93       	push	r29
     b30:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     b32:	0e 94 22 0a 	call	0x1444	; 0x1444 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     b36:	00 91 ac 00 	lds	r16, 0x00AC
     b3a:	10 91 ad 00 	lds	r17, 0x00AD
     b3e:	c0 0f       	add	r28, r16
     b40:	d1 1f       	adc	r29, r17
     b42:	85 e0       	ldi	r24, 0x05	; 5
     b44:	cc 3d       	cpi	r28, 0xDC	; 220
     b46:	d8 07       	cpc	r29, r24
     b48:	50 f4       	brcc	.+20     	; 0xb5e <pvPortMalloc+0x36>
     b4a:	0c 17       	cp	r16, r28
     b4c:	1d 07       	cpc	r17, r29
     b4e:	50 f4       	brcc	.+20     	; 0xb64 <pvPortMalloc+0x3c>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     b50:	02 55       	subi	r16, 0x52	; 82
     b52:	1f 4f       	sbci	r17, 0xFF	; 255
			xNextFreeByte += xWantedSize;			
     b54:	d0 93 ad 00 	sts	0x00AD, r29
     b58:	c0 93 ac 00 	sts	0x00AC, r28
     b5c:	05 c0       	rjmp	.+10     	; 0xb68 <pvPortMalloc+0x40>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
     b5e:	00 e0       	ldi	r16, 0x00	; 0
     b60:	10 e0       	ldi	r17, 0x00	; 0
     b62:	02 c0       	rjmp	.+4      	; 0xb68 <pvPortMalloc+0x40>
     b64:	00 e0       	ldi	r16, 0x00	; 0
     b66:	10 e0       	ldi	r17, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
     b68:	0e 94 00 0b 	call	0x1600	; 0x1600 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
     b6c:	80 2f       	mov	r24, r16
     b6e:	91 2f       	mov	r25, r17
     b70:	df 91       	pop	r29
     b72:	cf 91       	pop	r28
     b74:	1f 91       	pop	r17
     b76:	0f 91       	pop	r16
     b78:	08 95       	ret

00000b7a <vPortFree>:
{
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
     b7a:	08 95       	ret

00000b7c <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     b7c:	10 92 ad 00 	sts	0x00AD, r1
     b80:	10 92 ac 00 	sts	0x00AC, r1
}
     b84:	08 95       	ret

00000b86 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
     b86:	20 91 ac 00 	lds	r18, 0x00AC
     b8a:	30 91 ad 00 	lds	r19, 0x00AD
     b8e:	8c ed       	ldi	r24, 0xDC	; 220
     b90:	95 e0       	ldi	r25, 0x05	; 5
     b92:	82 1b       	sub	r24, r18
     b94:	93 0b       	sbc	r25, r19
}
     b96:	08 95       	ret

00000b98 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
     b98:	cf 93       	push	r28
     b9a:	df 93       	push	r29
     b9c:	dc 01       	movw	r26, r24
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
     b9e:	cd 91       	ld	r28, X+
     ba0:	dc 91       	ld	r29, X
     ba2:	11 97       	sbiw	r26, 0x01	; 1
     ba4:	20 97       	sbiw	r28, 0x00	; 0
     ba6:	21 f1       	breq	.+72     	; 0xbf0 <prvCopyDataFromQueue+0x58>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
     ba8:	5c 96       	adiw	r26, 0x1c	; 28
     baa:	4c 91       	ld	r20, X
     bac:	5c 97       	sbiw	r26, 0x1c	; 28
     bae:	16 96       	adiw	r26, 0x06	; 6
     bb0:	2d 91       	ld	r18, X+
     bb2:	3c 91       	ld	r19, X
     bb4:	17 97       	sbiw	r26, 0x07	; 7
     bb6:	24 0f       	add	r18, r20
     bb8:	31 1d       	adc	r19, r1
     bba:	17 96       	adiw	r26, 0x07	; 7
     bbc:	3c 93       	st	X, r19
     bbe:	2e 93       	st	-X, r18
     bc0:	16 97       	sbiw	r26, 0x06	; 6
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
     bc2:	12 96       	adiw	r26, 0x02	; 2
     bc4:	ed 91       	ld	r30, X+
     bc6:	fc 91       	ld	r31, X
     bc8:	13 97       	sbiw	r26, 0x03	; 3
     bca:	2e 17       	cp	r18, r30
     bcc:	3f 07       	cpc	r19, r31
     bce:	20 f0       	brcs	.+8      	; 0xbd8 <prvCopyDataFromQueue+0x40>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
     bd0:	17 96       	adiw	r26, 0x07	; 7
     bd2:	dc 93       	st	X, r29
     bd4:	ce 93       	st	-X, r28
     bd6:	16 97       	sbiw	r26, 0x06	; 6
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
     bd8:	16 96       	adiw	r26, 0x06	; 6
     bda:	3c 91       	ld	r19, X
     bdc:	16 97       	sbiw	r26, 0x06	; 6
     bde:	17 96       	adiw	r26, 0x07	; 7
     be0:	2c 91       	ld	r18, X
     be2:	86 2f       	mov	r24, r22
     be4:	97 2f       	mov	r25, r23
     be6:	63 2f       	mov	r22, r19
     be8:	72 2f       	mov	r23, r18
     bea:	50 e0       	ldi	r21, 0x00	; 0
     bec:	0e 94 23 0d 	call	0x1a46	; 0x1a46 <memcpy>
	}
}
     bf0:	df 91       	pop	r29
     bf2:	cf 91       	pop	r28
     bf4:	08 95       	ret

00000bf6 <prvCopyDataToQueue>:

#endif
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
     bf6:	cf 93       	push	r28
     bf8:	df 93       	push	r29
     bfa:	ec 01       	movw	r28, r24
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
     bfc:	2c 8d       	ldd	r18, Y+28	; 0x1c
     bfe:	22 23       	and	r18, r18
     c00:	a9 f1       	breq	.+106    	; 0xc6c <prvCopyDataToQueue+0x76>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
     c02:	44 23       	and	r20, r20
     c04:	b9 f4       	brne	.+46     	; 0xc34 <prvCopyDataToQueue+0x3e>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
     c06:	8c 81       	ldd	r24, Y+4	; 0x04
     c08:	9d 81       	ldd	r25, Y+5	; 0x05
     c0a:	42 2f       	mov	r20, r18
     c0c:	50 e0       	ldi	r21, 0x00	; 0
     c0e:	0e 94 23 0d 	call	0x1a46	; 0x1a46 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     c12:	2c 8d       	ldd	r18, Y+28	; 0x1c
     c14:	8c 81       	ldd	r24, Y+4	; 0x04
     c16:	9d 81       	ldd	r25, Y+5	; 0x05
     c18:	82 0f       	add	r24, r18
     c1a:	91 1d       	adc	r25, r1
     c1c:	9d 83       	std	Y+5, r25	; 0x05
     c1e:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
     c20:	2a 81       	ldd	r18, Y+2	; 0x02
     c22:	3b 81       	ldd	r19, Y+3	; 0x03
     c24:	82 17       	cp	r24, r18
     c26:	93 07       	cpc	r25, r19
     c28:	08 f1       	brcs	.+66     	; 0xc6c <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     c2a:	88 81       	ld	r24, Y
     c2c:	99 81       	ldd	r25, Y+1	; 0x01
     c2e:	9d 83       	std	Y+5, r25	; 0x05
     c30:	8c 83       	std	Y+4, r24	; 0x04
     c32:	1c c0       	rjmp	.+56     	; 0xc6c <prvCopyDataToQueue+0x76>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
     c34:	8e 81       	ldd	r24, Y+6	; 0x06
     c36:	9f 81       	ldd	r25, Y+7	; 0x07
     c38:	42 2f       	mov	r20, r18
     c3a:	50 e0       	ldi	r21, 0x00	; 0
     c3c:	0e 94 23 0d 	call	0x1a46	; 0x1a46 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
     c40:	4c 8d       	ldd	r20, Y+28	; 0x1c
     c42:	50 e0       	ldi	r21, 0x00	; 0
     c44:	50 95       	com	r21
     c46:	41 95       	neg	r20
     c48:	5f 4f       	sbci	r21, 0xFF	; 255
     c4a:	8e 81       	ldd	r24, Y+6	; 0x06
     c4c:	9f 81       	ldd	r25, Y+7	; 0x07
     c4e:	84 0f       	add	r24, r20
     c50:	95 1f       	adc	r25, r21
     c52:	9f 83       	std	Y+7, r25	; 0x07
     c54:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
     c56:	28 81       	ld	r18, Y
     c58:	39 81       	ldd	r19, Y+1	; 0x01
     c5a:	82 17       	cp	r24, r18
     c5c:	93 07       	cpc	r25, r19
     c5e:	30 f4       	brcc	.+12     	; 0xc6c <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     c60:	8a 81       	ldd	r24, Y+2	; 0x02
     c62:	9b 81       	ldd	r25, Y+3	; 0x03
     c64:	48 0f       	add	r20, r24
     c66:	59 1f       	adc	r21, r25
     c68:	5f 83       	std	Y+7, r21	; 0x07
     c6a:	4e 83       	std	Y+6, r20	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
     c6c:	8a 8d       	ldd	r24, Y+26	; 0x1a
     c6e:	8f 5f       	subi	r24, 0xFF	; 255
     c70:	8a 8f       	std	Y+26, r24	; 0x1a
}
     c72:	df 91       	pop	r29
     c74:	cf 91       	pop	r28
     c76:	08 95       	ret

00000c78 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
     c78:	0f 93       	push	r16
     c7a:	1f 93       	push	r17
     c7c:	cf 93       	push	r28
     c7e:	df 93       	push	r29
     c80:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
     c82:	0f b6       	in	r0, 0x3f	; 63
     c84:	f8 94       	cli
     c86:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     c88:	8e 8d       	ldd	r24, Y+30	; 0x1e
     c8a:	18 16       	cp	r1, r24
     c8c:	bc f4       	brge	.+46     	; 0xcbc <prvUnlockQueue+0x44>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     c8e:	89 89       	ldd	r24, Y+17	; 0x11
     c90:	88 23       	and	r24, r24
     c92:	29 f4       	brne	.+10     	; 0xc9e <prvUnlockQueue+0x26>
     c94:	13 c0       	rjmp	.+38     	; 0xcbc <prvUnlockQueue+0x44>
     c96:	89 89       	ldd	r24, Y+17	; 0x11
     c98:	88 23       	and	r24, r24
     c9a:	21 f4       	brne	.+8      	; 0xca4 <prvUnlockQueue+0x2c>
     c9c:	0f c0       	rjmp	.+30     	; 0xcbc <prvUnlockQueue+0x44>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     c9e:	8e 01       	movw	r16, r28
     ca0:	0f 5e       	subi	r16, 0xEF	; 239
     ca2:	1f 4f       	sbci	r17, 0xFF	; 255
     ca4:	c8 01       	movw	r24, r16
     ca6:	0e 94 74 0c 	call	0x18e8	; 0x18e8 <xTaskRemoveFromEventList>
     caa:	88 23       	and	r24, r24
     cac:	11 f0       	breq	.+4      	; 0xcb2 <prvUnlockQueue+0x3a>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
     cae:	0e 94 fd 0c 	call	0x19fa	; 0x19fa <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
     cb2:	8e 8d       	ldd	r24, Y+30	; 0x1e
     cb4:	81 50       	subi	r24, 0x01	; 1
     cb6:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     cb8:	18 16       	cp	r1, r24
     cba:	6c f3       	brlt	.-38     	; 0xc96 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
     cbc:	8f ef       	ldi	r24, 0xFF	; 255
     cbe:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
     cc0:	0f 90       	pop	r0
     cc2:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
     cc4:	0f b6       	in	r0, 0x3f	; 63
     cc6:	f8 94       	cli
     cc8:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     cca:	8d 8d       	ldd	r24, Y+29	; 0x1d
     ccc:	18 16       	cp	r1, r24
     cce:	bc f4       	brge	.+46     	; 0xcfe <prvUnlockQueue+0x86>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     cd0:	88 85       	ldd	r24, Y+8	; 0x08
     cd2:	88 23       	and	r24, r24
     cd4:	29 f4       	brne	.+10     	; 0xce0 <prvUnlockQueue+0x68>
     cd6:	13 c0       	rjmp	.+38     	; 0xcfe <prvUnlockQueue+0x86>
     cd8:	88 85       	ldd	r24, Y+8	; 0x08
     cda:	88 23       	and	r24, r24
     cdc:	21 f4       	brne	.+8      	; 0xce6 <prvUnlockQueue+0x6e>
     cde:	0f c0       	rjmp	.+30     	; 0xcfe <prvUnlockQueue+0x86>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     ce0:	8e 01       	movw	r16, r28
     ce2:	08 5f       	subi	r16, 0xF8	; 248
     ce4:	1f 4f       	sbci	r17, 0xFF	; 255
     ce6:	c8 01       	movw	r24, r16
     ce8:	0e 94 74 0c 	call	0x18e8	; 0x18e8 <xTaskRemoveFromEventList>
     cec:	88 23       	and	r24, r24
     cee:	11 f0       	breq	.+4      	; 0xcf4 <prvUnlockQueue+0x7c>
				{
					vTaskMissedYield();
     cf0:	0e 94 fd 0c 	call	0x19fa	; 0x19fa <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
     cf4:	8d 8d       	ldd	r24, Y+29	; 0x1d
     cf6:	81 50       	subi	r24, 0x01	; 1
     cf8:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     cfa:	18 16       	cp	r1, r24
     cfc:	6c f3       	brlt	.-38     	; 0xcd8 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
     cfe:	8f ef       	ldi	r24, 0xFF	; 255
     d00:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
     d02:	0f 90       	pop	r0
     d04:	0f be       	out	0x3f, r0	; 63
}
     d06:	df 91       	pop	r29
     d08:	cf 91       	pop	r28
     d0a:	1f 91       	pop	r17
     d0c:	0f 91       	pop	r16
     d0e:	08 95       	ret

00000d10 <xQueueGenericCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
     d10:	af 92       	push	r10
     d12:	bf 92       	push	r11
     d14:	cf 92       	push	r12
     d16:	df 92       	push	r13
     d18:	ef 92       	push	r14
     d1a:	ff 92       	push	r15
     d1c:	0f 93       	push	r16
     d1e:	1f 93       	push	r17
     d20:	cf 93       	push	r28
     d22:	df 93       	push	r29
     d24:	f8 2e       	mov	r15, r24
     d26:	e6 2e       	mov	r14, r22
	/* Remove compiler warnings about unused parameters should 
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
     d28:	88 23       	and	r24, r24
     d2a:	09 f4       	brne	.+2      	; 0xd2e <xQueueGenericCreate+0x1e>
     d2c:	46 c0       	rjmp	.+140    	; 0xdba <xQueueGenericCreate+0xaa>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
     d2e:	8f e1       	ldi	r24, 0x1F	; 31
     d30:	90 e0       	ldi	r25, 0x00	; 0
     d32:	0e 94 94 05 	call	0xb28	; 0xb28 <pvPortMalloc>
     d36:	8c 01       	movw	r16, r24
		if( pxNewQueue != NULL )
     d38:	00 97       	sbiw	r24, 0x00	; 0
     d3a:	09 f4       	brne	.+2      	; 0xd3e <xQueueGenericCreate+0x2e>
     d3c:	41 c0       	rjmp	.+130    	; 0xdc0 <xQueueGenericCreate+0xb0>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
     d3e:	cf 2c       	mov	r12, r15
     d40:	dd 24       	eor	r13, r13
     d42:	ae 2c       	mov	r10, r14
     d44:	bb 24       	eor	r11, r11
     d46:	ca 9c       	mul	r12, r10
     d48:	e0 01       	movw	r28, r0
     d4a:	cb 9c       	mul	r12, r11
     d4c:	d0 0d       	add	r29, r0
     d4e:	da 9c       	mul	r13, r10
     d50:	d0 0d       	add	r29, r0
     d52:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
     d54:	ce 01       	movw	r24, r28
     d56:	01 96       	adiw	r24, 0x01	; 1
     d58:	0e 94 94 05 	call	0xb28	; 0xb28 <pvPortMalloc>
     d5c:	ac 01       	movw	r20, r24
     d5e:	f8 01       	movw	r30, r16
     d60:	91 83       	std	Z+1, r25	; 0x01
     d62:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
     d64:	00 97       	sbiw	r24, 0x00	; 0
     d66:	19 f1       	breq	.+70     	; 0xdae <xQueueGenericCreate+0x9e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
     d68:	c8 0f       	add	r28, r24
     d6a:	d9 1f       	adc	r29, r25
     d6c:	d3 83       	std	Z+3, r29	; 0x03
     d6e:	c2 83       	std	Z+2, r28	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
     d70:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
     d72:	95 83       	std	Z+5, r25	; 0x05
     d74:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
     d76:	c6 01       	movw	r24, r12
     d78:	01 97       	sbiw	r24, 0x01	; 1
     d7a:	a8 9e       	mul	r10, r24
     d7c:	90 01       	movw	r18, r0
     d7e:	a9 9e       	mul	r10, r25
     d80:	30 0d       	add	r19, r0
     d82:	b8 9e       	mul	r11, r24
     d84:	30 0d       	add	r19, r0
     d86:	11 24       	eor	r1, r1
     d88:	24 0f       	add	r18, r20
     d8a:	35 1f       	adc	r19, r21
     d8c:	37 83       	std	Z+7, r19	; 0x07
     d8e:	26 83       	std	Z+6, r18	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
     d90:	f3 8e       	std	Z+27, r15	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
     d92:	e4 8e       	std	Z+28, r14	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
     d94:	8f ef       	ldi	r24, 0xFF	; 255
     d96:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
     d98:	86 8f       	std	Z+30, r24	; 0x1e
					pxNewQueue->ucQueueType = ucQueueType;
				}
				#endif /* configUSE_TRACE_FACILITY */

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
     d9a:	c8 01       	movw	r24, r16
     d9c:	08 96       	adiw	r24, 0x08	; 8
     d9e:	0e 94 79 03 	call	0x6f2	; 0x6f2 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
     da2:	c8 01       	movw	r24, r16
     da4:	41 96       	adiw	r24, 0x11	; 17
     da6:	0e 94 79 03 	call	0x6f2	; 0x6f2 <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
     daa:	c8 01       	movw	r24, r16
     dac:	0b c0       	rjmp	.+22     	; 0xdc4 <xQueueGenericCreate+0xb4>
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
     dae:	c8 01       	movw	r24, r16
     db0:	0e 94 bd 05 	call	0xb7a	; 0xb7a <vPortFree>

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
     db4:	80 e0       	ldi	r24, 0x00	; 0
     db6:	90 e0       	ldi	r25, 0x00	; 0
     db8:	05 c0       	rjmp	.+10     	; 0xdc4 <xQueueGenericCreate+0xb4>
     dba:	80 e0       	ldi	r24, 0x00	; 0
     dbc:	90 e0       	ldi	r25, 0x00	; 0
     dbe:	02 c0       	rjmp	.+4      	; 0xdc4 <xQueueGenericCreate+0xb4>
     dc0:	80 e0       	ldi	r24, 0x00	; 0
     dc2:	90 e0       	ldi	r25, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
     dc4:	df 91       	pop	r29
     dc6:	cf 91       	pop	r28
     dc8:	1f 91       	pop	r17
     dca:	0f 91       	pop	r16
     dcc:	ff 90       	pop	r15
     dce:	ef 90       	pop	r14
     dd0:	df 90       	pop	r13
     dd2:	cf 90       	pop	r12
     dd4:	bf 90       	pop	r11
     dd6:	af 90       	pop	r10
     dd8:	08 95       	ret

00000dda <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
     dda:	8f 92       	push	r8
     ddc:	9f 92       	push	r9
     dde:	bf 92       	push	r11
     de0:	cf 92       	push	r12
     de2:	df 92       	push	r13
     de4:	ef 92       	push	r14
     de6:	ff 92       	push	r15
     de8:	0f 93       	push	r16
     dea:	1f 93       	push	r17
     dec:	cf 93       	push	r28
     dee:	df 93       	push	r29
     df0:	00 d0       	rcall	.+0      	; 0xdf2 <xQueueGenericSend+0x18>
     df2:	00 d0       	rcall	.+0      	; 0xdf4 <xQueueGenericSend+0x1a>
     df4:	0f 92       	push	r0
     df6:	cd b7       	in	r28, 0x3d	; 61
     df8:	de b7       	in	r29, 0x3e	; 62
     dfa:	8c 01       	movw	r16, r24
     dfc:	4b 01       	movw	r8, r22
     dfe:	5d 83       	std	Y+5, r21	; 0x05
     e00:	4c 83       	std	Y+4, r20	; 0x04
     e02:	b2 2e       	mov	r11, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
     e04:	ff 24       	eor	r15, r15
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     e06:	ee 24       	eor	r14, r14
     e08:	e3 94       	inc	r14
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     e0a:	cc 24       	eor	r12, r12
     e0c:	dd 24       	eor	r13, r13
     e0e:	68 94       	set
     e10:	c3 f8       	bld	r12, 3
     e12:	c8 0e       	add	r12, r24
     e14:	d9 1e       	adc	r13, r25
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
     e16:	0f b6       	in	r0, 0x3f	; 63
     e18:	f8 94       	cli
     e1a:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
     e1c:	f8 01       	movw	r30, r16
     e1e:	92 8d       	ldd	r25, Z+26	; 0x1a
     e20:	83 8d       	ldd	r24, Z+27	; 0x1b
     e22:	98 17       	cp	r25, r24
     e24:	a8 f4       	brcc	.+42     	; 0xe50 <xQueueGenericSend+0x76>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     e26:	c8 01       	movw	r24, r16
     e28:	b4 01       	movw	r22, r8
     e2a:	4b 2d       	mov	r20, r11
     e2c:	0e 94 fb 05 	call	0xbf6	; 0xbf6 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     e30:	f8 01       	movw	r30, r16
     e32:	81 89       	ldd	r24, Z+17	; 0x11
     e34:	88 23       	and	r24, r24
     e36:	41 f0       	breq	.+16     	; 0xe48 <xQueueGenericSend+0x6e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
     e38:	c8 01       	movw	r24, r16
     e3a:	41 96       	adiw	r24, 0x11	; 17
     e3c:	0e 94 74 0c 	call	0x18e8	; 0x18e8 <xTaskRemoveFromEventList>
     e40:	81 30       	cpi	r24, 0x01	; 1
     e42:	11 f4       	brne	.+4      	; 0xe48 <xQueueGenericSend+0x6e>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
     e44:	0e 94 dd 04 	call	0x9ba	; 0x9ba <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
     e48:	0f 90       	pop	r0
     e4a:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
     e4c:	81 e0       	ldi	r24, 0x01	; 1
     e4e:	52 c0       	rjmp	.+164    	; 0xef4 <xQueueGenericSend+0x11a>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
     e50:	8c 81       	ldd	r24, Y+4	; 0x04
     e52:	9d 81       	ldd	r25, Y+5	; 0x05
     e54:	00 97       	sbiw	r24, 0x00	; 0
     e56:	21 f4       	brne	.+8      	; 0xe60 <xQueueGenericSend+0x86>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     e58:	0f 90       	pop	r0
     e5a:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
     e5c:	80 e0       	ldi	r24, 0x00	; 0
     e5e:	4a c0       	rjmp	.+148    	; 0xef4 <xQueueGenericSend+0x11a>
				}
				else if( xEntryTimeSet == pdFALSE )
     e60:	ff 20       	and	r15, r15
     e62:	29 f4       	brne	.+10     	; 0xe6e <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     e64:	ce 01       	movw	r24, r28
     e66:	01 96       	adiw	r24, 0x01	; 1
     e68:	0e 94 bc 0c 	call	0x1978	; 0x1978 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     e6c:	fe 2c       	mov	r15, r14
				}
			}
		}
		taskEXIT_CRITICAL();
     e6e:	0f 90       	pop	r0
     e70:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     e72:	0e 94 22 0a 	call	0x1444	; 0x1444 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     e76:	0f b6       	in	r0, 0x3f	; 63
     e78:	f8 94       	cli
     e7a:	0f 92       	push	r0
     e7c:	f8 01       	movw	r30, r16
     e7e:	85 8d       	ldd	r24, Z+29	; 0x1d
     e80:	8f 3f       	cpi	r24, 0xFF	; 255
     e82:	09 f4       	brne	.+2      	; 0xe86 <xQueueGenericSend+0xac>
     e84:	15 8e       	std	Z+29, r1	; 0x1d
     e86:	f8 01       	movw	r30, r16
     e88:	86 8d       	ldd	r24, Z+30	; 0x1e
     e8a:	8f 3f       	cpi	r24, 0xFF	; 255
     e8c:	09 f4       	brne	.+2      	; 0xe90 <xQueueGenericSend+0xb6>
     e8e:	16 8e       	std	Z+30, r1	; 0x1e
     e90:	0f 90       	pop	r0
     e92:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     e94:	ce 01       	movw	r24, r28
     e96:	01 96       	adiw	r24, 0x01	; 1
     e98:	be 01       	movw	r22, r28
     e9a:	6c 5f       	subi	r22, 0xFC	; 252
     e9c:	7f 4f       	sbci	r23, 0xFF	; 255
     e9e:	0e 94 c7 0c 	call	0x198e	; 0x198e <xTaskCheckForTimeOut>
     ea2:	88 23       	and	r24, r24
     ea4:	09 f5       	brne	.+66     	; 0xee8 <xQueueGenericSend+0x10e>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
     ea6:	0f b6       	in	r0, 0x3f	; 63
     ea8:	f8 94       	cli
     eaa:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
     eac:	f8 01       	movw	r30, r16
     eae:	92 8d       	ldd	r25, Z+26	; 0x1a
	taskEXIT_CRITICAL();
     eb0:	0f 90       	pop	r0
     eb2:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
     eb4:	f8 01       	movw	r30, r16
     eb6:	83 8d       	ldd	r24, Z+27	; 0x1b
     eb8:	98 17       	cp	r25, r24
     eba:	81 f4       	brne	.+32     	; 0xedc <xQueueGenericSend+0x102>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     ebc:	6c 81       	ldd	r22, Y+4	; 0x04
     ebe:	7d 81       	ldd	r23, Y+5	; 0x05
     ec0:	c6 01       	movw	r24, r12
     ec2:	0e 94 57 0c 	call	0x18ae	; 0x18ae <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
     ec6:	c8 01       	movw	r24, r16
     ec8:	0e 94 3c 06 	call	0xc78	; 0xc78 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
     ecc:	0e 94 00 0b 	call	0x1600	; 0x1600 <xTaskResumeAll>
     ed0:	88 23       	and	r24, r24
     ed2:	09 f0       	breq	.+2      	; 0xed6 <xQueueGenericSend+0xfc>
     ed4:	a0 cf       	rjmp	.-192    	; 0xe16 <xQueueGenericSend+0x3c>
				{
					portYIELD_WITHIN_API();
     ed6:	0e 94 dd 04 	call	0x9ba	; 0x9ba <vPortYield>
     eda:	9d cf       	rjmp	.-198    	; 0xe16 <xQueueGenericSend+0x3c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     edc:	c8 01       	movw	r24, r16
     ede:	0e 94 3c 06 	call	0xc78	; 0xc78 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     ee2:	0e 94 00 0b 	call	0x1600	; 0x1600 <xTaskResumeAll>
     ee6:	97 cf       	rjmp	.-210    	; 0xe16 <xQueueGenericSend+0x3c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
     ee8:	c8 01       	movw	r24, r16
     eea:	0e 94 3c 06 	call	0xc78	; 0xc78 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     eee:	0e 94 00 0b 	call	0x1600	; 0x1600 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
     ef2:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     ef4:	0f 90       	pop	r0
     ef6:	0f 90       	pop	r0
     ef8:	0f 90       	pop	r0
     efa:	0f 90       	pop	r0
     efc:	0f 90       	pop	r0
     efe:	df 91       	pop	r29
     f00:	cf 91       	pop	r28
     f02:	1f 91       	pop	r17
     f04:	0f 91       	pop	r16
     f06:	ff 90       	pop	r15
     f08:	ef 90       	pop	r14
     f0a:	df 90       	pop	r13
     f0c:	cf 90       	pop	r12
     f0e:	bf 90       	pop	r11
     f10:	9f 90       	pop	r9
     f12:	8f 90       	pop	r8
     f14:	08 95       	ret

00000f16 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
     f16:	0f 93       	push	r16
     f18:	1f 93       	push	r17
     f1a:	cf 93       	push	r28
     f1c:	df 93       	push	r29
     f1e:	ec 01       	movw	r28, r24
     f20:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
     f22:	9a 8d       	ldd	r25, Y+26	; 0x1a
     f24:	8b 8d       	ldd	r24, Y+27	; 0x1b
     f26:	98 17       	cp	r25, r24
     f28:	c0 f4       	brcc	.+48     	; 0xf5a <xQueueGenericSendFromISR+0x44>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     f2a:	ce 01       	movw	r24, r28
     f2c:	42 2f       	mov	r20, r18
     f2e:	0e 94 fb 05 	call	0xbf6	; 0xbf6 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
     f32:	8e 8d       	ldd	r24, Y+30	; 0x1e
     f34:	8f 3f       	cpi	r24, 0xFF	; 255
     f36:	69 f4       	brne	.+26     	; 0xf52 <xQueueGenericSendFromISR+0x3c>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     f38:	89 89       	ldd	r24, Y+17	; 0x11
     f3a:	88 23       	and	r24, r24
     f3c:	81 f0       	breq	.+32     	; 0xf5e <xQueueGenericSendFromISR+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     f3e:	ce 01       	movw	r24, r28
     f40:	41 96       	adiw	r24, 0x11	; 17
     f42:	0e 94 74 0c 	call	0x18e8	; 0x18e8 <xTaskRemoveFromEventList>
     f46:	88 23       	and	r24, r24
     f48:	61 f0       	breq	.+24     	; 0xf62 <xQueueGenericSendFromISR+0x4c>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
     f4a:	81 e0       	ldi	r24, 0x01	; 1
     f4c:	f8 01       	movw	r30, r16
     f4e:	80 83       	st	Z, r24
     f50:	09 c0       	rjmp	.+18     	; 0xf64 <xQueueGenericSendFromISR+0x4e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
     f52:	8f 5f       	subi	r24, 0xFF	; 255
     f54:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
     f56:	81 e0       	ldi	r24, 0x01	; 1
     f58:	05 c0       	rjmp	.+10     	; 0xf64 <xQueueGenericSendFromISR+0x4e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
     f5a:	80 e0       	ldi	r24, 0x00	; 0
     f5c:	03 c0       	rjmp	.+6      	; 0xf64 <xQueueGenericSendFromISR+0x4e>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
     f5e:	81 e0       	ldi	r24, 0x01	; 1
     f60:	01 c0       	rjmp	.+2      	; 0xf64 <xQueueGenericSendFromISR+0x4e>
     f62:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     f64:	df 91       	pop	r29
     f66:	cf 91       	pop	r28
     f68:	1f 91       	pop	r17
     f6a:	0f 91       	pop	r16
     f6c:	08 95       	ret

00000f6e <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
     f6e:	8f 92       	push	r8
     f70:	9f 92       	push	r9
     f72:	bf 92       	push	r11
     f74:	cf 92       	push	r12
     f76:	df 92       	push	r13
     f78:	ef 92       	push	r14
     f7a:	ff 92       	push	r15
     f7c:	0f 93       	push	r16
     f7e:	1f 93       	push	r17
     f80:	cf 93       	push	r28
     f82:	df 93       	push	r29
     f84:	00 d0       	rcall	.+0      	; 0xf86 <xQueueGenericReceive+0x18>
     f86:	00 d0       	rcall	.+0      	; 0xf88 <xQueueGenericReceive+0x1a>
     f88:	0f 92       	push	r0
     f8a:	cd b7       	in	r28, 0x3d	; 61
     f8c:	de b7       	in	r29, 0x3e	; 62
     f8e:	8c 01       	movw	r16, r24
     f90:	4b 01       	movw	r8, r22
     f92:	5d 83       	std	Y+5, r21	; 0x05
     f94:	4c 83       	std	Y+4, r20	; 0x04
     f96:	b2 2e       	mov	r11, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
     f98:	ff 24       	eor	r15, r15
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     f9a:	ee 24       	eor	r14, r14
     f9c:	e3 94       	inc	r14
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     f9e:	0f 2e       	mov	r0, r31
     fa0:	f1 e1       	ldi	r31, 0x11	; 17
     fa2:	cf 2e       	mov	r12, r31
     fa4:	dd 24       	eor	r13, r13
     fa6:	f0 2d       	mov	r31, r0
     fa8:	c8 0e       	add	r12, r24
     faa:	d9 1e       	adc	r13, r25
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     fac:	0f b6       	in	r0, 0x3f	; 63
     fae:	f8 94       	cli
     fb0:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
     fb2:	f8 01       	movw	r30, r16
     fb4:	82 8d       	ldd	r24, Z+26	; 0x1a
     fb6:	88 23       	and	r24, r24
     fb8:	51 f1       	breq	.+84     	; 0x100e <xQueueGenericReceive+0xa0>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
     fba:	e6 80       	ldd	r14, Z+6	; 0x06
     fbc:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     fbe:	c8 01       	movw	r24, r16
     fc0:	b4 01       	movw	r22, r8
     fc2:	0e 94 cc 05 	call	0xb98	; 0xb98 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
     fc6:	bb 20       	and	r11, r11
     fc8:	81 f4       	brne	.+32     	; 0xfea <xQueueGenericReceive+0x7c>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
     fca:	f8 01       	movw	r30, r16
     fcc:	82 8d       	ldd	r24, Z+26	; 0x1a
     fce:	81 50       	subi	r24, 0x01	; 1
     fd0:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     fd2:	80 85       	ldd	r24, Z+8	; 0x08
     fd4:	88 23       	and	r24, r24
     fd6:	b9 f0       	breq	.+46     	; 0x1006 <xQueueGenericReceive+0x98>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     fd8:	c8 01       	movw	r24, r16
     fda:	08 96       	adiw	r24, 0x08	; 8
     fdc:	0e 94 74 0c 	call	0x18e8	; 0x18e8 <xTaskRemoveFromEventList>
     fe0:	81 30       	cpi	r24, 0x01	; 1
     fe2:	89 f4       	brne	.+34     	; 0x1006 <xQueueGenericReceive+0x98>
						{
							portYIELD_WITHIN_API();
     fe4:	0e 94 dd 04 	call	0x9ba	; 0x9ba <vPortYield>
     fe8:	0e c0       	rjmp	.+28     	; 0x1006 <xQueueGenericReceive+0x98>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
     fea:	f8 01       	movw	r30, r16
     fec:	f7 82       	std	Z+7, r15	; 0x07
     fee:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     ff0:	81 89       	ldd	r24, Z+17	; 0x11
     ff2:	88 23       	and	r24, r24
     ff4:	41 f0       	breq	.+16     	; 0x1006 <xQueueGenericReceive+0x98>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     ff6:	c8 01       	movw	r24, r16
     ff8:	41 96       	adiw	r24, 0x11	; 17
     ffa:	0e 94 74 0c 	call	0x18e8	; 0x18e8 <xTaskRemoveFromEventList>
     ffe:	88 23       	and	r24, r24
    1000:	11 f0       	breq	.+4      	; 0x1006 <xQueueGenericReceive+0x98>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    1002:	0e 94 dd 04 	call	0x9ba	; 0x9ba <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    1006:	0f 90       	pop	r0
    1008:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    100a:	81 e0       	ldi	r24, 0x01	; 1
    100c:	50 c0       	rjmp	.+160    	; 0x10ae <xQueueGenericReceive+0x140>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    100e:	8c 81       	ldd	r24, Y+4	; 0x04
    1010:	9d 81       	ldd	r25, Y+5	; 0x05
    1012:	00 97       	sbiw	r24, 0x00	; 0
    1014:	21 f4       	brne	.+8      	; 0x101e <xQueueGenericReceive+0xb0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1016:	0f 90       	pop	r0
    1018:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    101a:	80 e0       	ldi	r24, 0x00	; 0
    101c:	48 c0       	rjmp	.+144    	; 0x10ae <xQueueGenericReceive+0x140>
				}
				else if( xEntryTimeSet == pdFALSE )
    101e:	ff 20       	and	r15, r15
    1020:	29 f4       	brne	.+10     	; 0x102c <xQueueGenericReceive+0xbe>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1022:	ce 01       	movw	r24, r28
    1024:	01 96       	adiw	r24, 0x01	; 1
    1026:	0e 94 bc 0c 	call	0x1978	; 0x1978 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    102a:	fe 2c       	mov	r15, r14
				}
			}
		}
		taskEXIT_CRITICAL();
    102c:	0f 90       	pop	r0
    102e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1030:	0e 94 22 0a 	call	0x1444	; 0x1444 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1034:	0f b6       	in	r0, 0x3f	; 63
    1036:	f8 94       	cli
    1038:	0f 92       	push	r0
    103a:	f8 01       	movw	r30, r16
    103c:	85 8d       	ldd	r24, Z+29	; 0x1d
    103e:	8f 3f       	cpi	r24, 0xFF	; 255
    1040:	09 f4       	brne	.+2      	; 0x1044 <xQueueGenericReceive+0xd6>
    1042:	15 8e       	std	Z+29, r1	; 0x1d
    1044:	f8 01       	movw	r30, r16
    1046:	86 8d       	ldd	r24, Z+30	; 0x1e
    1048:	8f 3f       	cpi	r24, 0xFF	; 255
    104a:	09 f4       	brne	.+2      	; 0x104e <xQueueGenericReceive+0xe0>
    104c:	16 8e       	std	Z+30, r1	; 0x1e
    104e:	0f 90       	pop	r0
    1050:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1052:	ce 01       	movw	r24, r28
    1054:	01 96       	adiw	r24, 0x01	; 1
    1056:	be 01       	movw	r22, r28
    1058:	6c 5f       	subi	r22, 0xFC	; 252
    105a:	7f 4f       	sbci	r23, 0xFF	; 255
    105c:	0e 94 c7 0c 	call	0x198e	; 0x198e <xTaskCheckForTimeOut>
    1060:	88 23       	and	r24, r24
    1062:	f9 f4       	brne	.+62     	; 0x10a2 <xQueueGenericReceive+0x134>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1064:	0f b6       	in	r0, 0x3f	; 63
    1066:	f8 94       	cli
    1068:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    106a:	f8 01       	movw	r30, r16
    106c:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    106e:	0f 90       	pop	r0
    1070:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1072:	88 23       	and	r24, r24
    1074:	81 f4       	brne	.+32     	; 0x1096 <xQueueGenericReceive+0x128>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1076:	6c 81       	ldd	r22, Y+4	; 0x04
    1078:	7d 81       	ldd	r23, Y+5	; 0x05
    107a:	c6 01       	movw	r24, r12
    107c:	0e 94 57 0c 	call	0x18ae	; 0x18ae <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1080:	c8 01       	movw	r24, r16
    1082:	0e 94 3c 06 	call	0xc78	; 0xc78 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1086:	0e 94 00 0b 	call	0x1600	; 0x1600 <xTaskResumeAll>
    108a:	88 23       	and	r24, r24
    108c:	09 f0       	breq	.+2      	; 0x1090 <xQueueGenericReceive+0x122>
    108e:	8e cf       	rjmp	.-228    	; 0xfac <xQueueGenericReceive+0x3e>
				{
					portYIELD_WITHIN_API();
    1090:	0e 94 dd 04 	call	0x9ba	; 0x9ba <vPortYield>
    1094:	8b cf       	rjmp	.-234    	; 0xfac <xQueueGenericReceive+0x3e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1096:	c8 01       	movw	r24, r16
    1098:	0e 94 3c 06 	call	0xc78	; 0xc78 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    109c:	0e 94 00 0b 	call	0x1600	; 0x1600 <xTaskResumeAll>
    10a0:	85 cf       	rjmp	.-246    	; 0xfac <xQueueGenericReceive+0x3e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    10a2:	c8 01       	movw	r24, r16
    10a4:	0e 94 3c 06 	call	0xc78	; 0xc78 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    10a8:	0e 94 00 0b 	call	0x1600	; 0x1600 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    10ac:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    10ae:	0f 90       	pop	r0
    10b0:	0f 90       	pop	r0
    10b2:	0f 90       	pop	r0
    10b4:	0f 90       	pop	r0
    10b6:	0f 90       	pop	r0
    10b8:	df 91       	pop	r29
    10ba:	cf 91       	pop	r28
    10bc:	1f 91       	pop	r17
    10be:	0f 91       	pop	r16
    10c0:	ff 90       	pop	r15
    10c2:	ef 90       	pop	r14
    10c4:	df 90       	pop	r13
    10c6:	cf 90       	pop	r12
    10c8:	bf 90       	pop	r11
    10ca:	9f 90       	pop	r9
    10cc:	8f 90       	pop	r8
    10ce:	08 95       	ret

000010d0 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    10d0:	0f 93       	push	r16
    10d2:	1f 93       	push	r17
    10d4:	cf 93       	push	r28
    10d6:	df 93       	push	r29
    10d8:	ec 01       	movw	r28, r24
    10da:	8a 01       	movw	r16, r20
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    10dc:	8a 8d       	ldd	r24, Y+26	; 0x1a
    10de:	88 23       	and	r24, r24
    10e0:	d1 f0       	breq	.+52     	; 0x1116 <xQueueReceiveFromISR+0x46>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    10e2:	ce 01       	movw	r24, r28
    10e4:	0e 94 cc 05 	call	0xb98	; 0xb98 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    10e8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    10ea:	81 50       	subi	r24, 0x01	; 1
    10ec:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    10ee:	8d 8d       	ldd	r24, Y+29	; 0x1d
    10f0:	8f 3f       	cpi	r24, 0xFF	; 255
    10f2:	69 f4       	brne	.+26     	; 0x110e <xQueueReceiveFromISR+0x3e>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    10f4:	88 85       	ldd	r24, Y+8	; 0x08
    10f6:	88 23       	and	r24, r24
    10f8:	81 f0       	breq	.+32     	; 0x111a <xQueueReceiveFromISR+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    10fa:	ce 01       	movw	r24, r28
    10fc:	08 96       	adiw	r24, 0x08	; 8
    10fe:	0e 94 74 0c 	call	0x18e8	; 0x18e8 <xTaskRemoveFromEventList>
    1102:	88 23       	and	r24, r24
    1104:	61 f0       	breq	.+24     	; 0x111e <xQueueReceiveFromISR+0x4e>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    1106:	81 e0       	ldi	r24, 0x01	; 1
    1108:	f8 01       	movw	r30, r16
    110a:	80 83       	st	Z, r24
    110c:	09 c0       	rjmp	.+18     	; 0x1120 <xQueueReceiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    110e:	8f 5f       	subi	r24, 0xFF	; 255
    1110:	8d 8f       	std	Y+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    1112:	81 e0       	ldi	r24, 0x01	; 1
    1114:	05 c0       	rjmp	.+10     	; 0x1120 <xQueueReceiveFromISR+0x50>
		}
		else
		{
			xReturn = pdFAIL;
    1116:	80 e0       	ldi	r24, 0x00	; 0
    1118:	03 c0       	rjmp	.+6      	; 0x1120 <xQueueReceiveFromISR+0x50>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    111a:	81 e0       	ldi	r24, 0x01	; 1
    111c:	01 c0       	rjmp	.+2      	; 0x1120 <xQueueReceiveFromISR+0x50>
    111e:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1120:	df 91       	pop	r29
    1122:	cf 91       	pop	r28
    1124:	1f 91       	pop	r17
    1126:	0f 91       	pop	r16
    1128:	08 95       	ret

0000112a <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    112a:	0f b6       	in	r0, 0x3f	; 63
    112c:	f8 94       	cli
    112e:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1130:	fc 01       	movw	r30, r24
    1132:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    1134:	0f 90       	pop	r0
    1136:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    1138:	08 95       	ret

0000113a <uxQueueMessagesWaitingFromISR>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    113a:	fc 01       	movw	r30, r24
    113c:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
}
    113e:	08 95       	ret

00001140 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    1140:	cf 93       	push	r28
    1142:	df 93       	push	r29
    1144:	ec 01       	movw	r28, r24
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    1146:	88 81       	ld	r24, Y
    1148:	99 81       	ldd	r25, Y+1	; 0x01
    114a:	0e 94 bd 05 	call	0xb7a	; 0xb7a <vPortFree>
	vPortFree( pxQueue );
    114e:	ce 01       	movw	r24, r28
    1150:	0e 94 bd 05 	call	0xb7a	; 0xb7a <vPortFree>
}
    1154:	df 91       	pop	r29
    1156:	cf 91       	pop	r28
    1158:	08 95       	ret

0000115a <xQueueIsQueueEmptyFromISR>:
signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    115a:	fc 01       	movw	r30, r24
    115c:	92 8d       	ldd	r25, Z+26	; 0x1a
    115e:	81 e0       	ldi	r24, 0x01	; 1
    1160:	91 11       	cpse	r25, r1
    1162:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    1164:	08 95       	ret

00001166 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    1166:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    1168:	22 8d       	ldd	r18, Z+26	; 0x1a
    116a:	81 e0       	ldi	r24, 0x01	; 1
    116c:	93 8d       	ldd	r25, Z+27	; 0x1b
    116e:	29 13       	cpse	r18, r25
    1170:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    1172:	08 95       	ret

00001174 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    1174:	cf 93       	push	r28
    1176:	df 93       	push	r29
    1178:	ec 01       	movw	r28, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    117a:	e0 91 8a 06 	lds	r30, 0x068A
    117e:	f0 91 8b 06 	lds	r31, 0x068B
    1182:	93 83       	std	Z+3, r25	; 0x03
    1184:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    1186:	80 91 92 06 	lds	r24, 0x0692
    118a:	90 91 93 06 	lds	r25, 0x0693
    118e:	c8 17       	cp	r28, r24
    1190:	d9 07       	cpc	r29, r25
    1192:	68 f4       	brcc	.+26     	; 0x11ae <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1194:	80 91 95 06 	lds	r24, 0x0695
    1198:	90 91 96 06 	lds	r25, 0x0696
    119c:	60 91 8a 06 	lds	r22, 0x068A
    11a0:	70 91 8b 06 	lds	r23, 0x068B
    11a4:	6e 5f       	subi	r22, 0xFE	; 254
    11a6:	7f 4f       	sbci	r23, 0xFF	; 255
    11a8:	0e 94 b4 03 	call	0x768	; 0x768 <vListInsert>
    11ac:	17 c0       	rjmp	.+46     	; 0x11dc <prvAddCurrentTaskToDelayedList+0x68>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    11ae:	80 91 97 06 	lds	r24, 0x0697
    11b2:	90 91 98 06 	lds	r25, 0x0698
    11b6:	60 91 8a 06 	lds	r22, 0x068A
    11ba:	70 91 8b 06 	lds	r23, 0x068B
    11be:	6e 5f       	subi	r22, 0xFE	; 254
    11c0:	7f 4f       	sbci	r23, 0xFF	; 255
    11c2:	0e 94 b4 03 	call	0x768	; 0x768 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    11c6:	80 91 6f 00 	lds	r24, 0x006F
    11ca:	90 91 70 00 	lds	r25, 0x0070
    11ce:	c8 17       	cp	r28, r24
    11d0:	d9 07       	cpc	r29, r25
    11d2:	20 f4       	brcc	.+8      	; 0x11dc <prvAddCurrentTaskToDelayedList+0x68>
		{
			xNextTaskUnblockTime = xTimeToWake;
    11d4:	d0 93 70 00 	sts	0x0070, r29
    11d8:	c0 93 6f 00 	sts	0x006F, r28
		}
	}
}
    11dc:	df 91       	pop	r29
    11de:	cf 91       	pop	r28
    11e0:	08 95       	ret

000011e2 <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    11e2:	cb e9       	ldi	r28, 0x9B	; 155
    11e4:	d6 e0       	ldi	r29, 0x06	; 6
    11e6:	88 81       	ld	r24, Y
    11e8:	82 30       	cpi	r24, 0x02	; 2
    11ea:	e8 f3       	brcs	.-6      	; 0x11e6 <prvIdleTask+0x4>
			{
				taskYIELD();
    11ec:	0e 94 dd 04 	call	0x9ba	; 0x9ba <vPortYield>
    11f0:	fa cf       	rjmp	.-12     	; 0x11e6 <prvIdleTask+0x4>

000011f2 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    11f2:	4f 92       	push	r4
    11f4:	5f 92       	push	r5
    11f6:	6f 92       	push	r6
    11f8:	7f 92       	push	r7
    11fa:	8f 92       	push	r8
    11fc:	9f 92       	push	r9
    11fe:	af 92       	push	r10
    1200:	bf 92       	push	r11
    1202:	cf 92       	push	r12
    1204:	df 92       	push	r13
    1206:	ef 92       	push	r14
    1208:	ff 92       	push	r15
    120a:	0f 93       	push	r16
    120c:	cf 93       	push	r28
    120e:	df 93       	push	r29
    1210:	2c 01       	movw	r4, r24
    1212:	4b 01       	movw	r8, r22
    1214:	5a 01       	movw	r10, r20
    1216:	39 01       	movw	r6, r18
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    1218:	81 e2       	ldi	r24, 0x21	; 33
    121a:	90 e0       	ldi	r25, 0x00	; 0
    121c:	0e 94 94 05 	call	0xb28	; 0xb28 <pvPortMalloc>
    1220:	ec 01       	movw	r28, r24

	if( pxNewTCB != NULL )
    1222:	00 97       	sbiw	r24, 0x00	; 0
    1224:	09 f4       	brne	.+2      	; 0x1228 <xTaskGenericCreate+0x36>
    1226:	a2 c0       	rjmp	.+324    	; 0x136c <xTaskGenericCreate+0x17a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    1228:	c1 14       	cp	r12, r1
    122a:	d1 04       	cpc	r13, r1
    122c:	09 f0       	breq	.+2      	; 0x1230 <xTaskGenericCreate+0x3e>
    122e:	b3 c0       	rjmp	.+358    	; 0x1396 <xTaskGenericCreate+0x1a4>
    1230:	c5 01       	movw	r24, r10
    1232:	0e 94 94 05 	call	0xb28	; 0xb28 <pvPortMalloc>
    1236:	6c 01       	movw	r12, r24
    1238:	98 8f       	std	Y+24, r25	; 0x18
    123a:	8f 8b       	std	Y+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    123c:	00 97       	sbiw	r24, 0x00	; 0
    123e:	29 f4       	brne	.+10     	; 0x124a <xTaskGenericCreate+0x58>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    1240:	ce 01       	movw	r24, r28
    1242:	0e 94 bd 05 	call	0xb7a	; 0xb7a <vPortFree>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1246:	8f ef       	ldi	r24, 0xFF	; 255
    1248:	96 c0       	rjmp	.+300    	; 0x1376 <xTaskGenericCreate+0x184>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    124a:	c6 01       	movw	r24, r12
    124c:	65 ea       	ldi	r22, 0xA5	; 165
    124e:	70 e0       	ldi	r23, 0x00	; 0
    1250:	a5 01       	movw	r20, r10
    1252:	0e 94 2c 0d 	call	0x1a58	; 0x1a58 <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    1256:	95 01       	movw	r18, r10
    1258:	21 50       	subi	r18, 0x01	; 1
    125a:	30 40       	sbci	r19, 0x00	; 0
    125c:	8f 89       	ldd	r24, Y+23	; 0x17
    125e:	98 8d       	ldd	r25, Y+24	; 0x18
    1260:	6c 01       	movw	r12, r24
    1262:	c2 0e       	add	r12, r18
    1264:	d3 1e       	adc	r13, r19
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    1266:	ce 01       	movw	r24, r28
    1268:	49 96       	adiw	r24, 0x19	; 25
    126a:	b4 01       	movw	r22, r8
    126c:	48 e0       	ldi	r20, 0x08	; 8
    126e:	50 e0       	ldi	r21, 0x00	; 0
    1270:	0e 94 33 0d 	call	0x1a66	; 0x1a66 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    1274:	18 a2       	lds	r17, 0x98
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
    1276:	1e 8a       	std	Y+22, r1	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    1278:	aa 24       	eor	r10, r10
    127a:	bb 24       	eor	r11, r11
    127c:	68 94       	set
    127e:	a1 f8       	bld	r10, 1
    1280:	ac 0e       	add	r10, r28
    1282:	bd 1e       	adc	r11, r29
    1284:	c5 01       	movw	r24, r10
    1286:	0e 94 87 03 	call	0x70e	; 0x70e <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    128a:	ce 01       	movw	r24, r28
    128c:	0c 96       	adiw	r24, 0x0c	; 12
    128e:	0e 94 87 03 	call	0x70e	; 0x70e <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    1292:	d9 87       	std	Y+9, r29	; 0x09
    1294:	c8 87       	std	Y+8, r28	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    1296:	81 e0       	ldi	r24, 0x01	; 1
    1298:	90 e0       	ldi	r25, 0x00	; 0
    129a:	9d 87       	std	Y+13, r25	; 0x0d
    129c:	8c 87       	std	Y+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    129e:	db 8b       	std	Y+19, r29	; 0x13
    12a0:	ca 8b       	std	Y+18, r28	; 0x12
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    12a2:	c6 01       	movw	r24, r12
    12a4:	b2 01       	movw	r22, r4
    12a6:	a3 01       	movw	r20, r6
    12a8:	0e 94 17 04 	call	0x82e	; 0x82e <pxPortInitialiseStack>
    12ac:	99 83       	std	Y+1, r25	; 0x01
    12ae:	88 83       	st	Y, r24
		#endif

		/* Check the alignment of the initialised stack. */
		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    12b0:	e1 14       	cp	r14, r1
    12b2:	f1 04       	cpc	r15, r1
    12b4:	19 f0       	breq	.+6      	; 0x12bc <xTaskGenericCreate+0xca>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    12b6:	f7 01       	movw	r30, r14
    12b8:	d1 83       	std	Z+1, r29	; 0x01
    12ba:	c0 83       	st	Z, r28
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    12bc:	0f b6       	in	r0, 0x3f	; 63
    12be:	f8 94       	cli
    12c0:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    12c2:	80 91 94 06 	lds	r24, 0x0694
    12c6:	8f 5f       	subi	r24, 0xFF	; 255
    12c8:	80 93 94 06 	sts	0x0694, r24
			if( pxCurrentTCB == NULL )
    12cc:	80 91 8a 06 	lds	r24, 0x068A
    12d0:	90 91 8b 06 	lds	r25, 0x068B
    12d4:	00 97       	sbiw	r24, 0x00	; 0
    12d6:	49 f4       	brne	.+18     	; 0x12ea <xTaskGenericCreate+0xf8>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    12d8:	d0 93 8b 06 	sts	0x068B, r29
    12dc:	c0 93 8a 06 	sts	0x068A, r28

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    12e0:	80 91 94 06 	lds	r24, 0x0694
    12e4:	81 30       	cpi	r24, 0x01	; 1
    12e6:	81 f4       	brne	.+32     	; 0x1308 <xTaskGenericCreate+0x116>
    12e8:	59 c0       	rjmp	.+178    	; 0x139c <xTaskGenericCreate+0x1aa>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    12ea:	80 91 90 06 	lds	r24, 0x0690
    12ee:	88 23       	and	r24, r24
    12f0:	59 f4       	brne	.+22     	; 0x1308 <xTaskGenericCreate+0x116>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    12f2:	e0 91 8a 06 	lds	r30, 0x068A
    12f6:	f0 91 8b 06 	lds	r31, 0x068B
    12fa:	86 89       	ldd	r24, Z+22	; 0x16
    12fc:	08 17       	cp	r16, r24
    12fe:	20 f0       	brcs	.+8      	; 0x1308 <xTaskGenericCreate+0x116>
					{
						pxCurrentTCB = pxNewTCB;
    1300:	d0 93 8b 06 	sts	0x068B, r29
    1304:	c0 93 8a 06 	sts	0x068A, r28
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    1308:	8e 89       	ldd	r24, Y+22	; 0x16
    130a:	90 91 99 06 	lds	r25, 0x0699
    130e:	98 17       	cp	r25, r24
    1310:	10 f4       	brcc	.+4      	; 0x1316 <xTaskGenericCreate+0x124>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    1312:	80 93 99 06 	sts	0x0699, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTCBNumber;
			}
			#endif
			uxTCBNumber++;
    1316:	90 91 9a 06 	lds	r25, 0x069A
    131a:	9f 5f       	subi	r25, 0xFF	; 255
    131c:	90 93 9a 06 	sts	0x069A, r25

			prvAddTaskToReadyQueue( pxNewTCB );
    1320:	90 91 91 06 	lds	r25, 0x0691
    1324:	98 17       	cp	r25, r24
    1326:	10 f4       	brcc	.+4      	; 0x132c <xTaskGenericCreate+0x13a>
    1328:	80 93 91 06 	sts	0x0691, r24
    132c:	90 e0       	ldi	r25, 0x00	; 0
    132e:	9c 01       	movw	r18, r24
    1330:	22 0f       	add	r18, r18
    1332:	33 1f       	adc	r19, r19
    1334:	22 0f       	add	r18, r18
    1336:	33 1f       	adc	r19, r19
    1338:	22 0f       	add	r18, r18
    133a:	33 1f       	adc	r19, r19
    133c:	82 0f       	add	r24, r18
    133e:	93 1f       	adc	r25, r19
    1340:	85 56       	subi	r24, 0x65	; 101
    1342:	99 4f       	sbci	r25, 0xF9	; 249
    1344:	b5 01       	movw	r22, r10
    1346:	0e 94 8b 03 	call	0x716	; 0x716 <vListInsertEnd>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    134a:	0f 90       	pop	r0
    134c:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    134e:	80 91 90 06 	lds	r24, 0x0690
    1352:	88 23       	and	r24, r24
    1354:	69 f0       	breq	.+26     	; 0x1370 <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    1356:	e0 91 8a 06 	lds	r30, 0x068A
    135a:	f0 91 8b 06 	lds	r31, 0x068B
    135e:	86 89       	ldd	r24, Z+22	; 0x16
    1360:	80 17       	cp	r24, r16
    1362:	40 f4       	brcc	.+16     	; 0x1374 <xTaskGenericCreate+0x182>
			{
				portYIELD_WITHIN_API();
    1364:	0e 94 dd 04 	call	0x9ba	; 0x9ba <vPortYield>
			#endif
			uxTCBNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    1368:	81 e0       	ldi	r24, 0x01	; 1
    136a:	05 c0       	rjmp	.+10     	; 0x1376 <xTaskGenericCreate+0x184>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    136c:	8f ef       	ldi	r24, 0xFF	; 255
    136e:	03 c0       	rjmp	.+6      	; 0x1376 <xTaskGenericCreate+0x184>
			#endif
			uxTCBNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    1370:	81 e0       	ldi	r24, 0x01	; 1
    1372:	01 c0       	rjmp	.+2      	; 0x1376 <xTaskGenericCreate+0x184>
    1374:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	return xReturn;
}
    1376:	df 91       	pop	r29
    1378:	cf 91       	pop	r28
    137a:	0f 91       	pop	r16
    137c:	ff 90       	pop	r15
    137e:	ef 90       	pop	r14
    1380:	df 90       	pop	r13
    1382:	cf 90       	pop	r12
    1384:	bf 90       	pop	r11
    1386:	af 90       	pop	r10
    1388:	9f 90       	pop	r9
    138a:	8f 90       	pop	r8
    138c:	7f 90       	pop	r7
    138e:	6f 90       	pop	r6
    1390:	5f 90       	pop	r5
    1392:	4f 90       	pop	r4
    1394:	08 95       	ret
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    1396:	d8 8e       	std	Y+24, r13	; 0x18
    1398:	cf 8a       	std	Y+23, r12	; 0x17
    139a:	57 cf       	rjmp	.-338    	; 0x124a <xTaskGenericCreate+0x58>
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    139c:	8b e9       	ldi	r24, 0x9B	; 155
    139e:	96 e0       	ldi	r25, 0x06	; 6
    13a0:	0e 94 79 03 	call	0x6f2	; 0x6f2 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    13a4:	0f 2e       	mov	r0, r31
    13a6:	f4 ea       	ldi	r31, 0xA4	; 164
    13a8:	ef 2e       	mov	r14, r31
    13aa:	f6 e0       	ldi	r31, 0x06	; 6
    13ac:	ff 2e       	mov	r15, r31
    13ae:	f0 2d       	mov	r31, r0
    13b0:	c7 01       	movw	r24, r14
    13b2:	0e 94 79 03 	call	0x6f2	; 0x6f2 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    13b6:	0f 2e       	mov	r0, r31
    13b8:	fd ea       	ldi	r31, 0xAD	; 173
    13ba:	cf 2e       	mov	r12, r31
    13bc:	f6 e0       	ldi	r31, 0x06	; 6
    13be:	df 2e       	mov	r13, r31
    13c0:	f0 2d       	mov	r31, r0
    13c2:	c6 01       	movw	r24, r12
    13c4:	0e 94 79 03 	call	0x6f2	; 0x6f2 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    13c8:	86 eb       	ldi	r24, 0xB6	; 182
    13ca:	96 e0       	ldi	r25, 0x06	; 6
    13cc:	0e 94 79 03 	call	0x6f2	; 0x6f2 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    13d0:	f0 92 98 06 	sts	0x0698, r15
    13d4:	e0 92 97 06 	sts	0x0697, r14
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    13d8:	d0 92 96 06 	sts	0x0696, r13
    13dc:	c0 92 95 06 	sts	0x0695, r12
    13e0:	93 cf       	rjmp	.-218    	; 0x1308 <xTaskGenericCreate+0x116>

000013e2 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    13e2:	af 92       	push	r10
    13e4:	bf 92       	push	r11
    13e6:	cf 92       	push	r12
    13e8:	df 92       	push	r13
    13ea:	ef 92       	push	r14
    13ec:	ff 92       	push	r15
    13ee:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    13f0:	81 ef       	ldi	r24, 0xF1	; 241
    13f2:	98 e0       	ldi	r25, 0x08	; 8
    13f4:	6a e6       	ldi	r22, 0x6A	; 106
    13f6:	70 e0       	ldi	r23, 0x00	; 0
    13f8:	45 e5       	ldi	r20, 0x55	; 85
    13fa:	50 e0       	ldi	r21, 0x00	; 0
    13fc:	20 e0       	ldi	r18, 0x00	; 0
    13fe:	30 e0       	ldi	r19, 0x00	; 0
    1400:	00 e0       	ldi	r16, 0x00	; 0
    1402:	ee 24       	eor	r14, r14
    1404:	ff 24       	eor	r15, r15
    1406:	cc 24       	eor	r12, r12
    1408:	dd 24       	eor	r13, r13
    140a:	aa 24       	eor	r10, r10
    140c:	bb 24       	eor	r11, r11
    140e:	0e 94 f9 08 	call	0x11f2	; 0x11f2 <xTaskGenericCreate>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    1412:	81 30       	cpi	r24, 0x01	; 1
    1414:	49 f4       	brne	.+18     	; 0x1428 <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    1416:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    1418:	80 93 90 06 	sts	0x0690, r24
		xTickCount = ( portTickType ) 0U;
    141c:	10 92 93 06 	sts	0x0693, r1
    1420:	10 92 92 06 	sts	0x0692, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    1424:	0e 94 a7 04 	call	0x94e	; 0x94e <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    1428:	0f 91       	pop	r16
    142a:	ff 90       	pop	r15
    142c:	ef 90       	pop	r14
    142e:	df 90       	pop	r13
    1430:	cf 90       	pop	r12
    1432:	bf 90       	pop	r11
    1434:	af 90       	pop	r10
    1436:	08 95       	ret

00001438 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    1438:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    143a:	10 92 90 06 	sts	0x0690, r1
	vPortEndScheduler();
    143e:	0e 94 dc 04 	call	0x9b8	; 0x9b8 <vPortEndScheduler>
}
    1442:	08 95       	ret

00001444 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    1444:	80 91 8f 06 	lds	r24, 0x068F
    1448:	8f 5f       	subi	r24, 0xFF	; 255
    144a:	80 93 8f 06 	sts	0x068F, r24
}
    144e:	08 95       	ret

00001450 <xTaskGetTickCount>:
portTickType xTaskGetTickCount( void )
{
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    1450:	0f b6       	in	r0, 0x3f	; 63
    1452:	f8 94       	cli
    1454:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    1456:	80 91 92 06 	lds	r24, 0x0692
    145a:	90 91 93 06 	lds	r25, 0x0693
	}
	taskEXIT_CRITICAL();
    145e:	0f 90       	pop	r0
    1460:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    1462:	08 95       	ret

00001464 <xTaskGetTickCountFromISR>:
{
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	xReturn = xTickCount;
    1464:	80 91 92 06 	lds	r24, 0x0692
    1468:	90 91 93 06 	lds	r25, 0x0693
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    146c:	08 95       	ret

0000146e <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    146e:	80 91 94 06 	lds	r24, 0x0694
}
    1472:	08 95       	ret

00001474 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    1474:	0f 93       	push	r16
    1476:	1f 93       	push	r17
    1478:	cf 93       	push	r28
    147a:	df 93       	push	r29
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    147c:	80 91 8f 06 	lds	r24, 0x068F
    1480:	88 23       	and	r24, r24
    1482:	09 f0       	breq	.+2      	; 0x1486 <vTaskIncrementTick+0x12>
    1484:	b3 c0       	rjmp	.+358    	; 0x15ec <vTaskIncrementTick+0x178>
	{
		++xTickCount;
    1486:	80 91 92 06 	lds	r24, 0x0692
    148a:	90 91 93 06 	lds	r25, 0x0693
    148e:	01 96       	adiw	r24, 0x01	; 1
    1490:	90 93 93 06 	sts	0x0693, r25
    1494:	80 93 92 06 	sts	0x0692, r24
		if( xTickCount == ( portTickType ) 0U )
    1498:	80 91 92 06 	lds	r24, 0x0692
    149c:	90 91 93 06 	lds	r25, 0x0693
    14a0:	00 97       	sbiw	r24, 0x00	; 0
    14a2:	99 f5       	brne	.+102    	; 0x150a <vTaskIncrementTick+0x96>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    14a4:	80 91 97 06 	lds	r24, 0x0697
    14a8:	90 91 98 06 	lds	r25, 0x0698
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    14ac:	20 91 95 06 	lds	r18, 0x0695
    14b0:	30 91 96 06 	lds	r19, 0x0696
    14b4:	30 93 98 06 	sts	0x0698, r19
    14b8:	20 93 97 06 	sts	0x0697, r18
			pxOverflowDelayedTaskList = pxTemp;
    14bc:	90 93 96 06 	sts	0x0696, r25
    14c0:	80 93 95 06 	sts	0x0695, r24
			xNumOfOverflows++;
    14c4:	80 91 8c 06 	lds	r24, 0x068C
    14c8:	8f 5f       	subi	r24, 0xFF	; 255
    14ca:	80 93 8c 06 	sts	0x068C, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    14ce:	e0 91 97 06 	lds	r30, 0x0697
    14d2:	f0 91 98 06 	lds	r31, 0x0698
    14d6:	80 81       	ld	r24, Z
    14d8:	88 23       	and	r24, r24
    14da:	39 f4       	brne	.+14     	; 0x14ea <vTaskIncrementTick+0x76>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    14dc:	8f ef       	ldi	r24, 0xFF	; 255
    14de:	9f ef       	ldi	r25, 0xFF	; 255
    14e0:	90 93 70 00 	sts	0x0070, r25
    14e4:	80 93 6f 00 	sts	0x006F, r24
    14e8:	10 c0       	rjmp	.+32     	; 0x150a <vTaskIncrementTick+0x96>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    14ea:	e0 91 97 06 	lds	r30, 0x0697
    14ee:	f0 91 98 06 	lds	r31, 0x0698
    14f2:	05 80       	ldd	r0, Z+5	; 0x05
    14f4:	f6 81       	ldd	r31, Z+6	; 0x06
    14f6:	e0 2d       	mov	r30, r0
    14f8:	06 80       	ldd	r0, Z+6	; 0x06
    14fa:	f7 81       	ldd	r31, Z+7	; 0x07
    14fc:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    14fe:	82 81       	ldd	r24, Z+2	; 0x02
    1500:	93 81       	ldd	r25, Z+3	; 0x03
    1502:	90 93 70 00 	sts	0x0070, r25
    1506:	80 93 6f 00 	sts	0x006F, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    150a:	20 91 92 06 	lds	r18, 0x0692
    150e:	30 91 93 06 	lds	r19, 0x0693
    1512:	80 91 6f 00 	lds	r24, 0x006F
    1516:	90 91 70 00 	lds	r25, 0x0070
    151a:	28 17       	cp	r18, r24
    151c:	39 07       	cpc	r19, r25
    151e:	08 f4       	brcc	.+2      	; 0x1522 <vTaskIncrementTick+0xae>
    1520:	6a c0       	rjmp	.+212    	; 0x15f6 <vTaskIncrementTick+0x182>
    1522:	e0 91 97 06 	lds	r30, 0x0697
    1526:	f0 91 98 06 	lds	r31, 0x0698
    152a:	80 81       	ld	r24, Z
    152c:	88 23       	and	r24, r24
    152e:	99 f0       	breq	.+38     	; 0x1556 <vTaskIncrementTick+0xe2>
    1530:	e0 91 97 06 	lds	r30, 0x0697
    1534:	f0 91 98 06 	lds	r31, 0x0698
    1538:	05 80       	ldd	r0, Z+5	; 0x05
    153a:	f6 81       	ldd	r31, Z+6	; 0x06
    153c:	e0 2d       	mov	r30, r0
    153e:	c6 81       	ldd	r28, Z+6	; 0x06
    1540:	d7 81       	ldd	r29, Z+7	; 0x07
    1542:	8a 81       	ldd	r24, Y+2	; 0x02
    1544:	9b 81       	ldd	r25, Y+3	; 0x03
    1546:	20 91 92 06 	lds	r18, 0x0692
    154a:	30 91 93 06 	lds	r19, 0x0693
    154e:	28 17       	cp	r18, r24
    1550:	39 07       	cpc	r19, r25
    1552:	f8 f4       	brcc	.+62     	; 0x1592 <vTaskIncrementTick+0x11e>
    1554:	19 c0       	rjmp	.+50     	; 0x1588 <vTaskIncrementTick+0x114>
    1556:	8f ef       	ldi	r24, 0xFF	; 255
    1558:	9f ef       	ldi	r25, 0xFF	; 255
    155a:	90 93 70 00 	sts	0x0070, r25
    155e:	80 93 6f 00 	sts	0x006F, r24
    1562:	49 c0       	rjmp	.+146    	; 0x15f6 <vTaskIncrementTick+0x182>
    1564:	e0 91 97 06 	lds	r30, 0x0697
    1568:	f0 91 98 06 	lds	r31, 0x0698
    156c:	05 80       	ldd	r0, Z+5	; 0x05
    156e:	f6 81       	ldd	r31, Z+6	; 0x06
    1570:	e0 2d       	mov	r30, r0
    1572:	c6 81       	ldd	r28, Z+6	; 0x06
    1574:	d7 81       	ldd	r29, Z+7	; 0x07
    1576:	8a 81       	ldd	r24, Y+2	; 0x02
    1578:	9b 81       	ldd	r25, Y+3	; 0x03
    157a:	20 91 92 06 	lds	r18, 0x0692
    157e:	30 91 93 06 	lds	r19, 0x0693
    1582:	28 17       	cp	r18, r24
    1584:	39 07       	cpc	r19, r25
    1586:	28 f4       	brcc	.+10     	; 0x1592 <vTaskIncrementTick+0x11e>
    1588:	90 93 70 00 	sts	0x0070, r25
    158c:	80 93 6f 00 	sts	0x006F, r24
    1590:	32 c0       	rjmp	.+100    	; 0x15f6 <vTaskIncrementTick+0x182>
    1592:	8e 01       	movw	r16, r28
    1594:	0e 5f       	subi	r16, 0xFE	; 254
    1596:	1f 4f       	sbci	r17, 0xFF	; 255
    1598:	c8 01       	movw	r24, r16
    159a:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <vListRemove>
    159e:	8c 89       	ldd	r24, Y+20	; 0x14
    15a0:	9d 89       	ldd	r25, Y+21	; 0x15
    15a2:	00 97       	sbiw	r24, 0x00	; 0
    15a4:	21 f0       	breq	.+8      	; 0x15ae <vTaskIncrementTick+0x13a>
    15a6:	ce 01       	movw	r24, r28
    15a8:	0c 96       	adiw	r24, 0x0c	; 12
    15aa:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <vListRemove>
    15ae:	8e 89       	ldd	r24, Y+22	; 0x16
    15b0:	90 91 91 06 	lds	r25, 0x0691
    15b4:	98 17       	cp	r25, r24
    15b6:	10 f4       	brcc	.+4      	; 0x15bc <vTaskIncrementTick+0x148>
    15b8:	80 93 91 06 	sts	0x0691, r24
    15bc:	90 e0       	ldi	r25, 0x00	; 0
    15be:	9c 01       	movw	r18, r24
    15c0:	22 0f       	add	r18, r18
    15c2:	33 1f       	adc	r19, r19
    15c4:	22 0f       	add	r18, r18
    15c6:	33 1f       	adc	r19, r19
    15c8:	22 0f       	add	r18, r18
    15ca:	33 1f       	adc	r19, r19
    15cc:	82 0f       	add	r24, r18
    15ce:	93 1f       	adc	r25, r19
    15d0:	85 56       	subi	r24, 0x65	; 101
    15d2:	99 4f       	sbci	r25, 0xF9	; 249
    15d4:	b8 01       	movw	r22, r16
    15d6:	0e 94 8b 03 	call	0x716	; 0x716 <vListInsertEnd>
    15da:	e0 91 97 06 	lds	r30, 0x0697
    15de:	f0 91 98 06 	lds	r31, 0x0698
    15e2:	80 81       	ld	r24, Z
    15e4:	88 23       	and	r24, r24
    15e6:	09 f0       	breq	.+2      	; 0x15ea <vTaskIncrementTick+0x176>
    15e8:	bd cf       	rjmp	.-134    	; 0x1564 <vTaskIncrementTick+0xf0>
    15ea:	b5 cf       	rjmp	.-150    	; 0x1556 <vTaskIncrementTick+0xe2>
	}
	else
	{
		++uxMissedTicks;
    15ec:	80 91 8e 06 	lds	r24, 0x068E
    15f0:	8f 5f       	subi	r24, 0xFF	; 255
    15f2:	80 93 8e 06 	sts	0x068E, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    15f6:	df 91       	pop	r29
    15f8:	cf 91       	pop	r28
    15fa:	1f 91       	pop	r17
    15fc:	0f 91       	pop	r16
    15fe:	08 95       	ret

00001600 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    1600:	af 92       	push	r10
    1602:	bf 92       	push	r11
    1604:	cf 92       	push	r12
    1606:	df 92       	push	r13
    1608:	ef 92       	push	r14
    160a:	ff 92       	push	r15
    160c:	0f 93       	push	r16
    160e:	1f 93       	push	r17
    1610:	cf 93       	push	r28
    1612:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    1614:	0f b6       	in	r0, 0x3f	; 63
    1616:	f8 94       	cli
    1618:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    161a:	80 91 8f 06 	lds	r24, 0x068F
    161e:	81 50       	subi	r24, 0x01	; 1
    1620:	80 93 8f 06 	sts	0x068F, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1624:	80 91 8f 06 	lds	r24, 0x068F
    1628:	88 23       	and	r24, r24
    162a:	09 f0       	breq	.+2      	; 0x162e <xTaskResumeAll+0x2e>
    162c:	69 c0       	rjmp	.+210    	; 0x1700 <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    162e:	80 91 94 06 	lds	r24, 0x0694
    1632:	88 23       	and	r24, r24
    1634:	81 f5       	brne	.+96     	; 0x1696 <xTaskResumeAll+0x96>
    1636:	67 c0       	rjmp	.+206    	; 0x1706 <xTaskResumeAll+0x106>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    1638:	d6 01       	movw	r26, r12
    163a:	ed 91       	ld	r30, X+
    163c:	fc 91       	ld	r31, X
    163e:	c6 81       	ldd	r28, Z+6	; 0x06
    1640:	d7 81       	ldd	r29, Z+7	; 0x07
					vListRemove( &( pxTCB->xEventListItem ) );
    1642:	ce 01       	movw	r24, r28
    1644:	0c 96       	adiw	r24, 0x0c	; 12
    1646:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    164a:	8e 01       	movw	r16, r28
    164c:	0e 5f       	subi	r16, 0xFE	; 254
    164e:	1f 4f       	sbci	r17, 0xFF	; 255
    1650:	c8 01       	movw	r24, r16
    1652:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    1656:	8e 89       	ldd	r24, Y+22	; 0x16
    1658:	90 91 91 06 	lds	r25, 0x0691
    165c:	98 17       	cp	r25, r24
    165e:	10 f4       	brcc	.+4      	; 0x1664 <xTaskResumeAll+0x64>
    1660:	80 93 91 06 	sts	0x0691, r24
    1664:	90 e0       	ldi	r25, 0x00	; 0
    1666:	9c 01       	movw	r18, r24
    1668:	22 0f       	add	r18, r18
    166a:	33 1f       	adc	r19, r19
    166c:	22 0f       	add	r18, r18
    166e:	33 1f       	adc	r19, r19
    1670:	22 0f       	add	r18, r18
    1672:	33 1f       	adc	r19, r19
    1674:	82 0f       	add	r24, r18
    1676:	93 1f       	adc	r25, r19
    1678:	85 56       	subi	r24, 0x65	; 101
    167a:	99 4f       	sbci	r25, 0xF9	; 249
    167c:	b8 01       	movw	r22, r16
    167e:	0e 94 8b 03 	call	0x716	; 0x716 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1682:	e0 91 8a 06 	lds	r30, 0x068A
    1686:	f0 91 8b 06 	lds	r31, 0x068B
    168a:	9e 89       	ldd	r25, Y+22	; 0x16
    168c:	86 89       	ldd	r24, Z+22	; 0x16
    168e:	98 17       	cp	r25, r24
    1690:	88 f0       	brcs	.+34     	; 0x16b4 <xTaskResumeAll+0xb4>
					{
						xYieldRequired = pdTRUE;
    1692:	ba 2c       	mov	r11, r10
    1694:	0f c0       	rjmp	.+30     	; 0x16b4 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    1696:	bb 24       	eor	r11, r11
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    1698:	0f 2e       	mov	r0, r31
    169a:	f6 eb       	ldi	r31, 0xB6	; 182
    169c:	ef 2e       	mov	r14, r31
    169e:	f6 e0       	ldi	r31, 0x06	; 6
    16a0:	ff 2e       	mov	r15, r31
    16a2:	f0 2d       	mov	r31, r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    16a4:	0f 2e       	mov	r0, r31
    16a6:	fb eb       	ldi	r31, 0xBB	; 187
    16a8:	cf 2e       	mov	r12, r31
    16aa:	f6 e0       	ldi	r31, 0x06	; 6
    16ac:	df 2e       	mov	r13, r31
    16ae:	f0 2d       	mov	r31, r0

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldRequired = pdTRUE;
    16b0:	aa 24       	eor	r10, r10
    16b2:	a3 94       	inc	r10
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    16b4:	f7 01       	movw	r30, r14
    16b6:	80 81       	ld	r24, Z
    16b8:	88 23       	and	r24, r24
    16ba:	09 f0       	breq	.+2      	; 0x16be <xTaskResumeAll+0xbe>
    16bc:	bd cf       	rjmp	.-134    	; 0x1638 <xTaskResumeAll+0x38>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    16be:	80 91 8e 06 	lds	r24, 0x068E
    16c2:	88 23       	and	r24, r24
    16c4:	81 f0       	breq	.+32     	; 0x16e6 <xTaskResumeAll+0xe6>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    16c6:	80 91 8e 06 	lds	r24, 0x068E
    16ca:	88 23       	and	r24, r24
    16cc:	99 f0       	breq	.+38     	; 0x16f4 <xTaskResumeAll+0xf4>
					{
						vTaskIncrementTick();
    16ce:	0e 94 3a 0a 	call	0x1474	; 0x1474 <vTaskIncrementTick>
						--uxMissedTicks;
    16d2:	80 91 8e 06 	lds	r24, 0x068E
    16d6:	81 50       	subi	r24, 0x01	; 1
    16d8:	80 93 8e 06 	sts	0x068E, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    16dc:	80 91 8e 06 	lds	r24, 0x068E
    16e0:	88 23       	and	r24, r24
    16e2:	a9 f7       	brne	.-22     	; 0x16ce <xTaskResumeAll+0xce>
    16e4:	07 c0       	rjmp	.+14     	; 0x16f4 <xTaskResumeAll+0xf4>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    16e6:	f1 e0       	ldi	r31, 0x01	; 1
    16e8:	bf 16       	cp	r11, r31
    16ea:	21 f0       	breq	.+8      	; 0x16f4 <xTaskResumeAll+0xf4>
    16ec:	80 91 8d 06 	lds	r24, 0x068D
    16f0:	81 30       	cpi	r24, 0x01	; 1
    16f2:	41 f4       	brne	.+16     	; 0x1704 <xTaskResumeAll+0x104>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    16f4:	10 92 8d 06 	sts	0x068D, r1
					portYIELD_WITHIN_API();
    16f8:	0e 94 dd 04 	call	0x9ba	; 0x9ba <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    16fc:	81 e0       	ldi	r24, 0x01	; 1
    16fe:	03 c0       	rjmp	.+6      	; 0x1706 <xTaskResumeAll+0x106>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    1700:	80 e0       	ldi	r24, 0x00	; 0
    1702:	01 c0       	rjmp	.+2      	; 0x1706 <xTaskResumeAll+0x106>
    1704:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    1706:	0f 90       	pop	r0
    1708:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    170a:	df 91       	pop	r29
    170c:	cf 91       	pop	r28
    170e:	1f 91       	pop	r17
    1710:	0f 91       	pop	r16
    1712:	ff 90       	pop	r15
    1714:	ef 90       	pop	r14
    1716:	df 90       	pop	r13
    1718:	cf 90       	pop	r12
    171a:	bf 90       	pop	r11
    171c:	af 90       	pop	r10
    171e:	08 95       	ret

00001720 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    1720:	cf 93       	push	r28
    1722:	df 93       	push	r29
    1724:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    1726:	00 97       	sbiw	r24, 0x00	; 0
    1728:	b1 f0       	breq	.+44     	; 0x1756 <vTaskDelay+0x36>
		{
			vTaskSuspendAll();
    172a:	0e 94 22 0a 	call	0x1444	; 0x1444 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    172e:	80 91 92 06 	lds	r24, 0x0692
    1732:	90 91 93 06 	lds	r25, 0x0693
    1736:	c8 0f       	add	r28, r24
    1738:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    173a:	80 91 8a 06 	lds	r24, 0x068A
    173e:	90 91 8b 06 	lds	r25, 0x068B
    1742:	02 96       	adiw	r24, 0x02	; 2
    1744:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1748:	ce 01       	movw	r24, r28
    174a:	0e 94 ba 08 	call	0x1174	; 0x1174 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    174e:	0e 94 00 0b 	call	0x1600	; 0x1600 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1752:	88 23       	and	r24, r24
    1754:	11 f4       	brne	.+4      	; 0x175a <vTaskDelay+0x3a>
		{
			portYIELD_WITHIN_API();
    1756:	0e 94 dd 04 	call	0x9ba	; 0x9ba <vPortYield>
		}
	}
    175a:	df 91       	pop	r29
    175c:	cf 91       	pop	r28
    175e:	08 95       	ret

00001760 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    1760:	0f 93       	push	r16
    1762:	1f 93       	push	r17
    1764:	cf 93       	push	r28
    1766:	df 93       	push	r29
    1768:	8c 01       	movw	r16, r24
    176a:	eb 01       	movw	r28, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    176c:	0e 94 22 0a 	call	0x1444	; 0x1444 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    1770:	f8 01       	movw	r30, r16
    1772:	80 81       	ld	r24, Z
    1774:	91 81       	ldd	r25, Z+1	; 0x01
    1776:	c8 0f       	add	r28, r24
    1778:	d9 1f       	adc	r29, r25

			if( xTickCount < *pxPreviousWakeTime )
    177a:	20 91 92 06 	lds	r18, 0x0692
    177e:	30 91 93 06 	lds	r19, 0x0693
    1782:	28 17       	cp	r18, r24
    1784:	39 07       	cpc	r19, r25
    1786:	68 f4       	brcc	.+26     	; 0x17a2 <vTaskDelayUntil+0x42>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    1788:	c8 17       	cp	r28, r24
    178a:	d9 07       	cpc	r29, r25
    178c:	50 f5       	brcc	.+84     	; 0x17e2 <vTaskDelayUntil+0x82>
    178e:	80 91 92 06 	lds	r24, 0x0692
    1792:	90 91 93 06 	lds	r25, 0x0693
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1796:	d1 83       	std	Z+1, r29	; 0x01
    1798:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
    179a:	8c 17       	cp	r24, r28
    179c:	9d 07       	cpc	r25, r29
    179e:	b0 f4       	brcc	.+44     	; 0x17cc <vTaskDelayUntil+0x6c>
    17a0:	0b c0       	rjmp	.+22     	; 0x17b8 <vTaskDelayUntil+0x58>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    17a2:	c8 17       	cp	r28, r24
    17a4:	d9 07       	cpc	r29, r25
    17a6:	c8 f0       	brcs	.+50     	; 0x17da <vTaskDelayUntil+0x7a>
    17a8:	80 91 92 06 	lds	r24, 0x0692
    17ac:	90 91 93 06 	lds	r25, 0x0693
    17b0:	8c 17       	cp	r24, r28
    17b2:	9d 07       	cpc	r25, r29
    17b4:	90 f0       	brcs	.+36     	; 0x17da <vTaskDelayUntil+0x7a>
    17b6:	15 c0       	rjmp	.+42     	; 0x17e2 <vTaskDelayUntil+0x82>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    17b8:	80 91 8a 06 	lds	r24, 0x068A
    17bc:	90 91 8b 06 	lds	r25, 0x068B
    17c0:	02 96       	adiw	r24, 0x02	; 2
    17c2:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    17c6:	ce 01       	movw	r24, r28
    17c8:	0e 94 ba 08 	call	0x1174	; 0x1174 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    17cc:	0e 94 00 0b 	call	0x1600	; 0x1600 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    17d0:	88 23       	and	r24, r24
    17d2:	59 f4       	brne	.+22     	; 0x17ea <vTaskDelayUntil+0x8a>
		{
			portYIELD_WITHIN_API();
    17d4:	0e 94 dd 04 	call	0x9ba	; 0x9ba <vPortYield>
    17d8:	08 c0       	rjmp	.+16     	; 0x17ea <vTaskDelayUntil+0x8a>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    17da:	f8 01       	movw	r30, r16
    17dc:	d1 83       	std	Z+1, r29	; 0x01
    17de:	c0 83       	st	Z, r28
    17e0:	eb cf       	rjmp	.-42     	; 0x17b8 <vTaskDelayUntil+0x58>
    17e2:	f8 01       	movw	r30, r16
    17e4:	d1 83       	std	Z+1, r29	; 0x01
    17e6:	c0 83       	st	Z, r28
    17e8:	f1 cf       	rjmp	.-30     	; 0x17cc <vTaskDelayUntil+0x6c>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    17ea:	df 91       	pop	r29
    17ec:	cf 91       	pop	r28
    17ee:	1f 91       	pop	r17
    17f0:	0f 91       	pop	r16
    17f2:	08 95       	ret

000017f4 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    17f4:	80 91 8f 06 	lds	r24, 0x068F
    17f8:	88 23       	and	r24, r24
    17fa:	99 f4       	brne	.+38     	; 0x1822 <vTaskSwitchContext+0x2e>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    17fc:	80 91 91 06 	lds	r24, 0x0691
    1800:	90 e0       	ldi	r25, 0x00	; 0
    1802:	fc 01       	movw	r30, r24
    1804:	ee 0f       	add	r30, r30
    1806:	ff 1f       	adc	r31, r31
    1808:	ee 0f       	add	r30, r30
    180a:	ff 1f       	adc	r31, r31
    180c:	ee 0f       	add	r30, r30
    180e:	ff 1f       	adc	r31, r31
    1810:	8e 0f       	add	r24, r30
    1812:	9f 1f       	adc	r25, r31
    1814:	fc 01       	movw	r30, r24
    1816:	e5 56       	subi	r30, 0x65	; 101
    1818:	f9 4f       	sbci	r31, 0xF9	; 249
    181a:	80 81       	ld	r24, Z
    181c:	88 23       	and	r24, r24
    181e:	29 f0       	breq	.+10     	; 0x182a <vTaskSwitchContext+0x36>
    1820:	1b c0       	rjmp	.+54     	; 0x1858 <vTaskSwitchContext+0x64>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    1822:	81 e0       	ldi	r24, 0x01	; 1
    1824:	80 93 8d 06 	sts	0x068D, r24
    1828:	08 95       	ret
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    182a:	80 91 91 06 	lds	r24, 0x0691
    182e:	81 50       	subi	r24, 0x01	; 1
    1830:	80 93 91 06 	sts	0x0691, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    1834:	80 91 91 06 	lds	r24, 0x0691
    1838:	90 e0       	ldi	r25, 0x00	; 0
    183a:	fc 01       	movw	r30, r24
    183c:	ee 0f       	add	r30, r30
    183e:	ff 1f       	adc	r31, r31
    1840:	ee 0f       	add	r30, r30
    1842:	ff 1f       	adc	r31, r31
    1844:	ee 0f       	add	r30, r30
    1846:	ff 1f       	adc	r31, r31
    1848:	8e 0f       	add	r24, r30
    184a:	9f 1f       	adc	r25, r31
    184c:	fc 01       	movw	r30, r24
    184e:	e5 56       	subi	r30, 0x65	; 101
    1850:	f9 4f       	sbci	r31, 0xF9	; 249
    1852:	80 81       	ld	r24, Z
    1854:	88 23       	and	r24, r24
    1856:	49 f3       	breq	.-46     	; 0x182a <vTaskSwitchContext+0x36>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    1858:	80 91 91 06 	lds	r24, 0x0691
    185c:	90 e0       	ldi	r25, 0x00	; 0
    185e:	fc 01       	movw	r30, r24
    1860:	ee 0f       	add	r30, r30
    1862:	ff 1f       	adc	r31, r31
    1864:	ee 0f       	add	r30, r30
    1866:	ff 1f       	adc	r31, r31
    1868:	ee 0f       	add	r30, r30
    186a:	ff 1f       	adc	r31, r31
    186c:	e8 0f       	add	r30, r24
    186e:	f9 1f       	adc	r31, r25
    1870:	e5 56       	subi	r30, 0x65	; 101
    1872:	f9 4f       	sbci	r31, 0xF9	; 249
    1874:	a1 81       	ldd	r26, Z+1	; 0x01
    1876:	b2 81       	ldd	r27, Z+2	; 0x02
    1878:	12 96       	adiw	r26, 0x02	; 2
    187a:	0d 90       	ld	r0, X+
    187c:	bc 91       	ld	r27, X
    187e:	a0 2d       	mov	r26, r0
    1880:	b2 83       	std	Z+2, r27	; 0x02
    1882:	a1 83       	std	Z+1, r26	; 0x01
    1884:	cf 01       	movw	r24, r30
    1886:	03 96       	adiw	r24, 0x03	; 3
    1888:	a8 17       	cp	r26, r24
    188a:	b9 07       	cpc	r27, r25
    188c:	31 f4       	brne	.+12     	; 0x189a <vTaskSwitchContext+0xa6>
    188e:	12 96       	adiw	r26, 0x02	; 2
    1890:	8d 91       	ld	r24, X+
    1892:	9c 91       	ld	r25, X
    1894:	13 97       	sbiw	r26, 0x03	; 3
    1896:	92 83       	std	Z+2, r25	; 0x02
    1898:	81 83       	std	Z+1, r24	; 0x01
    189a:	01 80       	ldd	r0, Z+1	; 0x01
    189c:	f2 81       	ldd	r31, Z+2	; 0x02
    189e:	e0 2d       	mov	r30, r0
    18a0:	86 81       	ldd	r24, Z+6	; 0x06
    18a2:	97 81       	ldd	r25, Z+7	; 0x07
    18a4:	90 93 8b 06 	sts	0x068B, r25
    18a8:	80 93 8a 06 	sts	0x068A, r24
    18ac:	08 95       	ret

000018ae <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    18ae:	cf 93       	push	r28
    18b0:	df 93       	push	r29
    18b2:	eb 01       	movw	r28, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    18b4:	60 91 8a 06 	lds	r22, 0x068A
    18b8:	70 91 8b 06 	lds	r23, 0x068B
    18bc:	64 5f       	subi	r22, 0xF4	; 244
    18be:	7f 4f       	sbci	r23, 0xFF	; 255
    18c0:	0e 94 b4 03 	call	0x768	; 0x768 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    18c4:	80 91 8a 06 	lds	r24, 0x068A
    18c8:	90 91 8b 06 	lds	r25, 0x068B
    18cc:	02 96       	adiw	r24, 0x02	; 2
    18ce:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    18d2:	80 91 92 06 	lds	r24, 0x0692
    18d6:	90 91 93 06 	lds	r25, 0x0693
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    18da:	8c 0f       	add	r24, r28
    18dc:	9d 1f       	adc	r25, r29
    18de:	0e 94 ba 08 	call	0x1174	; 0x1174 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    18e2:	df 91       	pop	r29
    18e4:	cf 91       	pop	r28
    18e6:	08 95       	ret

000018e8 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    18e8:	0f 93       	push	r16
    18ea:	1f 93       	push	r17
    18ec:	cf 93       	push	r28
    18ee:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    18f0:	dc 01       	movw	r26, r24
    18f2:	15 96       	adiw	r26, 0x05	; 5
    18f4:	ed 91       	ld	r30, X+
    18f6:	fc 91       	ld	r31, X
    18f8:	16 97       	sbiw	r26, 0x06	; 6
    18fa:	06 81       	ldd	r16, Z+6	; 0x06
    18fc:	17 81       	ldd	r17, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    18fe:	e8 01       	movw	r28, r16
    1900:	2c 96       	adiw	r28, 0x0c	; 12
    1902:	ce 01       	movw	r24, r28
    1904:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1908:	80 91 8f 06 	lds	r24, 0x068F
    190c:	88 23       	and	r24, r24
    190e:	e9 f4       	brne	.+58     	; 0x194a <xTaskRemoveFromEventList+0x62>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    1910:	e8 01       	movw	r28, r16
    1912:	22 96       	adiw	r28, 0x02	; 2
    1914:	ce 01       	movw	r24, r28
    1916:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    191a:	f8 01       	movw	r30, r16
    191c:	86 89       	ldd	r24, Z+22	; 0x16
    191e:	90 91 91 06 	lds	r25, 0x0691
    1922:	98 17       	cp	r25, r24
    1924:	10 f4       	brcc	.+4      	; 0x192a <xTaskRemoveFromEventList+0x42>
    1926:	80 93 91 06 	sts	0x0691, r24
    192a:	90 e0       	ldi	r25, 0x00	; 0
    192c:	9c 01       	movw	r18, r24
    192e:	22 0f       	add	r18, r18
    1930:	33 1f       	adc	r19, r19
    1932:	22 0f       	add	r18, r18
    1934:	33 1f       	adc	r19, r19
    1936:	22 0f       	add	r18, r18
    1938:	33 1f       	adc	r19, r19
    193a:	82 0f       	add	r24, r18
    193c:	93 1f       	adc	r25, r19
    193e:	85 56       	subi	r24, 0x65	; 101
    1940:	99 4f       	sbci	r25, 0xF9	; 249
    1942:	be 01       	movw	r22, r28
    1944:	0e 94 8b 03 	call	0x716	; 0x716 <vListInsertEnd>
    1948:	05 c0       	rjmp	.+10     	; 0x1954 <xTaskRemoveFromEventList+0x6c>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    194a:	86 eb       	ldi	r24, 0xB6	; 182
    194c:	96 e0       	ldi	r25, 0x06	; 6
    194e:	be 01       	movw	r22, r28
    1950:	0e 94 8b 03 	call	0x716	; 0x716 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1954:	e0 91 8a 06 	lds	r30, 0x068A
    1958:	f0 91 8b 06 	lds	r31, 0x068B
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    195c:	81 e0       	ldi	r24, 0x01	; 1
    195e:	d8 01       	movw	r26, r16
    1960:	56 96       	adiw	r26, 0x16	; 22
    1962:	2c 91       	ld	r18, X
    1964:	56 97       	sbiw	r26, 0x16	; 22
    1966:	96 89       	ldd	r25, Z+22	; 0x16
    1968:	29 17       	cp	r18, r25
    196a:	08 f4       	brcc	.+2      	; 0x196e <xTaskRemoveFromEventList+0x86>
    196c:	80 e0       	ldi	r24, 0x00	; 0
}
    196e:	df 91       	pop	r29
    1970:	cf 91       	pop	r28
    1972:	1f 91       	pop	r17
    1974:	0f 91       	pop	r16
    1976:	08 95       	ret

00001978 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    1978:	fc 01       	movw	r30, r24
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    197a:	80 91 8c 06 	lds	r24, 0x068C
    197e:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    1980:	80 91 92 06 	lds	r24, 0x0692
    1984:	90 91 93 06 	lds	r25, 0x0693
    1988:	92 83       	std	Z+2, r25	; 0x02
    198a:	81 83       	std	Z+1, r24	; 0x01
}
    198c:	08 95       	ret

0000198e <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    198e:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    1990:	0f b6       	in	r0, 0x3f	; 63
    1992:	f8 94       	cli
    1994:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    1996:	80 91 8c 06 	lds	r24, 0x068C
    199a:	90 81       	ld	r25, Z
    199c:	98 17       	cp	r25, r24
    199e:	49 f0       	breq	.+18     	; 0x19b2 <xTaskCheckForTimeOut+0x24>
    19a0:	80 91 92 06 	lds	r24, 0x0692
    19a4:	90 91 93 06 	lds	r25, 0x0693
    19a8:	21 81       	ldd	r18, Z+1	; 0x01
    19aa:	32 81       	ldd	r19, Z+2	; 0x02
    19ac:	82 17       	cp	r24, r18
    19ae:	93 07       	cpc	r25, r19
    19b0:	f0 f4       	brcc	.+60     	; 0x19ee <xTaskCheckForTimeOut+0x60>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    19b2:	80 91 92 06 	lds	r24, 0x0692
    19b6:	90 91 93 06 	lds	r25, 0x0693
    19ba:	21 81       	ldd	r18, Z+1	; 0x01
    19bc:	32 81       	ldd	r19, Z+2	; 0x02
    19be:	db 01       	movw	r26, r22
    19c0:	4d 91       	ld	r20, X+
    19c2:	5c 91       	ld	r21, X
    19c4:	11 97       	sbiw	r26, 0x01	; 1
    19c6:	82 1b       	sub	r24, r18
    19c8:	93 0b       	sbc	r25, r19
    19ca:	84 17       	cp	r24, r20
    19cc:	95 07       	cpc	r25, r21
    19ce:	88 f4       	brcc	.+34     	; 0x19f2 <xTaskCheckForTimeOut+0x64>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    19d0:	80 91 92 06 	lds	r24, 0x0692
    19d4:	90 91 93 06 	lds	r25, 0x0693
    19d8:	28 1b       	sub	r18, r24
    19da:	39 0b       	sbc	r19, r25
    19dc:	24 0f       	add	r18, r20
    19de:	35 1f       	adc	r19, r21
    19e0:	2d 93       	st	X+, r18
    19e2:	3c 93       	st	X, r19
			vTaskSetTimeOutState( pxTimeOut );
    19e4:	cf 01       	movw	r24, r30
    19e6:	0e 94 bc 0c 	call	0x1978	; 0x1978 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    19ea:	80 e0       	ldi	r24, 0x00	; 0
    19ec:	03 c0       	rjmp	.+6      	; 0x19f4 <xTaskCheckForTimeOut+0x66>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    19ee:	81 e0       	ldi	r24, 0x01	; 1
    19f0:	01 c0       	rjmp	.+2      	; 0x19f4 <xTaskCheckForTimeOut+0x66>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    19f2:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    19f4:	0f 90       	pop	r0
    19f6:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    19f8:	08 95       	ret

000019fa <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    19fa:	81 e0       	ldi	r24, 0x01	; 1
    19fc:	80 93 8d 06 	sts	0x068D, r24
}
    1a00:	08 95       	ret

00001a02 <__udivmodsi4>:
    1a02:	a1 e2       	ldi	r26, 0x21	; 33
    1a04:	1a 2e       	mov	r1, r26
    1a06:	aa 1b       	sub	r26, r26
    1a08:	bb 1b       	sub	r27, r27
    1a0a:	fd 01       	movw	r30, r26
    1a0c:	0d c0       	rjmp	.+26     	; 0x1a28 <__udivmodsi4_ep>

00001a0e <__udivmodsi4_loop>:
    1a0e:	aa 1f       	adc	r26, r26
    1a10:	bb 1f       	adc	r27, r27
    1a12:	ee 1f       	adc	r30, r30
    1a14:	ff 1f       	adc	r31, r31
    1a16:	a2 17       	cp	r26, r18
    1a18:	b3 07       	cpc	r27, r19
    1a1a:	e4 07       	cpc	r30, r20
    1a1c:	f5 07       	cpc	r31, r21
    1a1e:	20 f0       	brcs	.+8      	; 0x1a28 <__udivmodsi4_ep>
    1a20:	a2 1b       	sub	r26, r18
    1a22:	b3 0b       	sbc	r27, r19
    1a24:	e4 0b       	sbc	r30, r20
    1a26:	f5 0b       	sbc	r31, r21

00001a28 <__udivmodsi4_ep>:
    1a28:	66 1f       	adc	r22, r22
    1a2a:	77 1f       	adc	r23, r23
    1a2c:	88 1f       	adc	r24, r24
    1a2e:	99 1f       	adc	r25, r25
    1a30:	1a 94       	dec	r1
    1a32:	69 f7       	brne	.-38     	; 0x1a0e <__udivmodsi4_loop>
    1a34:	60 95       	com	r22
    1a36:	70 95       	com	r23
    1a38:	80 95       	com	r24
    1a3a:	90 95       	com	r25
    1a3c:	9b 01       	movw	r18, r22
    1a3e:	ac 01       	movw	r20, r24
    1a40:	bd 01       	movw	r22, r26
    1a42:	cf 01       	movw	r24, r30
    1a44:	08 95       	ret

00001a46 <memcpy>:
    1a46:	fb 01       	movw	r30, r22
    1a48:	dc 01       	movw	r26, r24
    1a4a:	02 c0       	rjmp	.+4      	; 0x1a50 <memcpy+0xa>
    1a4c:	01 90       	ld	r0, Z+
    1a4e:	0d 92       	st	X+, r0
    1a50:	41 50       	subi	r20, 0x01	; 1
    1a52:	50 40       	sbci	r21, 0x00	; 0
    1a54:	d8 f7       	brcc	.-10     	; 0x1a4c <memcpy+0x6>
    1a56:	08 95       	ret

00001a58 <memset>:
    1a58:	dc 01       	movw	r26, r24
    1a5a:	01 c0       	rjmp	.+2      	; 0x1a5e <memset+0x6>
    1a5c:	6d 93       	st	X+, r22
    1a5e:	41 50       	subi	r20, 0x01	; 1
    1a60:	50 40       	sbci	r21, 0x00	; 0
    1a62:	e0 f7       	brcc	.-8      	; 0x1a5c <memset+0x4>
    1a64:	08 95       	ret

00001a66 <strncpy>:
    1a66:	fb 01       	movw	r30, r22
    1a68:	dc 01       	movw	r26, r24
    1a6a:	41 50       	subi	r20, 0x01	; 1
    1a6c:	50 40       	sbci	r21, 0x00	; 0
    1a6e:	48 f0       	brcs	.+18     	; 0x1a82 <strncpy+0x1c>
    1a70:	01 90       	ld	r0, Z+
    1a72:	0d 92       	st	X+, r0
    1a74:	00 20       	and	r0, r0
    1a76:	c9 f7       	brne	.-14     	; 0x1a6a <strncpy+0x4>
    1a78:	01 c0       	rjmp	.+2      	; 0x1a7c <strncpy+0x16>
    1a7a:	1d 92       	st	X+, r1
    1a7c:	41 50       	subi	r20, 0x01	; 1
    1a7e:	50 40       	sbci	r21, 0x00	; 0
    1a80:	e0 f7       	brcc	.-8      	; 0x1a7a <strncpy+0x14>
    1a82:	08 95       	ret

00001a84 <itoa>:
    1a84:	fb 01       	movw	r30, r22
    1a86:	9f 01       	movw	r18, r30
    1a88:	e8 94       	clt
    1a8a:	42 30       	cpi	r20, 0x02	; 2
    1a8c:	c4 f0       	brlt	.+48     	; 0x1abe <itoa+0x3a>
    1a8e:	45 32       	cpi	r20, 0x25	; 37
    1a90:	b4 f4       	brge	.+44     	; 0x1abe <itoa+0x3a>
    1a92:	4a 30       	cpi	r20, 0x0A	; 10
    1a94:	29 f4       	brne	.+10     	; 0x1aa0 <itoa+0x1c>
    1a96:	97 fb       	bst	r25, 7
    1a98:	1e f4       	brtc	.+6      	; 0x1aa0 <itoa+0x1c>
    1a9a:	90 95       	com	r25
    1a9c:	81 95       	neg	r24
    1a9e:	9f 4f       	sbci	r25, 0xFF	; 255
    1aa0:	64 2f       	mov	r22, r20
    1aa2:	77 27       	eor	r23, r23
    1aa4:	0e 94 73 0d 	call	0x1ae6	; 0x1ae6 <__udivmodhi4>
    1aa8:	80 5d       	subi	r24, 0xD0	; 208
    1aaa:	8a 33       	cpi	r24, 0x3A	; 58
    1aac:	0c f0       	brlt	.+2      	; 0x1ab0 <itoa+0x2c>
    1aae:	89 5d       	subi	r24, 0xD9	; 217
    1ab0:	81 93       	st	Z+, r24
    1ab2:	cb 01       	movw	r24, r22
    1ab4:	00 97       	sbiw	r24, 0x00	; 0
    1ab6:	a1 f7       	brne	.-24     	; 0x1aa0 <itoa+0x1c>
    1ab8:	16 f4       	brtc	.+4      	; 0x1abe <itoa+0x3a>
    1aba:	5d e2       	ldi	r21, 0x2D	; 45
    1abc:	51 93       	st	Z+, r21
    1abe:	10 82       	st	Z, r1
    1ac0:	c9 01       	movw	r24, r18
    1ac2:	0c 94 63 0d 	jmp	0x1ac6	; 0x1ac6 <strrev>

00001ac6 <strrev>:
    1ac6:	dc 01       	movw	r26, r24
    1ac8:	fc 01       	movw	r30, r24
    1aca:	67 2f       	mov	r22, r23
    1acc:	71 91       	ld	r23, Z+
    1ace:	77 23       	and	r23, r23
    1ad0:	e1 f7       	brne	.-8      	; 0x1aca <strrev+0x4>
    1ad2:	32 97       	sbiw	r30, 0x02	; 2
    1ad4:	04 c0       	rjmp	.+8      	; 0x1ade <strrev+0x18>
    1ad6:	7c 91       	ld	r23, X
    1ad8:	6d 93       	st	X+, r22
    1ada:	70 83       	st	Z, r23
    1adc:	62 91       	ld	r22, -Z
    1ade:	ae 17       	cp	r26, r30
    1ae0:	bf 07       	cpc	r27, r31
    1ae2:	c8 f3       	brcs	.-14     	; 0x1ad6 <strrev+0x10>
    1ae4:	08 95       	ret

00001ae6 <__udivmodhi4>:
    1ae6:	aa 1b       	sub	r26, r26
    1ae8:	bb 1b       	sub	r27, r27
    1aea:	51 e1       	ldi	r21, 0x11	; 17
    1aec:	07 c0       	rjmp	.+14     	; 0x1afc <__udivmodhi4_ep>

00001aee <__udivmodhi4_loop>:
    1aee:	aa 1f       	adc	r26, r26
    1af0:	bb 1f       	adc	r27, r27
    1af2:	a6 17       	cp	r26, r22
    1af4:	b7 07       	cpc	r27, r23
    1af6:	10 f0       	brcs	.+4      	; 0x1afc <__udivmodhi4_ep>
    1af8:	a6 1b       	sub	r26, r22
    1afa:	b7 0b       	sbc	r27, r23

00001afc <__udivmodhi4_ep>:
    1afc:	88 1f       	adc	r24, r24
    1afe:	99 1f       	adc	r25, r25
    1b00:	5a 95       	dec	r21
    1b02:	a9 f7       	brne	.-22     	; 0x1aee <__udivmodhi4_loop>
    1b04:	80 95       	com	r24
    1b06:	90 95       	com	r25
    1b08:	bc 01       	movw	r22, r24
    1b0a:	cd 01       	movw	r24, r26
    1b0c:	08 95       	ret

00001b0e <_exit>:
    1b0e:	f8 94       	cli

00001b10 <__stop_program>:
    1b10:	ff cf       	rjmp	.-2      	; 0x1b10 <__stop_program>

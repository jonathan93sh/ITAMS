
RTOS_HH.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001502  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000001c  00800060  00001502  00001596  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000618  0080007c  0080007c  000015b2  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000015b2  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000015e4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000002f0  00000000  00000000  00001620  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00003519  00000000  00000000  00001910  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001276  00000000  00000000  00004e29  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001b30  00000000  00000000  0000609f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000078c  00000000  00000000  00007bd0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000f3a  00000000  00000000  0000835c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000021bc  00000000  00000000  00009296  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000002a8  00000000  00000000  0000b452  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 40 01 	jmp	0x280	; 0x280 <__vector_1>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 cf 03 	jmp	0x79e	; 0x79e <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e2 e0       	ldi	r30, 0x02	; 2
      68:	f5 e1       	ldi	r31, 0x15	; 21
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	ac 37       	cpi	r26, 0x7C	; 124
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	26 e0       	ldi	r18, 0x06	; 6
      78:	ac e7       	ldi	r26, 0x7C	; 124
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a4 39       	cpi	r26, 0x94	; 148
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 79 01 	call	0x2f2	; 0x2f2 <main>
      8a:	0c 94 7f 0a 	jmp	0x14fe	; 0x14fe <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <initLEDport>:
#define MAX_LED_NR 7

void initLEDport()
{
  // All PORTC pins are outputs 
  DDRC = 0b11111111;
      92:	8f ef       	ldi	r24, 0xFF	; 255
      94:	84 bb       	out	0x14, r24	; 20
  // Turn off all LEDs
  PORTC = 0xFF;     
      96:	85 bb       	out	0x15, r24	; 21
      98:	08 95       	ret

0000009a <writeAllLEDs>:
void writeAllLEDs(unsigned char pattern)
{
  // Fetch the parameter, invert all bits, and send to LEDs
  // The bits has to be inverted, because HW dictates 
  // a 0 will turn ON a LED
  PORTC = ~pattern;   
      9a:	80 95       	com	r24
      9c:	85 bb       	out	0x15, r24	; 21
      9e:	08 95       	ret

000000a0 <initSwitchPort>:

// Prepare the switch port
void initSwitchPort()
{
  // Switch port (PA pins) = All inputs
  DDRA = 0;	
      a0:	1a ba       	out	0x1a, r1	; 26
      a2:	08 95       	ret

000000a4 <switchStatus>:
}

// Reads all switches at a time
unsigned char switchStatus()
{
  return (~PINA);	
      a4:	89 b3       	in	r24, 0x19	; 25
}
      a6:	80 95       	com	r24
      a8:	08 95       	ret

000000aa <switchOn>:
// Returns TRUE, if the switch having the number
// "switch_nr" is activated - otherwise return FALSE
unsigned char switchOn(unsigned char switch_nr)
{
unsigned char mask;
  if (switch_nr <= MAX_SWITCH_NR)
      aa:	88 30       	cpi	r24, 0x08	; 8
      ac:	60 f4       	brcc	.+24     	; 0xc6 <switchOn+0x1c>
  {
    mask = 0b00000001 << switch_nr;
    return (~PINA & mask);
      ae:	99 b3       	in	r25, 0x19	; 25
unsigned char switchOn(unsigned char switch_nr)
{
unsigned char mask;
  if (switch_nr <= MAX_SWITCH_NR)
  {
    mask = 0b00000001 << switch_nr;
      b0:	21 e0       	ldi	r18, 0x01	; 1
      b2:	30 e0       	ldi	r19, 0x00	; 0
      b4:	02 c0       	rjmp	.+4      	; 0xba <switchOn+0x10>
      b6:	22 0f       	add	r18, r18
      b8:	33 1f       	adc	r19, r19
      ba:	8a 95       	dec	r24
      bc:	e2 f7       	brpl	.-8      	; 0xb6 <switchOn+0xc>
    return (~PINA & mask);
      be:	89 2f       	mov	r24, r25
      c0:	80 95       	com	r24
      c2:	82 23       	and	r24, r18
      c4:	08 95       	ret
  }
  else
    return 0;	
      c6:	80 e0       	ldi	r24, 0x00	; 0
} 
      c8:	08 95       	ret

000000ca <InitUART>:
Parameters:
	BaudRate: Wanted Baud Rate.
	Databits: Wanted number of Data Bits.
*************************************************************************/
void InitUART(unsigned long BaudRate, unsigned char DataBit)
{
      ca:	0f 93       	push	r16
      cc:	1f 93       	push	r17
unsigned int TempUBRR;

  if ((BaudRate >= 110) && (BaudRate <= 115200) && (DataBit >=5) && (DataBit <= 8))
      ce:	8b 01       	movw	r16, r22
      d0:	9c 01       	movw	r18, r24
      d2:	0e 56       	subi	r16, 0x6E	; 110
      d4:	11 09       	sbc	r17, r1
      d6:	21 09       	sbc	r18, r1
      d8:	31 09       	sbc	r19, r1
      da:	03 39       	cpi	r16, 0x93	; 147
      dc:	11 4c       	sbci	r17, 0xC1	; 193
      de:	21 40       	sbci	r18, 0x01	; 1
      e0:	31 05       	cpc	r19, r1
      e2:	68 f5       	brcc	.+90     	; 0x13e <InitUART+0x74>
      e4:	2b ef       	ldi	r18, 0xFB	; 251
      e6:	24 0f       	add	r18, r20
      e8:	24 30       	cpi	r18, 0x04	; 4
      ea:	48 f5       	brcc	.+82     	; 0x13e <InitUART+0x74>
  { 
    // "Normal" clock, no multiprocessor mode (= default)
    UCSRA = 0b00100000;
      ec:	20 e2       	ldi	r18, 0x20	; 32
      ee:	2b b9       	out	0x0b, r18	; 11
    // No interrupts enabled
    // Receiver enabled
    // Transmitter enabled
    // No 9 bit operation
    UCSRB = 0b00011000;	
      f0:	28 e1       	ldi	r18, 0x18	; 24
      f2:	2a b9       	out	0x0a, r18	; 10
    // Asynchronous operation, 1 stop bit, no parity
    // Bit7 always has to be 1
    // Bit 2 and bit 1 controls the number of databits
    UCSRC = 0b10000000 | (DataBit-5)<<1;
      f4:	50 e0       	ldi	r21, 0x00	; 0
      f6:	45 50       	subi	r20, 0x05	; 5
      f8:	51 09       	sbc	r21, r1
      fa:	44 0f       	add	r20, r20
      fc:	55 1f       	adc	r21, r21
      fe:	40 68       	ori	r20, 0x80	; 128
     100:	40 bd       	out	0x20, r20	; 32
    // Set Baud Rate according to the parameter BaudRate:
    // Select Baud Rate (first store "UBRRH--UBRRL" in local 16-bit variable,
    //                   then write the two 8-bit registers separately):
    TempUBRR = XTAL/(16*BaudRate) - 1;
     102:	dc 01       	movw	r26, r24
     104:	cb 01       	movw	r24, r22
     106:	88 0f       	add	r24, r24
     108:	99 1f       	adc	r25, r25
     10a:	aa 1f       	adc	r26, r26
     10c:	bb 1f       	adc	r27, r27
     10e:	88 0f       	add	r24, r24
     110:	99 1f       	adc	r25, r25
     112:	aa 1f       	adc	r26, r26
     114:	bb 1f       	adc	r27, r27
     116:	9c 01       	movw	r18, r24
     118:	ad 01       	movw	r20, r26
     11a:	22 0f       	add	r18, r18
     11c:	33 1f       	adc	r19, r19
     11e:	44 1f       	adc	r20, r20
     120:	55 1f       	adc	r21, r21
     122:	22 0f       	add	r18, r18
     124:	33 1f       	adc	r19, r19
     126:	44 1f       	adc	r20, r20
     128:	55 1f       	adc	r21, r21
     12a:	60 e0       	ldi	r22, 0x00	; 0
     12c:	70 e4       	ldi	r23, 0x40	; 64
     12e:	88 e3       	ldi	r24, 0x38	; 56
     130:	90 e0       	ldi	r25, 0x00	; 0
     132:	0e 94 3e 0a 	call	0x147c	; 0x147c <__udivmodsi4>
     136:	21 50       	subi	r18, 0x01	; 1
     138:	31 09       	sbc	r19, r1
    // Write upper part of UBRR
    UBRRH = TempUBRR >> 8;
     13a:	30 bd       	out	0x20, r19	; 32
    // Write lower part of UBRR
    UBRRL = TempUBRR;
     13c:	29 b9       	out	0x09, r18	; 9
  }  
}
     13e:	1f 91       	pop	r17
     140:	0f 91       	pop	r16
     142:	08 95       	ret

00000144 <EnterBoot>:
void EnterBoot( void *pvParameters)
{
	
	while(1)
	{
		if(((switchStatus() >> 7)&0b1) == 1)
     144:	0e 94 52 00 	call	0xa4	; 0xa4 <switchStatus>
     148:	88 23       	and	r24, r24
     14a:	14 f4       	brge	.+4      	; 0x150 <EnterBoot+0xc>
		{
			__asm("jmp 0x3c00");
     14c:	0c 94 00 1e 	jmp	0x3c00	; 0x3c00 <__data_load_end+0x26e2>
			
		}
		vTaskDelay(1000);
     150:	88 ee       	ldi	r24, 0xE8	; 232
     152:	93 e0       	ldi	r25, 0x03	; 3
     154:	0e 94 09 09 	call	0x1212	; 0x1212 <vTaskDelay>
	}
     158:	f5 cf       	rjmp	.-22     	; 0x144 <EnterBoot>

0000015a <decement>:
void decement(void *par)
{
	
	while(1)
	{
		if(switchOn(0))
     15a:	80 e0       	ldi	r24, 0x00	; 0
     15c:	0e 94 55 00 	call	0xaa	; 0xaa <switchOn>
     160:	88 23       	and	r24, r24
     162:	91 f1       	breq	.+100    	; 0x1c8 <decement+0x6e>
		{
			if(xSemaphoreTake(xSem1, 10000))
     164:	20 e0       	ldi	r18, 0x00	; 0
     166:	40 e1       	ldi	r20, 0x10	; 16
     168:	57 e2       	ldi	r21, 0x27	; 39
     16a:	60 e0       	ldi	r22, 0x00	; 0
     16c:	70 e0       	ldi	r23, 0x00	; 0
     16e:	80 91 7f 00 	lds	r24, 0x007F	; 0x80007f <xSem1>
     172:	90 91 80 00 	lds	r25, 0x0080	; 0x800080 <xSem1+0x1>
     176:	0e 94 b4 05 	call	0xb68	; 0xb68 <xQueueGenericReceive>
     17a:	88 23       	and	r24, r24
     17c:	29 f1       	breq	.+74     	; 0x1c8 <decement+0x6e>
			{
				count++;
     17e:	80 91 7e 00 	lds	r24, 0x007E	; 0x80007e <count>
     182:	8f 5f       	subi	r24, 0xFF	; 255
     184:	80 93 7e 00 	sts	0x007E, r24	; 0x80007e <count>
				xQueueSend(xQueue1,&count, 1000);
     188:	20 e0       	ldi	r18, 0x00	; 0
     18a:	48 ee       	ldi	r20, 0xE8	; 232
     18c:	53 e0       	ldi	r21, 0x03	; 3
     18e:	6e e7       	ldi	r22, 0x7E	; 126
     190:	70 e0       	ldi	r23, 0x00	; 0
     192:	80 91 7c 00 	lds	r24, 0x007C	; 0x80007c <__data_end>
     196:	90 91 7d 00 	lds	r25, 0x007D	; 0x80007d <__data_end+0x1>
     19a:	0e 94 ee 04 	call	0x9dc	; 0x9dc <xQueueGenericSend>
				xSemaphoreGive(xSem1);
     19e:	20 e0       	ldi	r18, 0x00	; 0
     1a0:	40 e0       	ldi	r20, 0x00	; 0
     1a2:	50 e0       	ldi	r21, 0x00	; 0
     1a4:	60 e0       	ldi	r22, 0x00	; 0
     1a6:	70 e0       	ldi	r23, 0x00	; 0
     1a8:	80 91 7f 00 	lds	r24, 0x007F	; 0x80007f <xSem1>
     1ac:	90 91 80 00 	lds	r25, 0x0080	; 0x800080 <xSem1+0x1>
     1b0:	0e 94 ee 04 	call	0x9dc	; 0x9dc <xQueueGenericSend>
				while(switchOn(0)){vTaskDelay(100);}
     1b4:	04 c0       	rjmp	.+8      	; 0x1be <decement+0x64>
     1b6:	84 e6       	ldi	r24, 0x64	; 100
     1b8:	90 e0       	ldi	r25, 0x00	; 0
     1ba:	0e 94 09 09 	call	0x1212	; 0x1212 <vTaskDelay>
     1be:	80 e0       	ldi	r24, 0x00	; 0
     1c0:	0e 94 55 00 	call	0xaa	; 0xaa <switchOn>
     1c4:	81 11       	cpse	r24, r1
     1c6:	f7 cf       	rjmp	.-18     	; 0x1b6 <decement+0x5c>
			}
			
		}
		vTaskDelay(100);
     1c8:	84 e6       	ldi	r24, 0x64	; 100
     1ca:	90 e0       	ldi	r25, 0x00	; 0
     1cc:	0e 94 09 09 	call	0x1212	; 0x1212 <vTaskDelay>
	}
     1d0:	c4 cf       	rjmp	.-120    	; 0x15a <decement>

000001d2 <increment>:
void increment(void *par)
{
	
	while(1)
	{
		if(switchOn(1))
     1d2:	81 e0       	ldi	r24, 0x01	; 1
     1d4:	0e 94 55 00 	call	0xaa	; 0xaa <switchOn>
     1d8:	88 23       	and	r24, r24
     1da:	91 f1       	breq	.+100    	; 0x240 <increment+0x6e>
		{
			if(xSemaphoreTake(xSem1, 10000))
     1dc:	20 e0       	ldi	r18, 0x00	; 0
     1de:	40 e1       	ldi	r20, 0x10	; 16
     1e0:	57 e2       	ldi	r21, 0x27	; 39
     1e2:	60 e0       	ldi	r22, 0x00	; 0
     1e4:	70 e0       	ldi	r23, 0x00	; 0
     1e6:	80 91 7f 00 	lds	r24, 0x007F	; 0x80007f <xSem1>
     1ea:	90 91 80 00 	lds	r25, 0x0080	; 0x800080 <xSem1+0x1>
     1ee:	0e 94 b4 05 	call	0xb68	; 0xb68 <xQueueGenericReceive>
     1f2:	88 23       	and	r24, r24
     1f4:	29 f1       	breq	.+74     	; 0x240 <increment+0x6e>
			{
				count--;
     1f6:	80 91 7e 00 	lds	r24, 0x007E	; 0x80007e <count>
     1fa:	81 50       	subi	r24, 0x01	; 1
     1fc:	80 93 7e 00 	sts	0x007E, r24	; 0x80007e <count>
				xQueueSend(xQueue1,&count, 1000);
     200:	20 e0       	ldi	r18, 0x00	; 0
     202:	48 ee       	ldi	r20, 0xE8	; 232
     204:	53 e0       	ldi	r21, 0x03	; 3
     206:	6e e7       	ldi	r22, 0x7E	; 126
     208:	70 e0       	ldi	r23, 0x00	; 0
     20a:	80 91 7c 00 	lds	r24, 0x007C	; 0x80007c <__data_end>
     20e:	90 91 7d 00 	lds	r25, 0x007D	; 0x80007d <__data_end+0x1>
     212:	0e 94 ee 04 	call	0x9dc	; 0x9dc <xQueueGenericSend>
				xSemaphoreGive(xSem1);
     216:	20 e0       	ldi	r18, 0x00	; 0
     218:	40 e0       	ldi	r20, 0x00	; 0
     21a:	50 e0       	ldi	r21, 0x00	; 0
     21c:	60 e0       	ldi	r22, 0x00	; 0
     21e:	70 e0       	ldi	r23, 0x00	; 0
     220:	80 91 7f 00 	lds	r24, 0x007F	; 0x80007f <xSem1>
     224:	90 91 80 00 	lds	r25, 0x0080	; 0x800080 <xSem1+0x1>
     228:	0e 94 ee 04 	call	0x9dc	; 0x9dc <xQueueGenericSend>
				while(switchOn(1)){vTaskDelay(100);}
     22c:	04 c0       	rjmp	.+8      	; 0x236 <increment+0x64>
     22e:	84 e6       	ldi	r24, 0x64	; 100
     230:	90 e0       	ldi	r25, 0x00	; 0
     232:	0e 94 09 09 	call	0x1212	; 0x1212 <vTaskDelay>
     236:	81 e0       	ldi	r24, 0x01	; 1
     238:	0e 94 55 00 	call	0xaa	; 0xaa <switchOn>
     23c:	81 11       	cpse	r24, r1
     23e:	f7 cf       	rjmp	.-18     	; 0x22e <increment+0x5c>
			}
		}
		vTaskDelay(100);
     240:	84 e6       	ldi	r24, 0x64	; 100
     242:	90 e0       	ldi	r25, 0x00	; 0
     244:	0e 94 09 09 	call	0x1212	; 0x1212 <vTaskDelay>
		
	}
     248:	c4 cf       	rjmp	.-120    	; 0x1d2 <increment>

0000024a <LEDDisplay>:
}

void LEDDisplay(void *par)
{
     24a:	cf 93       	push	r28
     24c:	df 93       	push	r29
     24e:	1f 92       	push	r1
     250:	cd b7       	in	r28, 0x3d	; 61
     252:	de b7       	in	r29, 0x3e	; 62
	uint8_t itemBuffer = 0;
     254:	19 82       	std	Y+1, r1	; 0x01
	writeAllLEDs(itemBuffer);
     256:	80 e0       	ldi	r24, 0x00	; 0
     258:	0e 94 4d 00 	call	0x9a	; 0x9a <writeAllLEDs>
	while(1)
	{
		if(xQueueReceive(xQueue1, &itemBuffer, 1000))
     25c:	20 e0       	ldi	r18, 0x00	; 0
     25e:	48 ee       	ldi	r20, 0xE8	; 232
     260:	53 e0       	ldi	r21, 0x03	; 3
     262:	be 01       	movw	r22, r28
     264:	6f 5f       	subi	r22, 0xFF	; 255
     266:	7f 4f       	sbci	r23, 0xFF	; 255
     268:	80 91 7c 00 	lds	r24, 0x007C	; 0x80007c <__data_end>
     26c:	90 91 7d 00 	lds	r25, 0x007D	; 0x80007d <__data_end+0x1>
     270:	0e 94 b4 05 	call	0xb68	; 0xb68 <xQueueGenericReceive>
     274:	88 23       	and	r24, r24
     276:	91 f3       	breq	.-28     	; 0x25c <LEDDisplay+0x12>
		{
			writeAllLEDs(itemBuffer);
     278:	89 81       	ldd	r24, Y+1	; 0x01
     27a:	0e 94 4d 00 	call	0x9a	; 0x9a <writeAllLEDs>
     27e:	ee cf       	rjmp	.-36     	; 0x25c <LEDDisplay+0x12>

00000280 <__vector_1>:
	}
}


ISR(INT0_vect)
{
     280:	1f 92       	push	r1
     282:	0f 92       	push	r0
     284:	0f b6       	in	r0, 0x3f	; 63
     286:	0f 92       	push	r0
     288:	11 24       	eor	r1, r1
     28a:	2f 93       	push	r18
     28c:	3f 93       	push	r19
     28e:	4f 93       	push	r20
     290:	5f 93       	push	r21
     292:	6f 93       	push	r22
     294:	7f 93       	push	r23
     296:	8f 93       	push	r24
     298:	9f 93       	push	r25
     29a:	af 93       	push	r26
     29c:	bf 93       	push	r27
     29e:	ef 93       	push	r30
     2a0:	ff 93       	push	r31
     2a2:	cf 93       	push	r28
     2a4:	df 93       	push	r29
     2a6:	1f 92       	push	r1
     2a8:	cd b7       	in	r28, 0x3d	; 61
     2aa:	de b7       	in	r29, 0x3e	; 62
	uint8_t tmp = 0;
     2ac:	19 82       	std	Y+1, r1	; 0x01
	//writeAllLEDs(0b1010101);
	xQueueSendToBackFromISR(xQueue1, &tmp,pdTRUE);
     2ae:	20 e0       	ldi	r18, 0x00	; 0
     2b0:	41 e0       	ldi	r20, 0x01	; 1
     2b2:	50 e0       	ldi	r21, 0x00	; 0
     2b4:	be 01       	movw	r22, r28
     2b6:	6f 5f       	subi	r22, 0xFF	; 255
     2b8:	7f 4f       	sbci	r23, 0xFF	; 255
     2ba:	80 91 7c 00 	lds	r24, 0x007C	; 0x80007c <__data_end>
     2be:	90 91 7d 00 	lds	r25, 0x007D	; 0x80007d <__data_end+0x1>
     2c2:	0e 94 88 05 	call	0xb10	; 0xb10 <xQueueGenericSendFromISR>
	count = 0;
     2c6:	10 92 7e 00 	sts	0x007E, r1	; 0x80007e <count>
}
     2ca:	0f 90       	pop	r0
     2cc:	df 91       	pop	r29
     2ce:	cf 91       	pop	r28
     2d0:	ff 91       	pop	r31
     2d2:	ef 91       	pop	r30
     2d4:	bf 91       	pop	r27
     2d6:	af 91       	pop	r26
     2d8:	9f 91       	pop	r25
     2da:	8f 91       	pop	r24
     2dc:	7f 91       	pop	r23
     2de:	6f 91       	pop	r22
     2e0:	5f 91       	pop	r21
     2e2:	4f 91       	pop	r20
     2e4:	3f 91       	pop	r19
     2e6:	2f 91       	pop	r18
     2e8:	0f 90       	pop	r0
     2ea:	0f be       	out	0x3f, r0	; 63
     2ec:	0f 90       	pop	r0
     2ee:	1f 90       	pop	r1
     2f0:	18 95       	reti

000002f2 <main>:


int main(void)
{
	
	PORTA &= ~(1<<2);
     2f2:	da 98       	cbi	0x1b, 2	; 27
	DDRD &= ~(1<<2);
     2f4:	8a 98       	cbi	0x11, 2	; 17
	MCUCR |= 0b11;
     2f6:	85 b7       	in	r24, 0x35	; 53
     2f8:	83 60       	ori	r24, 0x03	; 3
     2fa:	85 bf       	out	0x35, r24	; 53
	
	GICR |= (1<<6);    
     2fc:	8b b7       	in	r24, 0x3b	; 59
     2fe:	80 64       	ori	r24, 0x40	; 64
     300:	8b bf       	out	0x3b, r24	; 59
	sei();
	*/
	
	//rit_setup_callback(one_sec_isr, 1000);
	
  initLEDport();
     302:	0e 94 49 00 	call	0x92	; 0x92 <initLEDport>
  initSwitchPort();
     306:	0e 94 50 00 	call	0xa0	; 0xa0 <initSwitchPort>
  InitUART(115200,8);
     30a:	48 e0       	ldi	r20, 0x08	; 8
     30c:	60 e0       	ldi	r22, 0x00	; 0
     30e:	72 ec       	ldi	r23, 0xC2	; 194
     310:	81 e0       	ldi	r24, 0x01	; 1
     312:	90 e0       	ldi	r25, 0x00	; 0
     314:	0e 94 65 00 	call	0xca	; 0xca <InitUART>
  
  
  xTaskCreate(EnterBoot, (signed char *) "BootKey", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL);
     318:	a1 2c       	mov	r10, r1
     31a:	b1 2c       	mov	r11, r1
     31c:	c1 2c       	mov	r12, r1
     31e:	d1 2c       	mov	r13, r1
     320:	e1 2c       	mov	r14, r1
     322:	f1 2c       	mov	r15, r1
     324:	00 e0       	ldi	r16, 0x00	; 0
     326:	20 e0       	ldi	r18, 0x00	; 0
     328:	30 e0       	ldi	r19, 0x00	; 0
     32a:	45 e5       	ldi	r20, 0x55	; 85
     32c:	50 e0       	ldi	r21, 0x00	; 0
     32e:	62 e6       	ldi	r22, 0x62	; 98
     330:	70 e0       	ldi	r23, 0x00	; 0
     332:	82 ea       	ldi	r24, 0xA2	; 162
     334:	90 e0       	ldi	r25, 0x00	; 0
     336:	0e 94 9f 06 	call	0xd3e	; 0xd3e <xTaskGenericCreate>
  xTaskCreate( vLEDFlashTask1, ( signed char * ) "LED1", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
  xTaskCreate( vLEDFlashTask2, ( signed char * ) "LED2", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );	
  xTaskCreate(SW0Wait, (signed char *) "SW", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL);
  xTaskCreate(LED7on, (signed char *) "LED", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL);
  #elif EX_PART == 3
	vSemaphoreCreateBinary(xSem1);
     33a:	43 e0       	ldi	r20, 0x03	; 3
     33c:	60 e0       	ldi	r22, 0x00	; 0
     33e:	81 e0       	ldi	r24, 0x01	; 1
     340:	0e 94 9e 04 	call	0x93c	; 0x93c <xQueueGenericCreate>
     344:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <xSem1+0x1>
     348:	80 93 7f 00 	sts	0x007F, r24	; 0x80007f <xSem1>
     34c:	00 97       	sbiw	r24, 0x00	; 0
     34e:	39 f0       	breq	.+14     	; 0x35e <main+0x6c>
     350:	20 e0       	ldi	r18, 0x00	; 0
     352:	40 e0       	ldi	r20, 0x00	; 0
     354:	50 e0       	ldi	r21, 0x00	; 0
     356:	60 e0       	ldi	r22, 0x00	; 0
     358:	70 e0       	ldi	r23, 0x00	; 0
     35a:	0e 94 ee 04 	call	0x9dc	; 0x9dc <xQueueGenericSend>
	xQueue1=xQueueCreate(10, sizeof(uint8_t));
     35e:	40 e0       	ldi	r20, 0x00	; 0
     360:	61 e0       	ldi	r22, 0x01	; 1
     362:	8a e0       	ldi	r24, 0x0A	; 10
     364:	0e 94 9e 04 	call	0x93c	; 0x93c <xQueueGenericCreate>
     368:	90 93 7d 00 	sts	0x007D, r25	; 0x80007d <__data_end+0x1>
     36c:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__data_end>
	xTaskCreate( decement, ( signed char * ) "dec", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
     370:	a1 2c       	mov	r10, r1
     372:	b1 2c       	mov	r11, r1
     374:	c1 2c       	mov	r12, r1
     376:	d1 2c       	mov	r13, r1
     378:	e1 2c       	mov	r14, r1
     37a:	f1 2c       	mov	r15, r1
     37c:	00 e0       	ldi	r16, 0x00	; 0
     37e:	20 e0       	ldi	r18, 0x00	; 0
     380:	30 e0       	ldi	r19, 0x00	; 0
     382:	45 e5       	ldi	r20, 0x55	; 85
     384:	50 e0       	ldi	r21, 0x00	; 0
     386:	6a e6       	ldi	r22, 0x6A	; 106
     388:	70 e0       	ldi	r23, 0x00	; 0
     38a:	8d ea       	ldi	r24, 0xAD	; 173
     38c:	90 e0       	ldi	r25, 0x00	; 0
     38e:	0e 94 9f 06 	call	0xd3e	; 0xd3e <xTaskGenericCreate>
	xTaskCreate( increment, ( signed char * ) "inc", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
     392:	20 e0       	ldi	r18, 0x00	; 0
     394:	30 e0       	ldi	r19, 0x00	; 0
     396:	45 e5       	ldi	r20, 0x55	; 85
     398:	50 e0       	ldi	r21, 0x00	; 0
     39a:	6e e6       	ldi	r22, 0x6E	; 110
     39c:	70 e0       	ldi	r23, 0x00	; 0
     39e:	89 ee       	ldi	r24, 0xE9	; 233
     3a0:	90 e0       	ldi	r25, 0x00	; 0
     3a2:	0e 94 9f 06 	call	0xd3e	; 0xd3e <xTaskGenericCreate>
	xTaskCreate( LEDDisplay, ( signed char * ) "LEDD", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
     3a6:	20 e0       	ldi	r18, 0x00	; 0
     3a8:	30 e0       	ldi	r19, 0x00	; 0
     3aa:	45 e5       	ldi	r20, 0x55	; 85
     3ac:	50 e0       	ldi	r21, 0x00	; 0
     3ae:	62 e7       	ldi	r22, 0x72	; 114
     3b0:	70 e0       	ldi	r23, 0x00	; 0
     3b2:	85 e2       	ldi	r24, 0x25	; 37
     3b4:	91 e0       	ldi	r25, 0x01	; 1
     3b6:	0e 94 9f 06 	call	0xd3e	; 0xd3e <xTaskGenericCreate>
	
	
  #endif
  
  vTaskStartScheduler();
     3ba:	0e 94 8e 07 	call	0xf1c	; 0xf1c <vTaskStartScheduler>
  while(1)
  {}
     3be:	ff cf       	rjmp	.-2      	; 0x3be <main+0xcc>

000003c0 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     3c0:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     3c2:	03 96       	adiw	r24, 0x03	; 3
     3c4:	92 83       	std	Z+2, r25	; 0x02
     3c6:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     3c8:	2f ef       	ldi	r18, 0xFF	; 255
     3ca:	3f ef       	ldi	r19, 0xFF	; 255
     3cc:	34 83       	std	Z+4, r19	; 0x04
     3ce:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     3d0:	96 83       	std	Z+6, r25	; 0x06
     3d2:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     3d4:	90 87       	std	Z+8, r25	; 0x08
     3d6:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     3d8:	10 82       	st	Z, r1
     3da:	08 95       	ret

000003dc <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     3dc:	fc 01       	movw	r30, r24
     3de:	11 86       	std	Z+9, r1	; 0x09
     3e0:	10 86       	std	Z+8, r1	; 0x08
     3e2:	08 95       	ret

000003e4 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     3e4:	cf 93       	push	r28
     3e6:	df 93       	push	r29
     3e8:	fc 01       	movw	r30, r24
     3ea:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     3ec:	21 81       	ldd	r18, Z+1	; 0x01
     3ee:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
     3f0:	e9 01       	movw	r28, r18
     3f2:	8a 81       	ldd	r24, Y+2	; 0x02
     3f4:	9b 81       	ldd	r25, Y+3	; 0x03
     3f6:	13 96       	adiw	r26, 0x03	; 3
     3f8:	9c 93       	st	X, r25
     3fa:	8e 93       	st	-X, r24
     3fc:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
     3fe:	81 81       	ldd	r24, Z+1	; 0x01
     400:	92 81       	ldd	r25, Z+2	; 0x02
     402:	15 96       	adiw	r26, 0x05	; 5
     404:	9c 93       	st	X, r25
     406:	8e 93       	st	-X, r24
     408:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     40a:	8a 81       	ldd	r24, Y+2	; 0x02
     40c:	9b 81       	ldd	r25, Y+3	; 0x03
     40e:	ec 01       	movw	r28, r24
     410:	7d 83       	std	Y+5, r23	; 0x05
     412:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     414:	e9 01       	movw	r28, r18
     416:	7b 83       	std	Y+3, r23	; 0x03
     418:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     41a:	72 83       	std	Z+2, r23	; 0x02
     41c:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     41e:	19 96       	adiw	r26, 0x09	; 9
     420:	fc 93       	st	X, r31
     422:	ee 93       	st	-X, r30
     424:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
     426:	80 81       	ld	r24, Z
     428:	8f 5f       	subi	r24, 0xFF	; 255
     42a:	80 83       	st	Z, r24
}
     42c:	df 91       	pop	r29
     42e:	cf 91       	pop	r28
     430:	08 95       	ret

00000432 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     432:	cf 93       	push	r28
     434:	df 93       	push	r29
     436:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     438:	48 81       	ld	r20, Y
     43a:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     43c:	4f 3f       	cpi	r20, 0xFF	; 255
     43e:	2f ef       	ldi	r18, 0xFF	; 255
     440:	52 07       	cpc	r21, r18
     442:	31 f4       	brne	.+12     	; 0x450 <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     444:	dc 01       	movw	r26, r24
     446:	17 96       	adiw	r26, 0x07	; 7
     448:	ed 91       	ld	r30, X+
     44a:	fc 91       	ld	r31, X
     44c:	18 97       	sbiw	r26, 0x08	; 8
     44e:	17 c0       	rjmp	.+46     	; 0x47e <vListInsert+0x4c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     450:	fc 01       	movw	r30, r24
     452:	33 96       	adiw	r30, 0x03	; 3
     454:	dc 01       	movw	r26, r24
     456:	15 96       	adiw	r26, 0x05	; 5
     458:	2d 91       	ld	r18, X+
     45a:	3c 91       	ld	r19, X
     45c:	16 97       	sbiw	r26, 0x06	; 6
     45e:	d9 01       	movw	r26, r18
     460:	2d 91       	ld	r18, X+
     462:	3c 91       	ld	r19, X
     464:	42 17       	cp	r20, r18
     466:	53 07       	cpc	r21, r19
     468:	50 f0       	brcs	.+20     	; 0x47e <vListInsert+0x4c>
     46a:	02 80       	ldd	r0, Z+2	; 0x02
     46c:	f3 81       	ldd	r31, Z+3	; 0x03
     46e:	e0 2d       	mov	r30, r0
     470:	a2 81       	ldd	r26, Z+2	; 0x02
     472:	b3 81       	ldd	r27, Z+3	; 0x03
     474:	2d 91       	ld	r18, X+
     476:	3c 91       	ld	r19, X
     478:	42 17       	cp	r20, r18
     47a:	53 07       	cpc	r21, r19
     47c:	b0 f7       	brcc	.-20     	; 0x46a <vListInsert+0x38>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     47e:	a2 81       	ldd	r26, Z+2	; 0x02
     480:	b3 81       	ldd	r27, Z+3	; 0x03
     482:	bb 83       	std	Y+3, r27	; 0x03
     484:	aa 83       	std	Y+2, r26	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     486:	15 96       	adiw	r26, 0x05	; 5
     488:	dc 93       	st	X, r29
     48a:	ce 93       	st	-X, r28
     48c:	14 97       	sbiw	r26, 0x04	; 4
	pxNewListItem->pxPrevious = pxIterator;
     48e:	fd 83       	std	Y+5, r31	; 0x05
     490:	ec 83       	std	Y+4, r30	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     492:	d3 83       	std	Z+3, r29	; 0x03
     494:	c2 83       	std	Z+2, r28	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     496:	99 87       	std	Y+9, r25	; 0x09
     498:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     49a:	fc 01       	movw	r30, r24
     49c:	20 81       	ld	r18, Z
     49e:	2f 5f       	subi	r18, 0xFF	; 255
     4a0:	20 83       	st	Z, r18
}
     4a2:	df 91       	pop	r29
     4a4:	cf 91       	pop	r28
     4a6:	08 95       	ret

000004a8 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     4a8:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     4aa:	a2 81       	ldd	r26, Z+2	; 0x02
     4ac:	b3 81       	ldd	r27, Z+3	; 0x03
     4ae:	84 81       	ldd	r24, Z+4	; 0x04
     4b0:	95 81       	ldd	r25, Z+5	; 0x05
     4b2:	15 96       	adiw	r26, 0x05	; 5
     4b4:	9c 93       	st	X, r25
     4b6:	8e 93       	st	-X, r24
     4b8:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     4ba:	a4 81       	ldd	r26, Z+4	; 0x04
     4bc:	b5 81       	ldd	r27, Z+5	; 0x05
     4be:	82 81       	ldd	r24, Z+2	; 0x02
     4c0:	93 81       	ldd	r25, Z+3	; 0x03
     4c2:	13 96       	adiw	r26, 0x03	; 3
     4c4:	9c 93       	st	X, r25
     4c6:	8e 93       	st	-X, r24
     4c8:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     4ca:	a0 85       	ldd	r26, Z+8	; 0x08
     4cc:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     4ce:	11 96       	adiw	r26, 0x01	; 1
     4d0:	8d 91       	ld	r24, X+
     4d2:	9c 91       	ld	r25, X
     4d4:	12 97       	sbiw	r26, 0x02	; 2
     4d6:	8e 17       	cp	r24, r30
     4d8:	9f 07       	cpc	r25, r31
     4da:	31 f4       	brne	.+12     	; 0x4e8 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     4dc:	84 81       	ldd	r24, Z+4	; 0x04
     4de:	95 81       	ldd	r25, Z+5	; 0x05
     4e0:	12 96       	adiw	r26, 0x02	; 2
     4e2:	9c 93       	st	X, r25
     4e4:	8e 93       	st	-X, r24
     4e6:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
     4e8:	11 86       	std	Z+9, r1	; 0x09
     4ea:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     4ec:	8c 91       	ld	r24, X
     4ee:	81 50       	subi	r24, 0x01	; 1
     4f0:	8c 93       	st	X, r24
     4f2:	08 95       	ret

000004f4 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     4f4:	31 e1       	ldi	r19, 0x11	; 17
     4f6:	fc 01       	movw	r30, r24
     4f8:	30 83       	st	Z, r19
     4fa:	31 97       	sbiw	r30, 0x01	; 1
     4fc:	22 e2       	ldi	r18, 0x22	; 34
     4fe:	20 83       	st	Z, r18
     500:	31 97       	sbiw	r30, 0x01	; 1
     502:	a3 e3       	ldi	r26, 0x33	; 51
     504:	a0 83       	st	Z, r26
     506:	31 97       	sbiw	r30, 0x01	; 1
     508:	60 83       	st	Z, r22
     50a:	31 97       	sbiw	r30, 0x01	; 1
     50c:	70 83       	st	Z, r23
     50e:	31 97       	sbiw	r30, 0x01	; 1
     510:	10 82       	st	Z, r1
     512:	31 97       	sbiw	r30, 0x01	; 1
     514:	60 e8       	ldi	r22, 0x80	; 128
     516:	60 83       	st	Z, r22
     518:	31 97       	sbiw	r30, 0x01	; 1
     51a:	10 82       	st	Z, r1
     51c:	31 97       	sbiw	r30, 0x01	; 1
     51e:	62 e0       	ldi	r22, 0x02	; 2
     520:	60 83       	st	Z, r22
     522:	31 97       	sbiw	r30, 0x01	; 1
     524:	63 e0       	ldi	r22, 0x03	; 3
     526:	60 83       	st	Z, r22
     528:	31 97       	sbiw	r30, 0x01	; 1
     52a:	64 e0       	ldi	r22, 0x04	; 4
     52c:	60 83       	st	Z, r22
     52e:	31 97       	sbiw	r30, 0x01	; 1
     530:	65 e0       	ldi	r22, 0x05	; 5
     532:	60 83       	st	Z, r22
     534:	31 97       	sbiw	r30, 0x01	; 1
     536:	66 e0       	ldi	r22, 0x06	; 6
     538:	60 83       	st	Z, r22
     53a:	31 97       	sbiw	r30, 0x01	; 1
     53c:	67 e0       	ldi	r22, 0x07	; 7
     53e:	60 83       	st	Z, r22
     540:	31 97       	sbiw	r30, 0x01	; 1
     542:	68 e0       	ldi	r22, 0x08	; 8
     544:	60 83       	st	Z, r22
     546:	31 97       	sbiw	r30, 0x01	; 1
     548:	69 e0       	ldi	r22, 0x09	; 9
     54a:	60 83       	st	Z, r22
     54c:	31 97       	sbiw	r30, 0x01	; 1
     54e:	60 e1       	ldi	r22, 0x10	; 16
     550:	60 83       	st	Z, r22
     552:	31 97       	sbiw	r30, 0x01	; 1
     554:	30 83       	st	Z, r19
     556:	31 97       	sbiw	r30, 0x01	; 1
     558:	32 e1       	ldi	r19, 0x12	; 18
     55a:	30 83       	st	Z, r19
     55c:	31 97       	sbiw	r30, 0x01	; 1
     55e:	33 e1       	ldi	r19, 0x13	; 19
     560:	30 83       	st	Z, r19
     562:	31 97       	sbiw	r30, 0x01	; 1
     564:	34 e1       	ldi	r19, 0x14	; 20
     566:	30 83       	st	Z, r19
     568:	31 97       	sbiw	r30, 0x01	; 1
     56a:	35 e1       	ldi	r19, 0x15	; 21
     56c:	30 83       	st	Z, r19
     56e:	31 97       	sbiw	r30, 0x01	; 1
     570:	36 e1       	ldi	r19, 0x16	; 22
     572:	30 83       	st	Z, r19
     574:	31 97       	sbiw	r30, 0x01	; 1
     576:	37 e1       	ldi	r19, 0x17	; 23
     578:	30 83       	st	Z, r19
     57a:	31 97       	sbiw	r30, 0x01	; 1
     57c:	38 e1       	ldi	r19, 0x18	; 24
     57e:	30 83       	st	Z, r19
     580:	31 97       	sbiw	r30, 0x01	; 1
     582:	39 e1       	ldi	r19, 0x19	; 25
     584:	30 83       	st	Z, r19
     586:	31 97       	sbiw	r30, 0x01	; 1
     588:	30 e2       	ldi	r19, 0x20	; 32
     58a:	30 83       	st	Z, r19
     58c:	31 97       	sbiw	r30, 0x01	; 1
     58e:	31 e2       	ldi	r19, 0x21	; 33
     590:	30 83       	st	Z, r19
     592:	31 97       	sbiw	r30, 0x01	; 1
     594:	20 83       	st	Z, r18
     596:	31 97       	sbiw	r30, 0x01	; 1
     598:	23 e2       	ldi	r18, 0x23	; 35
     59a:	20 83       	st	Z, r18
     59c:	31 97       	sbiw	r30, 0x01	; 1
     59e:	40 83       	st	Z, r20
     5a0:	31 97       	sbiw	r30, 0x01	; 1
     5a2:	50 83       	st	Z, r21
     5a4:	31 97       	sbiw	r30, 0x01	; 1
     5a6:	26 e2       	ldi	r18, 0x26	; 38
     5a8:	20 83       	st	Z, r18
     5aa:	31 97       	sbiw	r30, 0x01	; 1
     5ac:	27 e2       	ldi	r18, 0x27	; 39
     5ae:	20 83       	st	Z, r18
     5b0:	31 97       	sbiw	r30, 0x01	; 1
     5b2:	28 e2       	ldi	r18, 0x28	; 40
     5b4:	20 83       	st	Z, r18
     5b6:	31 97       	sbiw	r30, 0x01	; 1
     5b8:	29 e2       	ldi	r18, 0x29	; 41
     5ba:	20 83       	st	Z, r18
     5bc:	31 97       	sbiw	r30, 0x01	; 1
     5be:	20 e3       	ldi	r18, 0x30	; 48
     5c0:	20 83       	st	Z, r18
     5c2:	31 97       	sbiw	r30, 0x01	; 1
     5c4:	21 e3       	ldi	r18, 0x31	; 49
     5c6:	20 83       	st	Z, r18
     5c8:	86 97       	sbiw	r24, 0x26	; 38
     5ca:	08 95       	ret

000005cc <xPortStartScheduler>:
     5cc:	1b bc       	out	0x2b, r1	; 43
     5ce:	88 e3       	ldi	r24, 0x38	; 56
     5d0:	8a bd       	out	0x2a, r24	; 42
     5d2:	8b e0       	ldi	r24, 0x0B	; 11
     5d4:	8e bd       	out	0x2e, r24	; 46
     5d6:	89 b7       	in	r24, 0x39	; 57
     5d8:	80 61       	ori	r24, 0x10	; 16
     5da:	89 bf       	out	0x39, r24	; 57
     5dc:	a0 91 92 06 	lds	r26, 0x0692	; 0x800692 <pxCurrentTCB>
     5e0:	b0 91 93 06 	lds	r27, 0x0693	; 0x800693 <pxCurrentTCB+0x1>
     5e4:	cd 91       	ld	r28, X+
     5e6:	cd bf       	out	0x3d, r28	; 61
     5e8:	dd 91       	ld	r29, X+
     5ea:	de bf       	out	0x3e, r29	; 62
     5ec:	ff 91       	pop	r31
     5ee:	ef 91       	pop	r30
     5f0:	df 91       	pop	r29
     5f2:	cf 91       	pop	r28
     5f4:	bf 91       	pop	r27
     5f6:	af 91       	pop	r26
     5f8:	9f 91       	pop	r25
     5fa:	8f 91       	pop	r24
     5fc:	7f 91       	pop	r23
     5fe:	6f 91       	pop	r22
     600:	5f 91       	pop	r21
     602:	4f 91       	pop	r20
     604:	3f 91       	pop	r19
     606:	2f 91       	pop	r18
     608:	1f 91       	pop	r17
     60a:	0f 91       	pop	r16
     60c:	ff 90       	pop	r15
     60e:	ef 90       	pop	r14
     610:	df 90       	pop	r13
     612:	cf 90       	pop	r12
     614:	bf 90       	pop	r11
     616:	af 90       	pop	r10
     618:	9f 90       	pop	r9
     61a:	8f 90       	pop	r8
     61c:	7f 90       	pop	r7
     61e:	6f 90       	pop	r6
     620:	5f 90       	pop	r5
     622:	4f 90       	pop	r4
     624:	3f 90       	pop	r3
     626:	2f 90       	pop	r2
     628:	1f 90       	pop	r1
     62a:	0f 90       	pop	r0
     62c:	0f be       	out	0x3f, r0	; 63
     62e:	0f 90       	pop	r0
     630:	08 95       	ret
     632:	81 e0       	ldi	r24, 0x01	; 1
     634:	08 95       	ret

00000636 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     636:	0f 92       	push	r0
     638:	0f b6       	in	r0, 0x3f	; 63
     63a:	f8 94       	cli
     63c:	0f 92       	push	r0
     63e:	1f 92       	push	r1
     640:	11 24       	eor	r1, r1
     642:	2f 92       	push	r2
     644:	3f 92       	push	r3
     646:	4f 92       	push	r4
     648:	5f 92       	push	r5
     64a:	6f 92       	push	r6
     64c:	7f 92       	push	r7
     64e:	8f 92       	push	r8
     650:	9f 92       	push	r9
     652:	af 92       	push	r10
     654:	bf 92       	push	r11
     656:	cf 92       	push	r12
     658:	df 92       	push	r13
     65a:	ef 92       	push	r14
     65c:	ff 92       	push	r15
     65e:	0f 93       	push	r16
     660:	1f 93       	push	r17
     662:	2f 93       	push	r18
     664:	3f 93       	push	r19
     666:	4f 93       	push	r20
     668:	5f 93       	push	r21
     66a:	6f 93       	push	r22
     66c:	7f 93       	push	r23
     66e:	8f 93       	push	r24
     670:	9f 93       	push	r25
     672:	af 93       	push	r26
     674:	bf 93       	push	r27
     676:	cf 93       	push	r28
     678:	df 93       	push	r29
     67a:	ef 93       	push	r30
     67c:	ff 93       	push	r31
     67e:	a0 91 92 06 	lds	r26, 0x0692	; 0x800692 <pxCurrentTCB>
     682:	b0 91 93 06 	lds	r27, 0x0693	; 0x800693 <pxCurrentTCB+0x1>
     686:	0d b6       	in	r0, 0x3d	; 61
     688:	0d 92       	st	X+, r0
     68a:	0e b6       	in	r0, 0x3e	; 62
     68c:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     68e:	0e 94 29 09 	call	0x1252	; 0x1252 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     692:	a0 91 92 06 	lds	r26, 0x0692	; 0x800692 <pxCurrentTCB>
     696:	b0 91 93 06 	lds	r27, 0x0693	; 0x800693 <pxCurrentTCB+0x1>
     69a:	cd 91       	ld	r28, X+
     69c:	cd bf       	out	0x3d, r28	; 61
     69e:	dd 91       	ld	r29, X+
     6a0:	de bf       	out	0x3e, r29	; 62
     6a2:	ff 91       	pop	r31
     6a4:	ef 91       	pop	r30
     6a6:	df 91       	pop	r29
     6a8:	cf 91       	pop	r28
     6aa:	bf 91       	pop	r27
     6ac:	af 91       	pop	r26
     6ae:	9f 91       	pop	r25
     6b0:	8f 91       	pop	r24
     6b2:	7f 91       	pop	r23
     6b4:	6f 91       	pop	r22
     6b6:	5f 91       	pop	r21
     6b8:	4f 91       	pop	r20
     6ba:	3f 91       	pop	r19
     6bc:	2f 91       	pop	r18
     6be:	1f 91       	pop	r17
     6c0:	0f 91       	pop	r16
     6c2:	ff 90       	pop	r15
     6c4:	ef 90       	pop	r14
     6c6:	df 90       	pop	r13
     6c8:	cf 90       	pop	r12
     6ca:	bf 90       	pop	r11
     6cc:	af 90       	pop	r10
     6ce:	9f 90       	pop	r9
     6d0:	8f 90       	pop	r8
     6d2:	7f 90       	pop	r7
     6d4:	6f 90       	pop	r6
     6d6:	5f 90       	pop	r5
     6d8:	4f 90       	pop	r4
     6da:	3f 90       	pop	r3
     6dc:	2f 90       	pop	r2
     6de:	1f 90       	pop	r1
     6e0:	0f 90       	pop	r0
     6e2:	0f be       	out	0x3f, r0	; 63
     6e4:	0f 90       	pop	r0

	asm volatile ( "ret" );
     6e6:	08 95       	ret

000006e8 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     6e8:	0f 92       	push	r0
     6ea:	0f b6       	in	r0, 0x3f	; 63
     6ec:	f8 94       	cli
     6ee:	0f 92       	push	r0
     6f0:	1f 92       	push	r1
     6f2:	11 24       	eor	r1, r1
     6f4:	2f 92       	push	r2
     6f6:	3f 92       	push	r3
     6f8:	4f 92       	push	r4
     6fa:	5f 92       	push	r5
     6fc:	6f 92       	push	r6
     6fe:	7f 92       	push	r7
     700:	8f 92       	push	r8
     702:	9f 92       	push	r9
     704:	af 92       	push	r10
     706:	bf 92       	push	r11
     708:	cf 92       	push	r12
     70a:	df 92       	push	r13
     70c:	ef 92       	push	r14
     70e:	ff 92       	push	r15
     710:	0f 93       	push	r16
     712:	1f 93       	push	r17
     714:	2f 93       	push	r18
     716:	3f 93       	push	r19
     718:	4f 93       	push	r20
     71a:	5f 93       	push	r21
     71c:	6f 93       	push	r22
     71e:	7f 93       	push	r23
     720:	8f 93       	push	r24
     722:	9f 93       	push	r25
     724:	af 93       	push	r26
     726:	bf 93       	push	r27
     728:	cf 93       	push	r28
     72a:	df 93       	push	r29
     72c:	ef 93       	push	r30
     72e:	ff 93       	push	r31
     730:	a0 91 92 06 	lds	r26, 0x0692	; 0x800692 <pxCurrentTCB>
     734:	b0 91 93 06 	lds	r27, 0x0693	; 0x800693 <pxCurrentTCB+0x1>
     738:	0d b6       	in	r0, 0x3d	; 61
     73a:	0d 92       	st	X+, r0
     73c:	0e b6       	in	r0, 0x3e	; 62
     73e:	0d 92       	st	X+, r0
	vTaskIncrementTick();
     740:	0e 94 bf 07 	call	0xf7e	; 0xf7e <vTaskIncrementTick>
	vTaskSwitchContext();
     744:	0e 94 29 09 	call	0x1252	; 0x1252 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     748:	a0 91 92 06 	lds	r26, 0x0692	; 0x800692 <pxCurrentTCB>
     74c:	b0 91 93 06 	lds	r27, 0x0693	; 0x800693 <pxCurrentTCB+0x1>
     750:	cd 91       	ld	r28, X+
     752:	cd bf       	out	0x3d, r28	; 61
     754:	dd 91       	ld	r29, X+
     756:	de bf       	out	0x3e, r29	; 62
     758:	ff 91       	pop	r31
     75a:	ef 91       	pop	r30
     75c:	df 91       	pop	r29
     75e:	cf 91       	pop	r28
     760:	bf 91       	pop	r27
     762:	af 91       	pop	r26
     764:	9f 91       	pop	r25
     766:	8f 91       	pop	r24
     768:	7f 91       	pop	r23
     76a:	6f 91       	pop	r22
     76c:	5f 91       	pop	r21
     76e:	4f 91       	pop	r20
     770:	3f 91       	pop	r19
     772:	2f 91       	pop	r18
     774:	1f 91       	pop	r17
     776:	0f 91       	pop	r16
     778:	ff 90       	pop	r15
     77a:	ef 90       	pop	r14
     77c:	df 90       	pop	r13
     77e:	cf 90       	pop	r12
     780:	bf 90       	pop	r11
     782:	af 90       	pop	r10
     784:	9f 90       	pop	r9
     786:	8f 90       	pop	r8
     788:	7f 90       	pop	r7
     78a:	6f 90       	pop	r6
     78c:	5f 90       	pop	r5
     78e:	4f 90       	pop	r4
     790:	3f 90       	pop	r3
     792:	2f 90       	pop	r2
     794:	1f 90       	pop	r1
     796:	0f 90       	pop	r0
     798:	0f be       	out	0x3f, r0	; 63
     79a:	0f 90       	pop	r0

	asm volatile ( "ret" );
     79c:	08 95       	ret

0000079e <__vector_7>:
//	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
//	void SIG_OUTPUT_COMPARE1A( void )
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     79e:	0e 94 74 03 	call	0x6e8	; 0x6e8 <vPortYieldFromTick>
		asm volatile ( "reti" );
     7a2:	18 95       	reti

000007a4 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     7a4:	cf 93       	push	r28
     7a6:	df 93       	push	r29
     7a8:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     7aa:	0e 94 b9 07 	call	0xf72	; 0xf72 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     7ae:	20 91 81 00 	lds	r18, 0x0081	; 0x800081 <xNextFreeByte>
     7b2:	30 91 82 00 	lds	r19, 0x0082	; 0x800082 <xNextFreeByte+0x1>
     7b6:	ce 01       	movw	r24, r28
     7b8:	82 0f       	add	r24, r18
     7ba:	93 1f       	adc	r25, r19
     7bc:	8c 3d       	cpi	r24, 0xDC	; 220
     7be:	45 e0       	ldi	r20, 0x05	; 5
     7c0:	94 07       	cpc	r25, r20
     7c2:	58 f4       	brcc	.+22     	; 0x7da <pvPortMalloc+0x36>
     7c4:	28 17       	cp	r18, r24
     7c6:	39 07       	cpc	r19, r25
     7c8:	58 f4       	brcc	.+22     	; 0x7e0 <pvPortMalloc+0x3c>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     7ca:	e9 01       	movw	r28, r18
     7cc:	cd 57       	subi	r28, 0x7D	; 125
     7ce:	df 4f       	sbci	r29, 0xFF	; 255
			xNextFreeByte += xWantedSize;			
     7d0:	90 93 82 00 	sts	0x0082, r25	; 0x800082 <xNextFreeByte+0x1>
     7d4:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <xNextFreeByte>
     7d8:	05 c0       	rjmp	.+10     	; 0x7e4 <pvPortMalloc+0x40>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
     7da:	c0 e0       	ldi	r28, 0x00	; 0
     7dc:	d0 e0       	ldi	r29, 0x00	; 0
     7de:	02 c0       	rjmp	.+4      	; 0x7e4 <pvPortMalloc+0x40>
     7e0:	c0 e0       	ldi	r28, 0x00	; 0
     7e2:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
     7e4:	0e 94 83 08 	call	0x1106	; 0x1106 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
     7e8:	ce 01       	movw	r24, r28
     7ea:	df 91       	pop	r29
     7ec:	cf 91       	pop	r28
     7ee:	08 95       	ret

000007f0 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     7f0:	08 95       	ret

000007f2 <prvCopyDataToQueue>:

#endif
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
     7f2:	cf 93       	push	r28
     7f4:	df 93       	push	r29
     7f6:	ec 01       	movw	r28, r24
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
     7f8:	8c 8d       	ldd	r24, Y+28	; 0x1c
     7fa:	88 23       	and	r24, r24
     7fc:	a9 f1       	breq	.+106    	; 0x868 <__stack+0x9>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
     7fe:	41 11       	cpse	r20, r1
     800:	17 c0       	rjmp	.+46     	; 0x830 <prvCopyDataToQueue+0x3e>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
     802:	48 2f       	mov	r20, r24
     804:	50 e0       	ldi	r21, 0x00	; 0
     806:	8c 81       	ldd	r24, Y+4	; 0x04
     808:	9d 81       	ldd	r25, Y+5	; 0x05
     80a:	0e 94 60 0a 	call	0x14c0	; 0x14c0 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     80e:	2c 8d       	ldd	r18, Y+28	; 0x1c
     810:	8c 81       	ldd	r24, Y+4	; 0x04
     812:	9d 81       	ldd	r25, Y+5	; 0x05
     814:	82 0f       	add	r24, r18
     816:	91 1d       	adc	r25, r1
     818:	9d 83       	std	Y+5, r25	; 0x05
     81a:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
     81c:	2a 81       	ldd	r18, Y+2	; 0x02
     81e:	3b 81       	ldd	r19, Y+3	; 0x03
     820:	82 17       	cp	r24, r18
     822:	93 07       	cpc	r25, r19
     824:	08 f1       	brcs	.+66     	; 0x868 <__stack+0x9>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     826:	88 81       	ld	r24, Y
     828:	99 81       	ldd	r25, Y+1	; 0x01
     82a:	9d 83       	std	Y+5, r25	; 0x05
     82c:	8c 83       	std	Y+4, r24	; 0x04
     82e:	1c c0       	rjmp	.+56     	; 0x868 <__stack+0x9>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
     830:	48 2f       	mov	r20, r24
     832:	50 e0       	ldi	r21, 0x00	; 0
     834:	8e 81       	ldd	r24, Y+6	; 0x06
     836:	9f 81       	ldd	r25, Y+7	; 0x07
     838:	0e 94 60 0a 	call	0x14c0	; 0x14c0 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
     83c:	8c 8d       	ldd	r24, Y+28	; 0x1c
     83e:	90 e0       	ldi	r25, 0x00	; 0
     840:	91 95       	neg	r25
     842:	81 95       	neg	r24
     844:	91 09       	sbc	r25, r1
     846:	2e 81       	ldd	r18, Y+6	; 0x06
     848:	3f 81       	ldd	r19, Y+7	; 0x07
     84a:	28 0f       	add	r18, r24
     84c:	39 1f       	adc	r19, r25
     84e:	3f 83       	std	Y+7, r19	; 0x07
     850:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
     852:	48 81       	ld	r20, Y
     854:	59 81       	ldd	r21, Y+1	; 0x01
     856:	24 17       	cp	r18, r20
     858:	35 07       	cpc	r19, r21
     85a:	30 f4       	brcc	.+12     	; 0x868 <__stack+0x9>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     85c:	2a 81       	ldd	r18, Y+2	; 0x02
     85e:	3b 81       	ldd	r19, Y+3	; 0x03
     860:	82 0f       	add	r24, r18
     862:	93 1f       	adc	r25, r19
     864:	9f 83       	std	Y+7, r25	; 0x07
     866:	8e 83       	std	Y+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
     868:	8a 8d       	ldd	r24, Y+26	; 0x1a
     86a:	8f 5f       	subi	r24, 0xFF	; 255
     86c:	8a 8f       	std	Y+26, r24	; 0x1a
}
     86e:	df 91       	pop	r29
     870:	cf 91       	pop	r28
     872:	08 95       	ret

00000874 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
     874:	fc 01       	movw	r30, r24
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
     876:	80 81       	ld	r24, Z
     878:	91 81       	ldd	r25, Z+1	; 0x01
     87a:	00 97       	sbiw	r24, 0x00	; 0
     87c:	a1 f0       	breq	.+40     	; 0x8a6 <prvCopyDataFromQueue+0x32>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
     87e:	44 8d       	ldd	r20, Z+28	; 0x1c
     880:	50 e0       	ldi	r21, 0x00	; 0
     882:	26 81       	ldd	r18, Z+6	; 0x06
     884:	37 81       	ldd	r19, Z+7	; 0x07
     886:	24 0f       	add	r18, r20
     888:	35 1f       	adc	r19, r21
     88a:	37 83       	std	Z+7, r19	; 0x07
     88c:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
     88e:	a2 81       	ldd	r26, Z+2	; 0x02
     890:	b3 81       	ldd	r27, Z+3	; 0x03
     892:	2a 17       	cp	r18, r26
     894:	3b 07       	cpc	r19, r27
     896:	10 f0       	brcs	.+4      	; 0x89c <prvCopyDataFromQueue+0x28>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
     898:	97 83       	std	Z+7, r25	; 0x07
     89a:	86 83       	std	Z+6, r24	; 0x06
     89c:	cb 01       	movw	r24, r22
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
     89e:	66 81       	ldd	r22, Z+6	; 0x06
     8a0:	77 81       	ldd	r23, Z+7	; 0x07
     8a2:	0e 94 60 0a 	call	0x14c0	; 0x14c0 <memcpy>
     8a6:	08 95       	ret

000008a8 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
     8a8:	0f 93       	push	r16
     8aa:	1f 93       	push	r17
     8ac:	cf 93       	push	r28
     8ae:	df 93       	push	r29
     8b0:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
     8b2:	0f b6       	in	r0, 0x3f	; 63
     8b4:	f8 94       	cli
     8b6:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     8b8:	8e 8d       	ldd	r24, Y+30	; 0x1e
     8ba:	18 16       	cp	r1, r24
     8bc:	b4 f4       	brge	.+44     	; 0x8ea <prvUnlockQueue+0x42>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     8be:	89 89       	ldd	r24, Y+17	; 0x11
     8c0:	81 11       	cpse	r24, r1
     8c2:	05 c0       	rjmp	.+10     	; 0x8ce <prvUnlockQueue+0x26>
     8c4:	12 c0       	rjmp	.+36     	; 0x8ea <prvUnlockQueue+0x42>
     8c6:	99 89       	ldd	r25, Y+17	; 0x11
     8c8:	91 11       	cpse	r25, r1
     8ca:	04 c0       	rjmp	.+8      	; 0x8d4 <prvUnlockQueue+0x2c>
     8cc:	0e c0       	rjmp	.+28     	; 0x8ea <prvUnlockQueue+0x42>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     8ce:	8e 01       	movw	r16, r28
     8d0:	0f 5e       	subi	r16, 0xEF	; 239
     8d2:	1f 4f       	sbci	r17, 0xFF	; 255
     8d4:	c8 01       	movw	r24, r16
     8d6:	0e 94 b3 09 	call	0x1366	; 0x1366 <xTaskRemoveFromEventList>
     8da:	81 11       	cpse	r24, r1
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
     8dc:	0e 94 3a 0a 	call	0x1474	; 0x1474 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
     8e0:	9e 8d       	ldd	r25, Y+30	; 0x1e
     8e2:	91 50       	subi	r25, 0x01	; 1
     8e4:	9e 8f       	std	Y+30, r25	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     8e6:	19 16       	cp	r1, r25
     8e8:	74 f3       	brlt	.-36     	; 0x8c6 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
     8ea:	8f ef       	ldi	r24, 0xFF	; 255
     8ec:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
     8ee:	0f 90       	pop	r0
     8f0:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
     8f2:	0f b6       	in	r0, 0x3f	; 63
     8f4:	f8 94       	cli
     8f6:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     8f8:	8d 8d       	ldd	r24, Y+29	; 0x1d
     8fa:	18 16       	cp	r1, r24
     8fc:	b4 f4       	brge	.+44     	; 0x92a <prvUnlockQueue+0x82>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     8fe:	88 85       	ldd	r24, Y+8	; 0x08
     900:	81 11       	cpse	r24, r1
     902:	05 c0       	rjmp	.+10     	; 0x90e <prvUnlockQueue+0x66>
     904:	12 c0       	rjmp	.+36     	; 0x92a <prvUnlockQueue+0x82>
     906:	98 85       	ldd	r25, Y+8	; 0x08
     908:	91 11       	cpse	r25, r1
     90a:	04 c0       	rjmp	.+8      	; 0x914 <prvUnlockQueue+0x6c>
     90c:	0e c0       	rjmp	.+28     	; 0x92a <prvUnlockQueue+0x82>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     90e:	8e 01       	movw	r16, r28
     910:	08 5f       	subi	r16, 0xF8	; 248
     912:	1f 4f       	sbci	r17, 0xFF	; 255
     914:	c8 01       	movw	r24, r16
     916:	0e 94 b3 09 	call	0x1366	; 0x1366 <xTaskRemoveFromEventList>
     91a:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
     91c:	0e 94 3a 0a 	call	0x1474	; 0x1474 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
     920:	9d 8d       	ldd	r25, Y+29	; 0x1d
     922:	91 50       	subi	r25, 0x01	; 1
     924:	9d 8f       	std	Y+29, r25	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     926:	19 16       	cp	r1, r25
     928:	74 f3       	brlt	.-36     	; 0x906 <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
     92a:	8f ef       	ldi	r24, 0xFF	; 255
     92c:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
     92e:	0f 90       	pop	r0
     930:	0f be       	out	0x3f, r0	; 63
}
     932:	df 91       	pop	r29
     934:	cf 91       	pop	r28
     936:	1f 91       	pop	r17
     938:	0f 91       	pop	r16
     93a:	08 95       	ret

0000093c <xQueueGenericCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
     93c:	cf 92       	push	r12
     93e:	df 92       	push	r13
     940:	ef 92       	push	r14
     942:	ff 92       	push	r15
     944:	0f 93       	push	r16
     946:	1f 93       	push	r17
     948:	cf 93       	push	r28
     94a:	df 93       	push	r29
	/* Remove compiler warnings about unused parameters should 
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
     94c:	88 23       	and	r24, r24
     94e:	d1 f1       	breq	.+116    	; 0x9c4 <xQueueGenericCreate+0x88>
     950:	e6 2e       	mov	r14, r22
     952:	f8 2e       	mov	r15, r24
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
     954:	8f e1       	ldi	r24, 0x1F	; 31
     956:	90 e0       	ldi	r25, 0x00	; 0
     958:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <pvPortMalloc>
     95c:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
     95e:	89 2b       	or	r24, r25
     960:	99 f1       	breq	.+102    	; 0x9c8 <xQueueGenericCreate+0x8c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
     962:	ce 2c       	mov	r12, r14
     964:	d1 2c       	mov	r13, r1
     966:	fc 9c       	mul	r15, r12
     968:	80 01       	movw	r16, r0
     96a:	fd 9c       	mul	r15, r13
     96c:	10 0d       	add	r17, r0
     96e:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
     970:	c8 01       	movw	r24, r16
     972:	01 96       	adiw	r24, 0x01	; 1
     974:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <pvPortMalloc>
     978:	99 83       	std	Y+1, r25	; 0x01
     97a:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
     97c:	00 97       	sbiw	r24, 0x00	; 0
     97e:	e1 f0       	breq	.+56     	; 0x9b8 <xQueueGenericCreate+0x7c>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
     980:	9c 01       	movw	r18, r24
     982:	20 0f       	add	r18, r16
     984:	31 1f       	adc	r19, r17
     986:	3b 83       	std	Y+3, r19	; 0x03
     988:	2a 83       	std	Y+2, r18	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
     98a:	1a 8e       	std	Y+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
     98c:	9d 83       	std	Y+5, r25	; 0x05
     98e:	8c 83       	std	Y+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
     990:	0c 19       	sub	r16, r12
     992:	1d 09       	sbc	r17, r13
     994:	08 0f       	add	r16, r24
     996:	19 1f       	adc	r17, r25
     998:	1f 83       	std	Y+7, r17	; 0x07
     99a:	0e 83       	std	Y+6, r16	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
     99c:	fb 8e       	std	Y+27, r15	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
     99e:	ec 8e       	std	Y+28, r14	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
     9a0:	8f ef       	ldi	r24, 0xFF	; 255
     9a2:	8d 8f       	std	Y+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
     9a4:	8e 8f       	std	Y+30, r24	; 0x1e
					pxNewQueue->ucQueueType = ucQueueType;
				}
				#endif /* configUSE_TRACE_FACILITY */

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
     9a6:	ce 01       	movw	r24, r28
     9a8:	08 96       	adiw	r24, 0x08	; 8
     9aa:	0e 94 e0 01 	call	0x3c0	; 0x3c0 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
     9ae:	ce 01       	movw	r24, r28
     9b0:	41 96       	adiw	r24, 0x11	; 17
     9b2:	0e 94 e0 01 	call	0x3c0	; 0x3c0 <vListInitialise>
     9b6:	08 c0       	rjmp	.+16     	; 0x9c8 <xQueueGenericCreate+0x8c>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
     9b8:	ce 01       	movw	r24, r28
     9ba:	0e 94 f8 03 	call	0x7f0	; 0x7f0 <vPortFree>

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
     9be:	c0 e0       	ldi	r28, 0x00	; 0
     9c0:	d0 e0       	ldi	r29, 0x00	; 0
     9c2:	02 c0       	rjmp	.+4      	; 0x9c8 <xQueueGenericCreate+0x8c>
     9c4:	c0 e0       	ldi	r28, 0x00	; 0
     9c6:	d0 e0       	ldi	r29, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
     9c8:	ce 01       	movw	r24, r28
     9ca:	df 91       	pop	r29
     9cc:	cf 91       	pop	r28
     9ce:	1f 91       	pop	r17
     9d0:	0f 91       	pop	r16
     9d2:	ff 90       	pop	r15
     9d4:	ef 90       	pop	r14
     9d6:	df 90       	pop	r13
     9d8:	cf 90       	pop	r12
     9da:	08 95       	ret

000009dc <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
     9dc:	9f 92       	push	r9
     9de:	af 92       	push	r10
     9e0:	bf 92       	push	r11
     9e2:	cf 92       	push	r12
     9e4:	df 92       	push	r13
     9e6:	ef 92       	push	r14
     9e8:	ff 92       	push	r15
     9ea:	0f 93       	push	r16
     9ec:	1f 93       	push	r17
     9ee:	cf 93       	push	r28
     9f0:	df 93       	push	r29
     9f2:	00 d0       	rcall	.+0      	; 0x9f4 <xQueueGenericSend+0x18>
     9f4:	00 d0       	rcall	.+0      	; 0x9f6 <xQueueGenericSend+0x1a>
     9f6:	1f 92       	push	r1
     9f8:	cd b7       	in	r28, 0x3d	; 61
     9fa:	de b7       	in	r29, 0x3e	; 62
     9fc:	8c 01       	movw	r16, r24
     9fe:	6b 01       	movw	r12, r22
     a00:	5d 83       	std	Y+5, r21	; 0x05
     a02:	4c 83       	std	Y+4, r20	; 0x04
     a04:	92 2e       	mov	r9, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
     a06:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     a08:	aa 24       	eor	r10, r10
     a0a:	a3 94       	inc	r10
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     a0c:	7c 01       	movw	r14, r24
     a0e:	88 e0       	ldi	r24, 0x08	; 8
     a10:	e8 0e       	add	r14, r24
     a12:	f1 1c       	adc	r15, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
     a14:	0f b6       	in	r0, 0x3f	; 63
     a16:	f8 94       	cli
     a18:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
     a1a:	f8 01       	movw	r30, r16
     a1c:	32 8d       	ldd	r19, Z+26	; 0x1a
     a1e:	93 8d       	ldd	r25, Z+27	; 0x1b
     a20:	39 17       	cp	r19, r25
     a22:	a8 f4       	brcc	.+42     	; 0xa4e <xQueueGenericSend+0x72>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     a24:	49 2d       	mov	r20, r9
     a26:	b6 01       	movw	r22, r12
     a28:	c8 01       	movw	r24, r16
     a2a:	0e 94 f9 03 	call	0x7f2	; 0x7f2 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     a2e:	f8 01       	movw	r30, r16
     a30:	81 89       	ldd	r24, Z+17	; 0x11
     a32:	88 23       	and	r24, r24
     a34:	41 f0       	breq	.+16     	; 0xa46 <xQueueGenericSend+0x6a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
     a36:	c8 01       	movw	r24, r16
     a38:	41 96       	adiw	r24, 0x11	; 17
     a3a:	0e 94 b3 09 	call	0x1366	; 0x1366 <xTaskRemoveFromEventList>
     a3e:	81 30       	cpi	r24, 0x01	; 1
     a40:	11 f4       	brne	.+4      	; 0xa46 <xQueueGenericSend+0x6a>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
     a42:	0e 94 1b 03 	call	0x636	; 0x636 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
     a46:	0f 90       	pop	r0
     a48:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
     a4a:	81 e0       	ldi	r24, 0x01	; 1
     a4c:	50 c0       	rjmp	.+160    	; 0xaee <xQueueGenericSend+0x112>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
     a4e:	ec 81       	ldd	r30, Y+4	; 0x04
     a50:	fd 81       	ldd	r31, Y+5	; 0x05
     a52:	ef 2b       	or	r30, r31
     a54:	21 f4       	brne	.+8      	; 0xa5e <xQueueGenericSend+0x82>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     a56:	0f 90       	pop	r0
     a58:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
     a5a:	80 e0       	ldi	r24, 0x00	; 0
     a5c:	48 c0       	rjmp	.+144    	; 0xaee <xQueueGenericSend+0x112>
				}
				else if( xEntryTimeSet == pdFALSE )
     a5e:	b1 10       	cpse	r11, r1
     a60:	05 c0       	rjmp	.+10     	; 0xa6c <xQueueGenericSend+0x90>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     a62:	ce 01       	movw	r24, r28
     a64:	01 96       	adiw	r24, 0x01	; 1
     a66:	0e 94 f8 09 	call	0x13f0	; 0x13f0 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     a6a:	ba 2c       	mov	r11, r10
				}
			}
		}
		taskEXIT_CRITICAL();
     a6c:	0f 90       	pop	r0
     a6e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     a70:	0e 94 b9 07 	call	0xf72	; 0xf72 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     a74:	0f b6       	in	r0, 0x3f	; 63
     a76:	f8 94       	cli
     a78:	0f 92       	push	r0
     a7a:	f8 01       	movw	r30, r16
     a7c:	85 8d       	ldd	r24, Z+29	; 0x1d
     a7e:	8f 3f       	cpi	r24, 0xFF	; 255
     a80:	09 f4       	brne	.+2      	; 0xa84 <xQueueGenericSend+0xa8>
     a82:	15 8e       	std	Z+29, r1	; 0x1d
     a84:	f8 01       	movw	r30, r16
     a86:	86 8d       	ldd	r24, Z+30	; 0x1e
     a88:	8f 3f       	cpi	r24, 0xFF	; 255
     a8a:	09 f4       	brne	.+2      	; 0xa8e <xQueueGenericSend+0xb2>
     a8c:	16 8e       	std	Z+30, r1	; 0x1e
     a8e:	0f 90       	pop	r0
     a90:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     a92:	be 01       	movw	r22, r28
     a94:	6c 5f       	subi	r22, 0xFC	; 252
     a96:	7f 4f       	sbci	r23, 0xFF	; 255
     a98:	ce 01       	movw	r24, r28
     a9a:	01 96       	adiw	r24, 0x01	; 1
     a9c:	0e 94 03 0a 	call	0x1406	; 0x1406 <xTaskCheckForTimeOut>
     aa0:	81 11       	cpse	r24, r1
     aa2:	1f c0       	rjmp	.+62     	; 0xae2 <xQueueGenericSend+0x106>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
     aa4:	0f b6       	in	r0, 0x3f	; 63
     aa6:	f8 94       	cli
     aa8:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
     aaa:	f8 01       	movw	r30, r16
     aac:	92 8d       	ldd	r25, Z+26	; 0x1a
	taskEXIT_CRITICAL();
     aae:	0f 90       	pop	r0
     ab0:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
     ab2:	83 8d       	ldd	r24, Z+27	; 0x1b
     ab4:	98 13       	cpse	r25, r24
     ab6:	0f c0       	rjmp	.+30     	; 0xad6 <xQueueGenericSend+0xfa>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     ab8:	6c 81       	ldd	r22, Y+4	; 0x04
     aba:	7d 81       	ldd	r23, Y+5	; 0x05
     abc:	c7 01       	movw	r24, r14
     abe:	0e 94 95 09 	call	0x132a	; 0x132a <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
     ac2:	c8 01       	movw	r24, r16
     ac4:	0e 94 54 04 	call	0x8a8	; 0x8a8 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
     ac8:	0e 94 83 08 	call	0x1106	; 0x1106 <xTaskResumeAll>
     acc:	81 11       	cpse	r24, r1
     ace:	a2 cf       	rjmp	.-188    	; 0xa14 <xQueueGenericSend+0x38>
				{
					portYIELD_WITHIN_API();
     ad0:	0e 94 1b 03 	call	0x636	; 0x636 <vPortYield>
     ad4:	9f cf       	rjmp	.-194    	; 0xa14 <xQueueGenericSend+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     ad6:	c8 01       	movw	r24, r16
     ad8:	0e 94 54 04 	call	0x8a8	; 0x8a8 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     adc:	0e 94 83 08 	call	0x1106	; 0x1106 <xTaskResumeAll>
     ae0:	99 cf       	rjmp	.-206    	; 0xa14 <xQueueGenericSend+0x38>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
     ae2:	c8 01       	movw	r24, r16
     ae4:	0e 94 54 04 	call	0x8a8	; 0x8a8 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     ae8:	0e 94 83 08 	call	0x1106	; 0x1106 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
     aec:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     aee:	0f 90       	pop	r0
     af0:	0f 90       	pop	r0
     af2:	0f 90       	pop	r0
     af4:	0f 90       	pop	r0
     af6:	0f 90       	pop	r0
     af8:	df 91       	pop	r29
     afa:	cf 91       	pop	r28
     afc:	1f 91       	pop	r17
     afe:	0f 91       	pop	r16
     b00:	ff 90       	pop	r15
     b02:	ef 90       	pop	r14
     b04:	df 90       	pop	r13
     b06:	cf 90       	pop	r12
     b08:	bf 90       	pop	r11
     b0a:	af 90       	pop	r10
     b0c:	9f 90       	pop	r9
     b0e:	08 95       	ret

00000b10 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
     b10:	0f 93       	push	r16
     b12:	1f 93       	push	r17
     b14:	cf 93       	push	r28
     b16:	df 93       	push	r29
     b18:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
     b1a:	fc 01       	movw	r30, r24
     b1c:	52 8d       	ldd	r21, Z+26	; 0x1a
     b1e:	33 8d       	ldd	r19, Z+27	; 0x1b
     b20:	53 17       	cp	r21, r19
     b22:	c0 f4       	brcc	.+48     	; 0xb54 <xQueueGenericSendFromISR+0x44>
     b24:	42 2f       	mov	r20, r18
     b26:	ec 01       	movw	r28, r24
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     b28:	0e 94 f9 03 	call	0x7f2	; 0x7f2 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
     b2c:	8e 8d       	ldd	r24, Y+30	; 0x1e
     b2e:	8f 3f       	cpi	r24, 0xFF	; 255
     b30:	69 f4       	brne	.+26     	; 0xb4c <xQueueGenericSendFromISR+0x3c>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     b32:	89 89       	ldd	r24, Y+17	; 0x11
     b34:	88 23       	and	r24, r24
     b36:	81 f0       	breq	.+32     	; 0xb58 <xQueueGenericSendFromISR+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     b38:	ce 01       	movw	r24, r28
     b3a:	41 96       	adiw	r24, 0x11	; 17
     b3c:	0e 94 b3 09 	call	0x1366	; 0x1366 <xTaskRemoveFromEventList>
     b40:	88 23       	and	r24, r24
     b42:	61 f0       	breq	.+24     	; 0xb5c <xQueueGenericSendFromISR+0x4c>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
     b44:	81 e0       	ldi	r24, 0x01	; 1
     b46:	f8 01       	movw	r30, r16
     b48:	80 83       	st	Z, r24
     b4a:	09 c0       	rjmp	.+18     	; 0xb5e <xQueueGenericSendFromISR+0x4e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
     b4c:	8f 5f       	subi	r24, 0xFF	; 255
     b4e:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
     b50:	81 e0       	ldi	r24, 0x01	; 1
     b52:	05 c0       	rjmp	.+10     	; 0xb5e <xQueueGenericSendFromISR+0x4e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
     b54:	80 e0       	ldi	r24, 0x00	; 0
     b56:	03 c0       	rjmp	.+6      	; 0xb5e <xQueueGenericSendFromISR+0x4e>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
     b58:	81 e0       	ldi	r24, 0x01	; 1
     b5a:	01 c0       	rjmp	.+2      	; 0xb5e <xQueueGenericSendFromISR+0x4e>
     b5c:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     b5e:	df 91       	pop	r29
     b60:	cf 91       	pop	r28
     b62:	1f 91       	pop	r17
     b64:	0f 91       	pop	r16
     b66:	08 95       	ret

00000b68 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
     b68:	9f 92       	push	r9
     b6a:	af 92       	push	r10
     b6c:	bf 92       	push	r11
     b6e:	cf 92       	push	r12
     b70:	df 92       	push	r13
     b72:	ef 92       	push	r14
     b74:	ff 92       	push	r15
     b76:	0f 93       	push	r16
     b78:	1f 93       	push	r17
     b7a:	cf 93       	push	r28
     b7c:	df 93       	push	r29
     b7e:	00 d0       	rcall	.+0      	; 0xb80 <xQueueGenericReceive+0x18>
     b80:	00 d0       	rcall	.+0      	; 0xb82 <xQueueGenericReceive+0x1a>
     b82:	1f 92       	push	r1
     b84:	cd b7       	in	r28, 0x3d	; 61
     b86:	de b7       	in	r29, 0x3e	; 62
     b88:	8c 01       	movw	r16, r24
     b8a:	6b 01       	movw	r12, r22
     b8c:	5d 83       	std	Y+5, r21	; 0x05
     b8e:	4c 83       	std	Y+4, r20	; 0x04
     b90:	92 2e       	mov	r9, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
     b92:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     b94:	aa 24       	eor	r10, r10
     b96:	a3 94       	inc	r10
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     b98:	7c 01       	movw	r14, r24
     b9a:	81 e1       	ldi	r24, 0x11	; 17
     b9c:	e8 0e       	add	r14, r24
     b9e:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     ba0:	0f b6       	in	r0, 0x3f	; 63
     ba2:	f8 94       	cli
     ba4:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
     ba6:	f8 01       	movw	r30, r16
     ba8:	92 8d       	ldd	r25, Z+26	; 0x1a
     baa:	99 23       	and	r25, r25
     bac:	49 f1       	breq	.+82     	; 0xc00 <xQueueGenericReceive+0x98>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
     bae:	e6 80       	ldd	r14, Z+6	; 0x06
     bb0:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     bb2:	b6 01       	movw	r22, r12
     bb4:	c8 01       	movw	r24, r16
     bb6:	0e 94 3a 04 	call	0x874	; 0x874 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
     bba:	91 10       	cpse	r9, r1
     bbc:	10 c0       	rjmp	.+32     	; 0xbde <xQueueGenericReceive+0x76>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
     bbe:	f8 01       	movw	r30, r16
     bc0:	82 8d       	ldd	r24, Z+26	; 0x1a
     bc2:	81 50       	subi	r24, 0x01	; 1
     bc4:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     bc6:	80 85       	ldd	r24, Z+8	; 0x08
     bc8:	88 23       	and	r24, r24
     bca:	b1 f0       	breq	.+44     	; 0xbf8 <xQueueGenericReceive+0x90>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     bcc:	c8 01       	movw	r24, r16
     bce:	08 96       	adiw	r24, 0x08	; 8
     bd0:	0e 94 b3 09 	call	0x1366	; 0x1366 <xTaskRemoveFromEventList>
     bd4:	81 30       	cpi	r24, 0x01	; 1
     bd6:	81 f4       	brne	.+32     	; 0xbf8 <xQueueGenericReceive+0x90>
						{
							portYIELD_WITHIN_API();
     bd8:	0e 94 1b 03 	call	0x636	; 0x636 <vPortYield>
     bdc:	0d c0       	rjmp	.+26     	; 0xbf8 <xQueueGenericReceive+0x90>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
     bde:	f8 01       	movw	r30, r16
     be0:	f7 82       	std	Z+7, r15	; 0x07
     be2:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     be4:	81 89       	ldd	r24, Z+17	; 0x11
     be6:	88 23       	and	r24, r24
     be8:	39 f0       	breq	.+14     	; 0xbf8 <xQueueGenericReceive+0x90>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     bea:	c8 01       	movw	r24, r16
     bec:	41 96       	adiw	r24, 0x11	; 17
     bee:	0e 94 b3 09 	call	0x1366	; 0x1366 <xTaskRemoveFromEventList>
     bf2:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
     bf4:	0e 94 1b 03 	call	0x636	; 0x636 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
     bf8:	0f 90       	pop	r0
     bfa:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     bfc:	81 e0       	ldi	r24, 0x01	; 1
     bfe:	4f c0       	rjmp	.+158    	; 0xc9e <xQueueGenericReceive+0x136>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
     c00:	4c 81       	ldd	r20, Y+4	; 0x04
     c02:	5d 81       	ldd	r21, Y+5	; 0x05
     c04:	45 2b       	or	r20, r21
     c06:	21 f4       	brne	.+8      	; 0xc10 <xQueueGenericReceive+0xa8>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     c08:	0f 90       	pop	r0
     c0a:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     c0c:	80 e0       	ldi	r24, 0x00	; 0
     c0e:	47 c0       	rjmp	.+142    	; 0xc9e <xQueueGenericReceive+0x136>
				}
				else if( xEntryTimeSet == pdFALSE )
     c10:	b1 10       	cpse	r11, r1
     c12:	05 c0       	rjmp	.+10     	; 0xc1e <xQueueGenericReceive+0xb6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     c14:	ce 01       	movw	r24, r28
     c16:	01 96       	adiw	r24, 0x01	; 1
     c18:	0e 94 f8 09 	call	0x13f0	; 0x13f0 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     c1c:	ba 2c       	mov	r11, r10
				}
			}
		}
		taskEXIT_CRITICAL();
     c1e:	0f 90       	pop	r0
     c20:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     c22:	0e 94 b9 07 	call	0xf72	; 0xf72 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     c26:	0f b6       	in	r0, 0x3f	; 63
     c28:	f8 94       	cli
     c2a:	0f 92       	push	r0
     c2c:	f8 01       	movw	r30, r16
     c2e:	85 8d       	ldd	r24, Z+29	; 0x1d
     c30:	8f 3f       	cpi	r24, 0xFF	; 255
     c32:	09 f4       	brne	.+2      	; 0xc36 <xQueueGenericReceive+0xce>
     c34:	15 8e       	std	Z+29, r1	; 0x1d
     c36:	f8 01       	movw	r30, r16
     c38:	96 8d       	ldd	r25, Z+30	; 0x1e
     c3a:	9f 3f       	cpi	r25, 0xFF	; 255
     c3c:	09 f4       	brne	.+2      	; 0xc40 <xQueueGenericReceive+0xd8>
     c3e:	16 8e       	std	Z+30, r1	; 0x1e
     c40:	0f 90       	pop	r0
     c42:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     c44:	be 01       	movw	r22, r28
     c46:	6c 5f       	subi	r22, 0xFC	; 252
     c48:	7f 4f       	sbci	r23, 0xFF	; 255
     c4a:	ce 01       	movw	r24, r28
     c4c:	01 96       	adiw	r24, 0x01	; 1
     c4e:	0e 94 03 0a 	call	0x1406	; 0x1406 <xTaskCheckForTimeOut>
     c52:	81 11       	cpse	r24, r1
     c54:	1e c0       	rjmp	.+60     	; 0xc92 <xQueueGenericReceive+0x12a>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
     c56:	0f b6       	in	r0, 0x3f	; 63
     c58:	f8 94       	cli
     c5a:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
     c5c:	f8 01       	movw	r30, r16
     c5e:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
     c60:	0f 90       	pop	r0
     c62:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     c64:	81 11       	cpse	r24, r1
     c66:	0f c0       	rjmp	.+30     	; 0xc86 <xQueueGenericReceive+0x11e>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     c68:	6c 81       	ldd	r22, Y+4	; 0x04
     c6a:	7d 81       	ldd	r23, Y+5	; 0x05
     c6c:	c7 01       	movw	r24, r14
     c6e:	0e 94 95 09 	call	0x132a	; 0x132a <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
     c72:	c8 01       	movw	r24, r16
     c74:	0e 94 54 04 	call	0x8a8	; 0x8a8 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
     c78:	0e 94 83 08 	call	0x1106	; 0x1106 <xTaskResumeAll>
     c7c:	81 11       	cpse	r24, r1
     c7e:	90 cf       	rjmp	.-224    	; 0xba0 <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
     c80:	0e 94 1b 03 	call	0x636	; 0x636 <vPortYield>
     c84:	8d cf       	rjmp	.-230    	; 0xba0 <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     c86:	c8 01       	movw	r24, r16
     c88:	0e 94 54 04 	call	0x8a8	; 0x8a8 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     c8c:	0e 94 83 08 	call	0x1106	; 0x1106 <xTaskResumeAll>
     c90:	87 cf       	rjmp	.-242    	; 0xba0 <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     c92:	c8 01       	movw	r24, r16
     c94:	0e 94 54 04 	call	0x8a8	; 0x8a8 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     c98:	0e 94 83 08 	call	0x1106	; 0x1106 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
     c9c:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     c9e:	0f 90       	pop	r0
     ca0:	0f 90       	pop	r0
     ca2:	0f 90       	pop	r0
     ca4:	0f 90       	pop	r0
     ca6:	0f 90       	pop	r0
     ca8:	df 91       	pop	r29
     caa:	cf 91       	pop	r28
     cac:	1f 91       	pop	r17
     cae:	0f 91       	pop	r16
     cb0:	ff 90       	pop	r15
     cb2:	ef 90       	pop	r14
     cb4:	df 90       	pop	r13
     cb6:	cf 90       	pop	r12
     cb8:	bf 90       	pop	r11
     cba:	af 90       	pop	r10
     cbc:	9f 90       	pop	r9
     cbe:	08 95       	ret

00000cc0 <prvIdleTask>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
     cc0:	c9 e8       	ldi	r28, 0x89	; 137
     cc2:	d6 e0       	ldi	r29, 0x06	; 6
     cc4:	88 81       	ld	r24, Y
     cc6:	82 30       	cpi	r24, 0x02	; 2
     cc8:	e8 f3       	brcs	.-6      	; 0xcc4 <prvIdleTask+0x4>
     cca:	0e 94 1b 03 	call	0x636	; 0x636 <vPortYield>
     cce:	fa cf       	rjmp	.-12     	; 0xcc4 <prvIdleTask+0x4>

00000cd0 <prvAddCurrentTaskToDelayedList>:
     cd0:	cf 93       	push	r28
     cd2:	df 93       	push	r29
     cd4:	ec 01       	movw	r28, r24
     cd6:	e0 91 92 06 	lds	r30, 0x0692	; 0x800692 <pxCurrentTCB>
     cda:	f0 91 93 06 	lds	r31, 0x0693	; 0x800693 <pxCurrentTCB+0x1>
     cde:	93 83       	std	Z+3, r25	; 0x03
     ce0:	82 83       	std	Z+2, r24	; 0x02
     ce2:	80 91 67 06 	lds	r24, 0x0667	; 0x800667 <xTickCount>
     ce6:	90 91 68 06 	lds	r25, 0x0668	; 0x800668 <xTickCount+0x1>
     cea:	c8 17       	cp	r28, r24
     cec:	d9 07       	cpc	r29, r25
     cee:	68 f4       	brcc	.+26     	; 0xd0a <prvAddCurrentTaskToDelayedList+0x3a>
     cf0:	60 91 92 06 	lds	r22, 0x0692	; 0x800692 <pxCurrentTCB>
     cf4:	70 91 93 06 	lds	r23, 0x0693	; 0x800693 <pxCurrentTCB+0x1>
     cf8:	80 91 73 06 	lds	r24, 0x0673	; 0x800673 <pxOverflowDelayedTaskList>
     cfc:	90 91 74 06 	lds	r25, 0x0674	; 0x800674 <pxOverflowDelayedTaskList+0x1>
     d00:	6e 5f       	subi	r22, 0xFE	; 254
     d02:	7f 4f       	sbci	r23, 0xFF	; 255
     d04:	0e 94 19 02 	call	0x432	; 0x432 <vListInsert>
     d08:	17 c0       	rjmp	.+46     	; 0xd38 <prvAddCurrentTaskToDelayedList+0x68>
     d0a:	60 91 92 06 	lds	r22, 0x0692	; 0x800692 <pxCurrentTCB>
     d0e:	70 91 93 06 	lds	r23, 0x0693	; 0x800693 <pxCurrentTCB+0x1>
     d12:	80 91 75 06 	lds	r24, 0x0675	; 0x800675 <pxDelayedTaskList>
     d16:	90 91 76 06 	lds	r25, 0x0676	; 0x800676 <pxDelayedTaskList+0x1>
     d1a:	6e 5f       	subi	r22, 0xFE	; 254
     d1c:	7f 4f       	sbci	r23, 0xFF	; 255
     d1e:	0e 94 19 02 	call	0x432	; 0x432 <vListInsert>
     d22:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__data_start>
     d26:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__data_start+0x1>
     d2a:	c8 17       	cp	r28, r24
     d2c:	d9 07       	cpc	r29, r25
     d2e:	20 f4       	brcc	.+8      	; 0xd38 <prvAddCurrentTaskToDelayedList+0x68>
     d30:	d0 93 61 00 	sts	0x0061, r29	; 0x800061 <__data_start+0x1>
     d34:	c0 93 60 00 	sts	0x0060, r28	; 0x800060 <__data_start>
     d38:	df 91       	pop	r29
     d3a:	cf 91       	pop	r28
     d3c:	08 95       	ret

00000d3e <xTaskGenericCreate>:
     d3e:	4f 92       	push	r4
     d40:	5f 92       	push	r5
     d42:	6f 92       	push	r6
     d44:	7f 92       	push	r7
     d46:	8f 92       	push	r8
     d48:	9f 92       	push	r9
     d4a:	af 92       	push	r10
     d4c:	bf 92       	push	r11
     d4e:	cf 92       	push	r12
     d50:	df 92       	push	r13
     d52:	ef 92       	push	r14
     d54:	ff 92       	push	r15
     d56:	0f 93       	push	r16
     d58:	cf 93       	push	r28
     d5a:	df 93       	push	r29
     d5c:	5c 01       	movw	r10, r24
     d5e:	4b 01       	movw	r8, r22
     d60:	3a 01       	movw	r6, r20
     d62:	29 01       	movw	r4, r18
     d64:	81 e2       	ldi	r24, 0x21	; 33
     d66:	90 e0       	ldi	r25, 0x00	; 0
     d68:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <pvPortMalloc>
     d6c:	ec 01       	movw	r28, r24
     d6e:	89 2b       	or	r24, r25
     d70:	09 f4       	brne	.+2      	; 0xd74 <xTaskGenericCreate+0x36>
     d72:	a5 c0       	rjmp	.+330    	; 0xebe <xTaskGenericCreate+0x180>
     d74:	c1 14       	cp	r12, r1
     d76:	d1 04       	cpc	r13, r1
     d78:	09 f0       	breq	.+2      	; 0xd7c <xTaskGenericCreate+0x3e>
     d7a:	9d c0       	rjmp	.+314    	; 0xeb6 <xTaskGenericCreate+0x178>
     d7c:	c3 01       	movw	r24, r6
     d7e:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <pvPortMalloc>
     d82:	98 8f       	std	Y+24, r25	; 0x18
     d84:	8f 8b       	std	Y+23, r24	; 0x17
     d86:	00 97       	sbiw	r24, 0x00	; 0
     d88:	21 f4       	brne	.+8      	; 0xd92 <xTaskGenericCreate+0x54>
     d8a:	ce 01       	movw	r24, r28
     d8c:	0e 94 f8 03 	call	0x7f0	; 0x7f0 <vPortFree>
     d90:	96 c0       	rjmp	.+300    	; 0xebe <xTaskGenericCreate+0x180>
     d92:	a3 01       	movw	r20, r6
     d94:	65 ea       	ldi	r22, 0xA5	; 165
     d96:	70 e0       	ldi	r23, 0x00	; 0
     d98:	0e 94 69 0a 	call	0x14d2	; 0x14d2 <memset>
     d9c:	93 01       	movw	r18, r6
     d9e:	21 50       	subi	r18, 0x01	; 1
     da0:	31 09       	sbc	r19, r1
     da2:	8f 89       	ldd	r24, Y+23	; 0x17
     da4:	98 8d       	ldd	r25, Y+24	; 0x18
     da6:	3c 01       	movw	r6, r24
     da8:	62 0e       	add	r6, r18
     daa:	73 1e       	adc	r7, r19
     dac:	48 e0       	ldi	r20, 0x08	; 8
     dae:	50 e0       	ldi	r21, 0x00	; 0
     db0:	b4 01       	movw	r22, r8
     db2:	ce 01       	movw	r24, r28
     db4:	49 96       	adiw	r24, 0x19	; 25
     db6:	0e 94 70 0a 	call	0x14e0	; 0x14e0 <strncpy>
     dba:	18 a2       	std	Y+32, r1	; 0x20
     dbc:	1e 8a       	std	Y+22, r1	; 0x16
     dbe:	6e 01       	movw	r12, r28
     dc0:	82 e0       	ldi	r24, 0x02	; 2
     dc2:	c8 0e       	add	r12, r24
     dc4:	d1 1c       	adc	r13, r1
     dc6:	c6 01       	movw	r24, r12
     dc8:	0e 94 ee 01 	call	0x3dc	; 0x3dc <vListInitialiseItem>
     dcc:	ce 01       	movw	r24, r28
     dce:	0c 96       	adiw	r24, 0x0c	; 12
     dd0:	0e 94 ee 01 	call	0x3dc	; 0x3dc <vListInitialiseItem>
     dd4:	d9 87       	std	Y+9, r29	; 0x09
     dd6:	c8 87       	std	Y+8, r28	; 0x08
     dd8:	81 e0       	ldi	r24, 0x01	; 1
     dda:	90 e0       	ldi	r25, 0x00	; 0
     ddc:	9d 87       	std	Y+13, r25	; 0x0d
     dde:	8c 87       	std	Y+12, r24	; 0x0c
     de0:	db 8b       	std	Y+19, r29	; 0x13
     de2:	ca 8b       	std	Y+18, r28	; 0x12
     de4:	a2 01       	movw	r20, r4
     de6:	b5 01       	movw	r22, r10
     de8:	c3 01       	movw	r24, r6
     dea:	0e 94 7a 02 	call	0x4f4	; 0x4f4 <pxPortInitialiseStack>
     dee:	99 83       	std	Y+1, r25	; 0x01
     df0:	88 83       	st	Y, r24
     df2:	e1 14       	cp	r14, r1
     df4:	f1 04       	cpc	r15, r1
     df6:	19 f0       	breq	.+6      	; 0xdfe <xTaskGenericCreate+0xc0>
     df8:	f7 01       	movw	r30, r14
     dfa:	d1 83       	std	Z+1, r29	; 0x01
     dfc:	c0 83       	st	Z, r28
     dfe:	0f b6       	in	r0, 0x3f	; 63
     e00:	f8 94       	cli
     e02:	0f 92       	push	r0
     e04:	80 91 69 06 	lds	r24, 0x0669	; 0x800669 <uxCurrentNumberOfTasks>
     e08:	8f 5f       	subi	r24, 0xFF	; 255
     e0a:	80 93 69 06 	sts	0x0669, r24	; 0x800669 <uxCurrentNumberOfTasks>
     e0e:	80 91 92 06 	lds	r24, 0x0692	; 0x800692 <pxCurrentTCB>
     e12:	90 91 93 06 	lds	r25, 0x0693	; 0x800693 <pxCurrentTCB+0x1>
     e16:	89 2b       	or	r24, r25
     e18:	49 f4       	brne	.+18     	; 0xe2c <xTaskGenericCreate+0xee>
     e1a:	d0 93 93 06 	sts	0x0693, r29	; 0x800693 <pxCurrentTCB+0x1>
     e1e:	c0 93 92 06 	sts	0x0692, r28	; 0x800692 <pxCurrentTCB>
     e22:	80 91 69 06 	lds	r24, 0x0669	; 0x800669 <uxCurrentNumberOfTasks>
     e26:	81 30       	cpi	r24, 0x01	; 1
     e28:	81 f4       	brne	.+32     	; 0xe4a <xTaskGenericCreate+0x10c>
     e2a:	4b c0       	rjmp	.+150    	; 0xec2 <xTaskGenericCreate+0x184>
     e2c:	80 91 64 06 	lds	r24, 0x0664	; 0x800664 <xSchedulerRunning>
     e30:	81 11       	cpse	r24, r1
     e32:	0b c0       	rjmp	.+22     	; 0xe4a <xTaskGenericCreate+0x10c>
     e34:	e0 91 92 06 	lds	r30, 0x0692	; 0x800692 <pxCurrentTCB>
     e38:	f0 91 93 06 	lds	r31, 0x0693	; 0x800693 <pxCurrentTCB+0x1>
     e3c:	86 89       	ldd	r24, Z+22	; 0x16
     e3e:	08 17       	cp	r16, r24
     e40:	20 f0       	brcs	.+8      	; 0xe4a <xTaskGenericCreate+0x10c>
     e42:	d0 93 93 06 	sts	0x0693, r29	; 0x800693 <pxCurrentTCB+0x1>
     e46:	c0 93 92 06 	sts	0x0692, r28	; 0x800692 <pxCurrentTCB>
     e4a:	8e 89       	ldd	r24, Y+22	; 0x16
     e4c:	90 91 66 06 	lds	r25, 0x0666	; 0x800666 <uxTopUsedPriority>
     e50:	98 17       	cp	r25, r24
     e52:	10 f4       	brcc	.+4      	; 0xe58 <xTaskGenericCreate+0x11a>
     e54:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <uxTopUsedPriority>
     e58:	90 91 5f 06 	lds	r25, 0x065F	; 0x80065f <uxTCBNumber>
     e5c:	9f 5f       	subi	r25, 0xFF	; 255
     e5e:	90 93 5f 06 	sts	0x065F, r25	; 0x80065f <uxTCBNumber>
     e62:	90 91 65 06 	lds	r25, 0x0665	; 0x800665 <uxTopReadyPriority>
     e66:	98 17       	cp	r25, r24
     e68:	10 f4       	brcc	.+4      	; 0xe6e <xTaskGenericCreate+0x130>
     e6a:	80 93 65 06 	sts	0x0665, r24	; 0x800665 <uxTopReadyPriority>
     e6e:	90 e0       	ldi	r25, 0x00	; 0
     e70:	9c 01       	movw	r18, r24
     e72:	22 0f       	add	r18, r18
     e74:	33 1f       	adc	r19, r19
     e76:	22 0f       	add	r18, r18
     e78:	33 1f       	adc	r19, r19
     e7a:	22 0f       	add	r18, r18
     e7c:	33 1f       	adc	r19, r19
     e7e:	82 0f       	add	r24, r18
     e80:	93 1f       	adc	r25, r19
     e82:	b6 01       	movw	r22, r12
     e84:	87 57       	subi	r24, 0x77	; 119
     e86:	99 4f       	sbci	r25, 0xF9	; 249
     e88:	0e 94 f2 01 	call	0x3e4	; 0x3e4 <vListInsertEnd>
     e8c:	0f 90       	pop	r0
     e8e:	0f be       	out	0x3f, r0	; 63
     e90:	80 91 64 06 	lds	r24, 0x0664	; 0x800664 <xSchedulerRunning>
     e94:	88 23       	and	r24, r24
     e96:	59 f0       	breq	.+22     	; 0xeae <xTaskGenericCreate+0x170>
     e98:	e0 91 92 06 	lds	r30, 0x0692	; 0x800692 <pxCurrentTCB>
     e9c:	f0 91 93 06 	lds	r31, 0x0693	; 0x800693 <pxCurrentTCB+0x1>
     ea0:	86 89       	ldd	r24, Z+22	; 0x16
     ea2:	80 17       	cp	r24, r16
     ea4:	30 f4       	brcc	.+12     	; 0xeb2 <xTaskGenericCreate+0x174>
     ea6:	0e 94 1b 03 	call	0x636	; 0x636 <vPortYield>
     eaa:	81 e0       	ldi	r24, 0x01	; 1
     eac:	27 c0       	rjmp	.+78     	; 0xefc <xTaskGenericCreate+0x1be>
     eae:	81 e0       	ldi	r24, 0x01	; 1
     eb0:	25 c0       	rjmp	.+74     	; 0xefc <xTaskGenericCreate+0x1be>
     eb2:	81 e0       	ldi	r24, 0x01	; 1
     eb4:	23 c0       	rjmp	.+70     	; 0xefc <xTaskGenericCreate+0x1be>
     eb6:	d8 8e       	std	Y+24, r13	; 0x18
     eb8:	cf 8a       	std	Y+23, r12	; 0x17
     eba:	c6 01       	movw	r24, r12
     ebc:	6a cf       	rjmp	.-300    	; 0xd92 <xTaskGenericCreate+0x54>
     ebe:	8f ef       	ldi	r24, 0xFF	; 255
     ec0:	1d c0       	rjmp	.+58     	; 0xefc <xTaskGenericCreate+0x1be>
     ec2:	89 e8       	ldi	r24, 0x89	; 137
     ec4:	96 e0       	ldi	r25, 0x06	; 6
     ec6:	0e 94 e0 01 	call	0x3c0	; 0x3c0 <vListInitialise>
     eca:	80 e8       	ldi	r24, 0x80	; 128
     ecc:	96 e0       	ldi	r25, 0x06	; 6
     ece:	0e 94 e0 01 	call	0x3c0	; 0x3c0 <vListInitialise>
     ed2:	87 e7       	ldi	r24, 0x77	; 119
     ed4:	96 e0       	ldi	r25, 0x06	; 6
     ed6:	0e 94 e0 01 	call	0x3c0	; 0x3c0 <vListInitialise>
     eda:	8a e6       	ldi	r24, 0x6A	; 106
     edc:	96 e0       	ldi	r25, 0x06	; 6
     ede:	0e 94 e0 01 	call	0x3c0	; 0x3c0 <vListInitialise>
     ee2:	80 e8       	ldi	r24, 0x80	; 128
     ee4:	96 e0       	ldi	r25, 0x06	; 6
     ee6:	90 93 76 06 	sts	0x0676, r25	; 0x800676 <pxDelayedTaskList+0x1>
     eea:	80 93 75 06 	sts	0x0675, r24	; 0x800675 <pxDelayedTaskList>
     eee:	87 e7       	ldi	r24, 0x77	; 119
     ef0:	96 e0       	ldi	r25, 0x06	; 6
     ef2:	90 93 74 06 	sts	0x0674, r25	; 0x800674 <pxOverflowDelayedTaskList+0x1>
     ef6:	80 93 73 06 	sts	0x0673, r24	; 0x800673 <pxOverflowDelayedTaskList>
     efa:	a7 cf       	rjmp	.-178    	; 0xe4a <xTaskGenericCreate+0x10c>
     efc:	df 91       	pop	r29
     efe:	cf 91       	pop	r28
     f00:	0f 91       	pop	r16
     f02:	ff 90       	pop	r15
     f04:	ef 90       	pop	r14
     f06:	df 90       	pop	r13
     f08:	cf 90       	pop	r12
     f0a:	bf 90       	pop	r11
     f0c:	af 90       	pop	r10
     f0e:	9f 90       	pop	r9
     f10:	8f 90       	pop	r8
     f12:	7f 90       	pop	r7
     f14:	6f 90       	pop	r6
     f16:	5f 90       	pop	r5
     f18:	4f 90       	pop	r4
     f1a:	08 95       	ret

00000f1c <vTaskStartScheduler>:
     f1c:	af 92       	push	r10
     f1e:	bf 92       	push	r11
     f20:	cf 92       	push	r12
     f22:	df 92       	push	r13
     f24:	ef 92       	push	r14
     f26:	ff 92       	push	r15
     f28:	0f 93       	push	r16
     f2a:	a1 2c       	mov	r10, r1
     f2c:	b1 2c       	mov	r11, r1
     f2e:	c1 2c       	mov	r12, r1
     f30:	d1 2c       	mov	r13, r1
     f32:	e1 2c       	mov	r14, r1
     f34:	f1 2c       	mov	r15, r1
     f36:	00 e0       	ldi	r16, 0x00	; 0
     f38:	20 e0       	ldi	r18, 0x00	; 0
     f3a:	30 e0       	ldi	r19, 0x00	; 0
     f3c:	45 e5       	ldi	r20, 0x55	; 85
     f3e:	50 e0       	ldi	r21, 0x00	; 0
     f40:	67 e7       	ldi	r22, 0x77	; 119
     f42:	70 e0       	ldi	r23, 0x00	; 0
     f44:	80 e6       	ldi	r24, 0x60	; 96
     f46:	96 e0       	ldi	r25, 0x06	; 6
     f48:	0e 94 9f 06 	call	0xd3e	; 0xd3e <xTaskGenericCreate>
     f4c:	81 30       	cpi	r24, 0x01	; 1
     f4e:	49 f4       	brne	.+18     	; 0xf62 <vTaskStartScheduler+0x46>
     f50:	f8 94       	cli
     f52:	80 93 64 06 	sts	0x0664, r24	; 0x800664 <xSchedulerRunning>
     f56:	10 92 68 06 	sts	0x0668, r1	; 0x800668 <xTickCount+0x1>
     f5a:	10 92 67 06 	sts	0x0667, r1	; 0x800667 <xTickCount>
     f5e:	0e 94 e6 02 	call	0x5cc	; 0x5cc <xPortStartScheduler>
     f62:	0f 91       	pop	r16
     f64:	ff 90       	pop	r15
     f66:	ef 90       	pop	r14
     f68:	df 90       	pop	r13
     f6a:	cf 90       	pop	r12
     f6c:	bf 90       	pop	r11
     f6e:	af 90       	pop	r10
     f70:	08 95       	ret

00000f72 <vTaskSuspendAll>:
     f72:	80 91 63 06 	lds	r24, 0x0663	; 0x800663 <uxSchedulerSuspended>
     f76:	8f 5f       	subi	r24, 0xFF	; 255
     f78:	80 93 63 06 	sts	0x0663, r24	; 0x800663 <uxSchedulerSuspended>
     f7c:	08 95       	ret

00000f7e <vTaskIncrementTick>:
     f7e:	0f 93       	push	r16
     f80:	1f 93       	push	r17
     f82:	cf 93       	push	r28
     f84:	df 93       	push	r29
     f86:	80 91 63 06 	lds	r24, 0x0663	; 0x800663 <uxSchedulerSuspended>
     f8a:	81 11       	cpse	r24, r1
     f8c:	b2 c0       	rjmp	.+356    	; 0x10f2 <vTaskIncrementTick+0x174>
     f8e:	80 91 67 06 	lds	r24, 0x0667	; 0x800667 <xTickCount>
     f92:	90 91 68 06 	lds	r25, 0x0668	; 0x800668 <xTickCount+0x1>
     f96:	01 96       	adiw	r24, 0x01	; 1
     f98:	90 93 68 06 	sts	0x0668, r25	; 0x800668 <xTickCount+0x1>
     f9c:	80 93 67 06 	sts	0x0667, r24	; 0x800667 <xTickCount>
     fa0:	80 91 67 06 	lds	r24, 0x0667	; 0x800667 <xTickCount>
     fa4:	90 91 68 06 	lds	r25, 0x0668	; 0x800668 <xTickCount+0x1>
     fa8:	89 2b       	or	r24, r25
     faa:	99 f5       	brne	.+102    	; 0x1012 <vTaskIncrementTick+0x94>
     fac:	80 91 75 06 	lds	r24, 0x0675	; 0x800675 <pxDelayedTaskList>
     fb0:	90 91 76 06 	lds	r25, 0x0676	; 0x800676 <pxDelayedTaskList+0x1>
     fb4:	20 91 73 06 	lds	r18, 0x0673	; 0x800673 <pxOverflowDelayedTaskList>
     fb8:	30 91 74 06 	lds	r19, 0x0674	; 0x800674 <pxOverflowDelayedTaskList+0x1>
     fbc:	30 93 76 06 	sts	0x0676, r19	; 0x800676 <pxDelayedTaskList+0x1>
     fc0:	20 93 75 06 	sts	0x0675, r18	; 0x800675 <pxDelayedTaskList>
     fc4:	90 93 74 06 	sts	0x0674, r25	; 0x800674 <pxOverflowDelayedTaskList+0x1>
     fc8:	80 93 73 06 	sts	0x0673, r24	; 0x800673 <pxOverflowDelayedTaskList>
     fcc:	80 91 60 06 	lds	r24, 0x0660	; 0x800660 <xNumOfOverflows>
     fd0:	8f 5f       	subi	r24, 0xFF	; 255
     fd2:	80 93 60 06 	sts	0x0660, r24	; 0x800660 <xNumOfOverflows>
     fd6:	e0 91 75 06 	lds	r30, 0x0675	; 0x800675 <pxDelayedTaskList>
     fda:	f0 91 76 06 	lds	r31, 0x0676	; 0x800676 <pxDelayedTaskList+0x1>
     fde:	80 81       	ld	r24, Z
     fe0:	81 11       	cpse	r24, r1
     fe2:	07 c0       	rjmp	.+14     	; 0xff2 <vTaskIncrementTick+0x74>
     fe4:	8f ef       	ldi	r24, 0xFF	; 255
     fe6:	9f ef       	ldi	r25, 0xFF	; 255
     fe8:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__data_start+0x1>
     fec:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
     ff0:	10 c0       	rjmp	.+32     	; 0x1012 <vTaskIncrementTick+0x94>
     ff2:	e0 91 75 06 	lds	r30, 0x0675	; 0x800675 <pxDelayedTaskList>
     ff6:	f0 91 76 06 	lds	r31, 0x0676	; 0x800676 <pxDelayedTaskList+0x1>
     ffa:	05 80       	ldd	r0, Z+5	; 0x05
     ffc:	f6 81       	ldd	r31, Z+6	; 0x06
     ffe:	e0 2d       	mov	r30, r0
    1000:	06 80       	ldd	r0, Z+6	; 0x06
    1002:	f7 81       	ldd	r31, Z+7	; 0x07
    1004:	e0 2d       	mov	r30, r0
    1006:	82 81       	ldd	r24, Z+2	; 0x02
    1008:	93 81       	ldd	r25, Z+3	; 0x03
    100a:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__data_start+0x1>
    100e:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
    1012:	20 91 67 06 	lds	r18, 0x0667	; 0x800667 <xTickCount>
    1016:	30 91 68 06 	lds	r19, 0x0668	; 0x800668 <xTickCount+0x1>
    101a:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__data_start>
    101e:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__data_start+0x1>
    1022:	28 17       	cp	r18, r24
    1024:	39 07       	cpc	r19, r25
    1026:	08 f4       	brcc	.+2      	; 0x102a <vTaskIncrementTick+0xac>
    1028:	69 c0       	rjmp	.+210    	; 0x10fc <vTaskIncrementTick+0x17e>
    102a:	e0 91 75 06 	lds	r30, 0x0675	; 0x800675 <pxDelayedTaskList>
    102e:	f0 91 76 06 	lds	r31, 0x0676	; 0x800676 <pxDelayedTaskList+0x1>
    1032:	80 81       	ld	r24, Z
    1034:	88 23       	and	r24, r24
    1036:	99 f0       	breq	.+38     	; 0x105e <vTaskIncrementTick+0xe0>
    1038:	e0 91 75 06 	lds	r30, 0x0675	; 0x800675 <pxDelayedTaskList>
    103c:	f0 91 76 06 	lds	r31, 0x0676	; 0x800676 <pxDelayedTaskList+0x1>
    1040:	05 80       	ldd	r0, Z+5	; 0x05
    1042:	f6 81       	ldd	r31, Z+6	; 0x06
    1044:	e0 2d       	mov	r30, r0
    1046:	c6 81       	ldd	r28, Z+6	; 0x06
    1048:	d7 81       	ldd	r29, Z+7	; 0x07
    104a:	8a 81       	ldd	r24, Y+2	; 0x02
    104c:	9b 81       	ldd	r25, Y+3	; 0x03
    104e:	20 91 67 06 	lds	r18, 0x0667	; 0x800667 <xTickCount>
    1052:	30 91 68 06 	lds	r19, 0x0668	; 0x800668 <xTickCount+0x1>
    1056:	28 17       	cp	r18, r24
    1058:	39 07       	cpc	r19, r25
    105a:	f8 f4       	brcc	.+62     	; 0x109a <vTaskIncrementTick+0x11c>
    105c:	19 c0       	rjmp	.+50     	; 0x1090 <vTaskIncrementTick+0x112>
    105e:	8f ef       	ldi	r24, 0xFF	; 255
    1060:	9f ef       	ldi	r25, 0xFF	; 255
    1062:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__data_start+0x1>
    1066:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
    106a:	48 c0       	rjmp	.+144    	; 0x10fc <vTaskIncrementTick+0x17e>
    106c:	e0 91 75 06 	lds	r30, 0x0675	; 0x800675 <pxDelayedTaskList>
    1070:	f0 91 76 06 	lds	r31, 0x0676	; 0x800676 <pxDelayedTaskList+0x1>
    1074:	05 80       	ldd	r0, Z+5	; 0x05
    1076:	f6 81       	ldd	r31, Z+6	; 0x06
    1078:	e0 2d       	mov	r30, r0
    107a:	c6 81       	ldd	r28, Z+6	; 0x06
    107c:	d7 81       	ldd	r29, Z+7	; 0x07
    107e:	8a 81       	ldd	r24, Y+2	; 0x02
    1080:	9b 81       	ldd	r25, Y+3	; 0x03
    1082:	20 91 67 06 	lds	r18, 0x0667	; 0x800667 <xTickCount>
    1086:	30 91 68 06 	lds	r19, 0x0668	; 0x800668 <xTickCount+0x1>
    108a:	28 17       	cp	r18, r24
    108c:	39 07       	cpc	r19, r25
    108e:	28 f4       	brcc	.+10     	; 0x109a <vTaskIncrementTick+0x11c>
    1090:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__data_start+0x1>
    1094:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
    1098:	31 c0       	rjmp	.+98     	; 0x10fc <vTaskIncrementTick+0x17e>
    109a:	8e 01       	movw	r16, r28
    109c:	0e 5f       	subi	r16, 0xFE	; 254
    109e:	1f 4f       	sbci	r17, 0xFF	; 255
    10a0:	c8 01       	movw	r24, r16
    10a2:	0e 94 54 02 	call	0x4a8	; 0x4a8 <vListRemove>
    10a6:	8c 89       	ldd	r24, Y+20	; 0x14
    10a8:	9d 89       	ldd	r25, Y+21	; 0x15
    10aa:	89 2b       	or	r24, r25
    10ac:	21 f0       	breq	.+8      	; 0x10b6 <vTaskIncrementTick+0x138>
    10ae:	ce 01       	movw	r24, r28
    10b0:	0c 96       	adiw	r24, 0x0c	; 12
    10b2:	0e 94 54 02 	call	0x4a8	; 0x4a8 <vListRemove>
    10b6:	2e 89       	ldd	r18, Y+22	; 0x16
    10b8:	80 91 65 06 	lds	r24, 0x0665	; 0x800665 <uxTopReadyPriority>
    10bc:	82 17       	cp	r24, r18
    10be:	10 f4       	brcc	.+4      	; 0x10c4 <vTaskIncrementTick+0x146>
    10c0:	20 93 65 06 	sts	0x0665, r18	; 0x800665 <uxTopReadyPriority>
    10c4:	30 e0       	ldi	r19, 0x00	; 0
    10c6:	c9 01       	movw	r24, r18
    10c8:	88 0f       	add	r24, r24
    10ca:	99 1f       	adc	r25, r25
    10cc:	88 0f       	add	r24, r24
    10ce:	99 1f       	adc	r25, r25
    10d0:	88 0f       	add	r24, r24
    10d2:	99 1f       	adc	r25, r25
    10d4:	82 0f       	add	r24, r18
    10d6:	93 1f       	adc	r25, r19
    10d8:	b8 01       	movw	r22, r16
    10da:	87 57       	subi	r24, 0x77	; 119
    10dc:	99 4f       	sbci	r25, 0xF9	; 249
    10de:	0e 94 f2 01 	call	0x3e4	; 0x3e4 <vListInsertEnd>
    10e2:	e0 91 75 06 	lds	r30, 0x0675	; 0x800675 <pxDelayedTaskList>
    10e6:	f0 91 76 06 	lds	r31, 0x0676	; 0x800676 <pxDelayedTaskList+0x1>
    10ea:	80 81       	ld	r24, Z
    10ec:	81 11       	cpse	r24, r1
    10ee:	be cf       	rjmp	.-132    	; 0x106c <vTaskIncrementTick+0xee>
    10f0:	b6 cf       	rjmp	.-148    	; 0x105e <vTaskIncrementTick+0xe0>
    10f2:	80 91 62 06 	lds	r24, 0x0662	; 0x800662 <uxMissedTicks>
    10f6:	8f 5f       	subi	r24, 0xFF	; 255
    10f8:	80 93 62 06 	sts	0x0662, r24	; 0x800662 <uxMissedTicks>
    10fc:	df 91       	pop	r29
    10fe:	cf 91       	pop	r28
    1100:	1f 91       	pop	r17
    1102:	0f 91       	pop	r16
    1104:	08 95       	ret

00001106 <xTaskResumeAll>:
    1106:	cf 92       	push	r12
    1108:	df 92       	push	r13
    110a:	ef 92       	push	r14
    110c:	ff 92       	push	r15
    110e:	0f 93       	push	r16
    1110:	1f 93       	push	r17
    1112:	cf 93       	push	r28
    1114:	df 93       	push	r29
    1116:	0f b6       	in	r0, 0x3f	; 63
    1118:	f8 94       	cli
    111a:	0f 92       	push	r0
    111c:	80 91 63 06 	lds	r24, 0x0663	; 0x800663 <uxSchedulerSuspended>
    1120:	81 50       	subi	r24, 0x01	; 1
    1122:	80 93 63 06 	sts	0x0663, r24	; 0x800663 <uxSchedulerSuspended>
    1126:	80 91 63 06 	lds	r24, 0x0663	; 0x800663 <uxSchedulerSuspended>
    112a:	81 11       	cpse	r24, r1
    112c:	64 c0       	rjmp	.+200    	; 0x11f6 <xTaskResumeAll+0xf0>
    112e:	80 91 69 06 	lds	r24, 0x0669	; 0x800669 <uxCurrentNumberOfTasks>
    1132:	81 11       	cpse	r24, r1
    1134:	32 c0       	rjmp	.+100    	; 0x119a <xTaskResumeAll+0x94>
    1136:	62 c0       	rjmp	.+196    	; 0x11fc <xTaskResumeAll+0xf6>
    1138:	d7 01       	movw	r26, r14
    113a:	15 96       	adiw	r26, 0x05	; 5
    113c:	ed 91       	ld	r30, X+
    113e:	fc 91       	ld	r31, X
    1140:	16 97       	sbiw	r26, 0x06	; 6
    1142:	c6 81       	ldd	r28, Z+6	; 0x06
    1144:	d7 81       	ldd	r29, Z+7	; 0x07
    1146:	ce 01       	movw	r24, r28
    1148:	0c 96       	adiw	r24, 0x0c	; 12
    114a:	0e 94 54 02 	call	0x4a8	; 0x4a8 <vListRemove>
    114e:	8e 01       	movw	r16, r28
    1150:	0e 5f       	subi	r16, 0xFE	; 254
    1152:	1f 4f       	sbci	r17, 0xFF	; 255
    1154:	c8 01       	movw	r24, r16
    1156:	0e 94 54 02 	call	0x4a8	; 0x4a8 <vListRemove>
    115a:	2e 89       	ldd	r18, Y+22	; 0x16
    115c:	80 91 65 06 	lds	r24, 0x0665	; 0x800665 <uxTopReadyPriority>
    1160:	82 17       	cp	r24, r18
    1162:	10 f4       	brcc	.+4      	; 0x1168 <xTaskResumeAll+0x62>
    1164:	20 93 65 06 	sts	0x0665, r18	; 0x800665 <uxTopReadyPriority>
    1168:	30 e0       	ldi	r19, 0x00	; 0
    116a:	c9 01       	movw	r24, r18
    116c:	88 0f       	add	r24, r24
    116e:	99 1f       	adc	r25, r25
    1170:	88 0f       	add	r24, r24
    1172:	99 1f       	adc	r25, r25
    1174:	88 0f       	add	r24, r24
    1176:	99 1f       	adc	r25, r25
    1178:	82 0f       	add	r24, r18
    117a:	93 1f       	adc	r25, r19
    117c:	b8 01       	movw	r22, r16
    117e:	87 57       	subi	r24, 0x77	; 119
    1180:	99 4f       	sbci	r25, 0xF9	; 249
    1182:	0e 94 f2 01 	call	0x3e4	; 0x3e4 <vListInsertEnd>
    1186:	e0 91 92 06 	lds	r30, 0x0692	; 0x800692 <pxCurrentTCB>
    118a:	f0 91 93 06 	lds	r31, 0x0693	; 0x800693 <pxCurrentTCB+0x1>
    118e:	9e 89       	ldd	r25, Y+22	; 0x16
    1190:	86 89       	ldd	r24, Z+22	; 0x16
    1192:	98 17       	cp	r25, r24
    1194:	58 f0       	brcs	.+22     	; 0x11ac <xTaskResumeAll+0xa6>
    1196:	dc 2c       	mov	r13, r12
    1198:	09 c0       	rjmp	.+18     	; 0x11ac <xTaskResumeAll+0xa6>
    119a:	d1 2c       	mov	r13, r1
    119c:	0f 2e       	mov	r0, r31
    119e:	fa e6       	ldi	r31, 0x6A	; 106
    11a0:	ef 2e       	mov	r14, r31
    11a2:	f6 e0       	ldi	r31, 0x06	; 6
    11a4:	ff 2e       	mov	r15, r31
    11a6:	f0 2d       	mov	r31, r0
    11a8:	cc 24       	eor	r12, r12
    11aa:	c3 94       	inc	r12
    11ac:	f7 01       	movw	r30, r14
    11ae:	80 81       	ld	r24, Z
    11b0:	81 11       	cpse	r24, r1
    11b2:	c2 cf       	rjmp	.-124    	; 0x1138 <xTaskResumeAll+0x32>
    11b4:	80 91 62 06 	lds	r24, 0x0662	; 0x800662 <uxMissedTicks>
    11b8:	88 23       	and	r24, r24
    11ba:	81 f0       	breq	.+32     	; 0x11dc <xTaskResumeAll+0xd6>
    11bc:	80 91 62 06 	lds	r24, 0x0662	; 0x800662 <uxMissedTicks>
    11c0:	88 23       	and	r24, r24
    11c2:	99 f0       	breq	.+38     	; 0x11ea <xTaskResumeAll+0xe4>
    11c4:	0e 94 bf 07 	call	0xf7e	; 0xf7e <vTaskIncrementTick>
    11c8:	80 91 62 06 	lds	r24, 0x0662	; 0x800662 <uxMissedTicks>
    11cc:	81 50       	subi	r24, 0x01	; 1
    11ce:	80 93 62 06 	sts	0x0662, r24	; 0x800662 <uxMissedTicks>
    11d2:	80 91 62 06 	lds	r24, 0x0662	; 0x800662 <uxMissedTicks>
    11d6:	81 11       	cpse	r24, r1
    11d8:	f5 cf       	rjmp	.-22     	; 0x11c4 <xTaskResumeAll+0xbe>
    11da:	07 c0       	rjmp	.+14     	; 0x11ea <xTaskResumeAll+0xe4>
    11dc:	f1 e0       	ldi	r31, 0x01	; 1
    11de:	df 16       	cp	r13, r31
    11e0:	21 f0       	breq	.+8      	; 0x11ea <xTaskResumeAll+0xe4>
    11e2:	80 91 61 06 	lds	r24, 0x0661	; 0x800661 <xMissedYield>
    11e6:	81 30       	cpi	r24, 0x01	; 1
    11e8:	41 f4       	brne	.+16     	; 0x11fa <xTaskResumeAll+0xf4>
    11ea:	10 92 61 06 	sts	0x0661, r1	; 0x800661 <xMissedYield>
    11ee:	0e 94 1b 03 	call	0x636	; 0x636 <vPortYield>
    11f2:	81 e0       	ldi	r24, 0x01	; 1
    11f4:	03 c0       	rjmp	.+6      	; 0x11fc <xTaskResumeAll+0xf6>
    11f6:	80 e0       	ldi	r24, 0x00	; 0
    11f8:	01 c0       	rjmp	.+2      	; 0x11fc <xTaskResumeAll+0xf6>
    11fa:	80 e0       	ldi	r24, 0x00	; 0
    11fc:	0f 90       	pop	r0
    11fe:	0f be       	out	0x3f, r0	; 63
    1200:	df 91       	pop	r29
    1202:	cf 91       	pop	r28
    1204:	1f 91       	pop	r17
    1206:	0f 91       	pop	r16
    1208:	ff 90       	pop	r15
    120a:	ef 90       	pop	r14
    120c:	df 90       	pop	r13
    120e:	cf 90       	pop	r12
    1210:	08 95       	ret

00001212 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    1212:	cf 93       	push	r28
    1214:	df 93       	push	r29
    1216:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    1218:	89 2b       	or	r24, r25
    121a:	b1 f0       	breq	.+44     	; 0x1248 <vTaskDelay+0x36>
		{
			vTaskSuspendAll();
    121c:	0e 94 b9 07 	call	0xf72	; 0xf72 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    1220:	80 91 67 06 	lds	r24, 0x0667	; 0x800667 <xTickCount>
    1224:	90 91 68 06 	lds	r25, 0x0668	; 0x800668 <xTickCount+0x1>
    1228:	c8 0f       	add	r28, r24
    122a:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    122c:	80 91 92 06 	lds	r24, 0x0692	; 0x800692 <pxCurrentTCB>
    1230:	90 91 93 06 	lds	r25, 0x0693	; 0x800693 <pxCurrentTCB+0x1>
    1234:	02 96       	adiw	r24, 0x02	; 2
    1236:	0e 94 54 02 	call	0x4a8	; 0x4a8 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    123a:	ce 01       	movw	r24, r28
    123c:	0e 94 68 06 	call	0xcd0	; 0xcd0 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    1240:	0e 94 83 08 	call	0x1106	; 0x1106 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1244:	81 11       	cpse	r24, r1
    1246:	02 c0       	rjmp	.+4      	; 0x124c <vTaskDelay+0x3a>
		{
			portYIELD_WITHIN_API();
    1248:	0e 94 1b 03 	call	0x636	; 0x636 <vPortYield>
		}
	}
    124c:	df 91       	pop	r29
    124e:	cf 91       	pop	r28
    1250:	08 95       	ret

00001252 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    1252:	80 91 63 06 	lds	r24, 0x0663	; 0x800663 <uxSchedulerSuspended>
    1256:	81 11       	cpse	r24, r1
    1258:	13 c0       	rjmp	.+38     	; 0x1280 <vTaskSwitchContext+0x2e>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    125a:	80 91 65 06 	lds	r24, 0x0665	; 0x800665 <uxTopReadyPriority>
    125e:	90 e0       	ldi	r25, 0x00	; 0
    1260:	fc 01       	movw	r30, r24
    1262:	ee 0f       	add	r30, r30
    1264:	ff 1f       	adc	r31, r31
    1266:	ee 0f       	add	r30, r30
    1268:	ff 1f       	adc	r31, r31
    126a:	ee 0f       	add	r30, r30
    126c:	ff 1f       	adc	r31, r31
    126e:	8e 0f       	add	r24, r30
    1270:	9f 1f       	adc	r25, r31
    1272:	fc 01       	movw	r30, r24
    1274:	e7 57       	subi	r30, 0x77	; 119
    1276:	f9 4f       	sbci	r31, 0xF9	; 249
    1278:	80 81       	ld	r24, Z
    127a:	88 23       	and	r24, r24
    127c:	29 f0       	breq	.+10     	; 0x1288 <vTaskSwitchContext+0x36>
    127e:	1b c0       	rjmp	.+54     	; 0x12b6 <vTaskSwitchContext+0x64>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    1280:	81 e0       	ldi	r24, 0x01	; 1
    1282:	80 93 61 06 	sts	0x0661, r24	; 0x800661 <xMissedYield>
    1286:	08 95       	ret
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    1288:	80 91 65 06 	lds	r24, 0x0665	; 0x800665 <uxTopReadyPriority>
    128c:	81 50       	subi	r24, 0x01	; 1
    128e:	80 93 65 06 	sts	0x0665, r24	; 0x800665 <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    1292:	80 91 65 06 	lds	r24, 0x0665	; 0x800665 <uxTopReadyPriority>
    1296:	90 e0       	ldi	r25, 0x00	; 0
    1298:	fc 01       	movw	r30, r24
    129a:	ee 0f       	add	r30, r30
    129c:	ff 1f       	adc	r31, r31
    129e:	ee 0f       	add	r30, r30
    12a0:	ff 1f       	adc	r31, r31
    12a2:	ee 0f       	add	r30, r30
    12a4:	ff 1f       	adc	r31, r31
    12a6:	8e 0f       	add	r24, r30
    12a8:	9f 1f       	adc	r25, r31
    12aa:	fc 01       	movw	r30, r24
    12ac:	e7 57       	subi	r30, 0x77	; 119
    12ae:	f9 4f       	sbci	r31, 0xF9	; 249
    12b0:	80 81       	ld	r24, Z
    12b2:	88 23       	and	r24, r24
    12b4:	49 f3       	breq	.-46     	; 0x1288 <vTaskSwitchContext+0x36>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    12b6:	80 91 65 06 	lds	r24, 0x0665	; 0x800665 <uxTopReadyPriority>
    12ba:	90 e0       	ldi	r25, 0x00	; 0
    12bc:	9c 01       	movw	r18, r24
    12be:	22 0f       	add	r18, r18
    12c0:	33 1f       	adc	r19, r19
    12c2:	22 0f       	add	r18, r18
    12c4:	33 1f       	adc	r19, r19
    12c6:	22 0f       	add	r18, r18
    12c8:	33 1f       	adc	r19, r19
    12ca:	28 0f       	add	r18, r24
    12cc:	39 1f       	adc	r19, r25
    12ce:	d9 01       	movw	r26, r18
    12d0:	a7 57       	subi	r26, 0x77	; 119
    12d2:	b9 4f       	sbci	r27, 0xF9	; 249
    12d4:	11 96       	adiw	r26, 0x01	; 1
    12d6:	ed 91       	ld	r30, X+
    12d8:	fc 91       	ld	r31, X
    12da:	12 97       	sbiw	r26, 0x02	; 2
    12dc:	02 80       	ldd	r0, Z+2	; 0x02
    12de:	f3 81       	ldd	r31, Z+3	; 0x03
    12e0:	e0 2d       	mov	r30, r0
    12e2:	12 96       	adiw	r26, 0x02	; 2
    12e4:	fc 93       	st	X, r31
    12e6:	ee 93       	st	-X, r30
    12e8:	11 97       	sbiw	r26, 0x01	; 1
    12ea:	24 57       	subi	r18, 0x74	; 116
    12ec:	39 4f       	sbci	r19, 0xF9	; 249
    12ee:	e2 17       	cp	r30, r18
    12f0:	f3 07       	cpc	r31, r19
    12f2:	29 f4       	brne	.+10     	; 0x12fe <vTaskSwitchContext+0xac>
    12f4:	22 81       	ldd	r18, Z+2	; 0x02
    12f6:	33 81       	ldd	r19, Z+3	; 0x03
    12f8:	fd 01       	movw	r30, r26
    12fa:	32 83       	std	Z+2, r19	; 0x02
    12fc:	21 83       	std	Z+1, r18	; 0x01
    12fe:	fc 01       	movw	r30, r24
    1300:	ee 0f       	add	r30, r30
    1302:	ff 1f       	adc	r31, r31
    1304:	ee 0f       	add	r30, r30
    1306:	ff 1f       	adc	r31, r31
    1308:	ee 0f       	add	r30, r30
    130a:	ff 1f       	adc	r31, r31
    130c:	8e 0f       	add	r24, r30
    130e:	9f 1f       	adc	r25, r31
    1310:	fc 01       	movw	r30, r24
    1312:	e7 57       	subi	r30, 0x77	; 119
    1314:	f9 4f       	sbci	r31, 0xF9	; 249
    1316:	01 80       	ldd	r0, Z+1	; 0x01
    1318:	f2 81       	ldd	r31, Z+2	; 0x02
    131a:	e0 2d       	mov	r30, r0
    131c:	86 81       	ldd	r24, Z+6	; 0x06
    131e:	97 81       	ldd	r25, Z+7	; 0x07
    1320:	90 93 93 06 	sts	0x0693, r25	; 0x800693 <pxCurrentTCB+0x1>
    1324:	80 93 92 06 	sts	0x0692, r24	; 0x800692 <pxCurrentTCB>
    1328:	08 95       	ret

0000132a <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    132a:	cf 93       	push	r28
    132c:	df 93       	push	r29
    132e:	eb 01       	movw	r28, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    1330:	20 91 92 06 	lds	r18, 0x0692	; 0x800692 <pxCurrentTCB>
    1334:	30 91 93 06 	lds	r19, 0x0693	; 0x800693 <pxCurrentTCB+0x1>
    1338:	b9 01       	movw	r22, r18
    133a:	64 5f       	subi	r22, 0xF4	; 244
    133c:	7f 4f       	sbci	r23, 0xFF	; 255
    133e:	0e 94 19 02 	call	0x432	; 0x432 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1342:	80 91 92 06 	lds	r24, 0x0692	; 0x800692 <pxCurrentTCB>
    1346:	90 91 93 06 	lds	r25, 0x0693	; 0x800693 <pxCurrentTCB+0x1>
    134a:	02 96       	adiw	r24, 0x02	; 2
    134c:	0e 94 54 02 	call	0x4a8	; 0x4a8 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    1350:	80 91 67 06 	lds	r24, 0x0667	; 0x800667 <xTickCount>
    1354:	90 91 68 06 	lds	r25, 0x0668	; 0x800668 <xTickCount+0x1>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    1358:	8c 0f       	add	r24, r28
    135a:	9d 1f       	adc	r25, r29
    135c:	0e 94 68 06 	call	0xcd0	; 0xcd0 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    1360:	df 91       	pop	r29
    1362:	cf 91       	pop	r28
    1364:	08 95       	ret

00001366 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    1366:	0f 93       	push	r16
    1368:	1f 93       	push	r17
    136a:	cf 93       	push	r28
    136c:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    136e:	dc 01       	movw	r26, r24
    1370:	15 96       	adiw	r26, 0x05	; 5
    1372:	ed 91       	ld	r30, X+
    1374:	fc 91       	ld	r31, X
    1376:	16 97       	sbiw	r26, 0x06	; 6
    1378:	c6 81       	ldd	r28, Z+6	; 0x06
    137a:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    137c:	8e 01       	movw	r16, r28
    137e:	04 5f       	subi	r16, 0xF4	; 244
    1380:	1f 4f       	sbci	r17, 0xFF	; 255
    1382:	c8 01       	movw	r24, r16
    1384:	0e 94 54 02 	call	0x4a8	; 0x4a8 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1388:	80 91 63 06 	lds	r24, 0x0663	; 0x800663 <uxSchedulerSuspended>
    138c:	81 11       	cpse	r24, r1
    138e:	1c c0       	rjmp	.+56     	; 0x13c8 <xTaskRemoveFromEventList+0x62>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    1390:	0a 50       	subi	r16, 0x0A	; 10
    1392:	11 09       	sbc	r17, r1
    1394:	c8 01       	movw	r24, r16
    1396:	0e 94 54 02 	call	0x4a8	; 0x4a8 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    139a:	2e 89       	ldd	r18, Y+22	; 0x16
    139c:	80 91 65 06 	lds	r24, 0x0665	; 0x800665 <uxTopReadyPriority>
    13a0:	82 17       	cp	r24, r18
    13a2:	10 f4       	brcc	.+4      	; 0x13a8 <xTaskRemoveFromEventList+0x42>
    13a4:	20 93 65 06 	sts	0x0665, r18	; 0x800665 <uxTopReadyPriority>
    13a8:	30 e0       	ldi	r19, 0x00	; 0
    13aa:	c9 01       	movw	r24, r18
    13ac:	88 0f       	add	r24, r24
    13ae:	99 1f       	adc	r25, r25
    13b0:	88 0f       	add	r24, r24
    13b2:	99 1f       	adc	r25, r25
    13b4:	88 0f       	add	r24, r24
    13b6:	99 1f       	adc	r25, r25
    13b8:	82 0f       	add	r24, r18
    13ba:	93 1f       	adc	r25, r19
    13bc:	b8 01       	movw	r22, r16
    13be:	87 57       	subi	r24, 0x77	; 119
    13c0:	99 4f       	sbci	r25, 0xF9	; 249
    13c2:	0e 94 f2 01 	call	0x3e4	; 0x3e4 <vListInsertEnd>
    13c6:	05 c0       	rjmp	.+10     	; 0x13d2 <xTaskRemoveFromEventList+0x6c>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    13c8:	b8 01       	movw	r22, r16
    13ca:	8a e6       	ldi	r24, 0x6A	; 106
    13cc:	96 e0       	ldi	r25, 0x06	; 6
    13ce:	0e 94 f2 01 	call	0x3e4	; 0x3e4 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    13d2:	e0 91 92 06 	lds	r30, 0x0692	; 0x800692 <pxCurrentTCB>
    13d6:	f0 91 93 06 	lds	r31, 0x0693	; 0x800693 <pxCurrentTCB+0x1>
    13da:	81 e0       	ldi	r24, 0x01	; 1
    13dc:	2e 89       	ldd	r18, Y+22	; 0x16
    13de:	96 89       	ldd	r25, Z+22	; 0x16
    13e0:	29 17       	cp	r18, r25
    13e2:	08 f4       	brcc	.+2      	; 0x13e6 <xTaskRemoveFromEventList+0x80>
    13e4:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    13e6:	df 91       	pop	r29
    13e8:	cf 91       	pop	r28
    13ea:	1f 91       	pop	r17
    13ec:	0f 91       	pop	r16
    13ee:	08 95       	ret

000013f0 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    13f0:	20 91 60 06 	lds	r18, 0x0660	; 0x800660 <xNumOfOverflows>
    13f4:	fc 01       	movw	r30, r24
    13f6:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    13f8:	20 91 67 06 	lds	r18, 0x0667	; 0x800667 <xTickCount>
    13fc:	30 91 68 06 	lds	r19, 0x0668	; 0x800668 <xTickCount+0x1>
    1400:	32 83       	std	Z+2, r19	; 0x02
    1402:	21 83       	std	Z+1, r18	; 0x01
    1404:	08 95       	ret

00001406 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    1406:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    1408:	0f b6       	in	r0, 0x3f	; 63
    140a:	f8 94       	cli
    140c:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    140e:	80 91 60 06 	lds	r24, 0x0660	; 0x800660 <xNumOfOverflows>
    1412:	90 81       	ld	r25, Z
    1414:	98 17       	cp	r25, r24
    1416:	49 f0       	breq	.+18     	; 0x142a <xTaskCheckForTimeOut+0x24>
    1418:	80 91 67 06 	lds	r24, 0x0667	; 0x800667 <xTickCount>
    141c:	90 91 68 06 	lds	r25, 0x0668	; 0x800668 <xTickCount+0x1>
    1420:	21 81       	ldd	r18, Z+1	; 0x01
    1422:	32 81       	ldd	r19, Z+2	; 0x02
    1424:	82 17       	cp	r24, r18
    1426:	93 07       	cpc	r25, r19
    1428:	f8 f4       	brcc	.+62     	; 0x1468 <xTaskCheckForTimeOut+0x62>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    142a:	80 91 67 06 	lds	r24, 0x0667	; 0x800667 <xTickCount>
    142e:	90 91 68 06 	lds	r25, 0x0668	; 0x800668 <xTickCount+0x1>
    1432:	41 81       	ldd	r20, Z+1	; 0x01
    1434:	52 81       	ldd	r21, Z+2	; 0x02
    1436:	db 01       	movw	r26, r22
    1438:	2d 91       	ld	r18, X+
    143a:	3c 91       	ld	r19, X
    143c:	11 97       	sbiw	r26, 0x01	; 1
    143e:	84 1b       	sub	r24, r20
    1440:	95 0b       	sbc	r25, r21
    1442:	82 17       	cp	r24, r18
    1444:	93 07       	cpc	r25, r19
    1446:	90 f4       	brcc	.+36     	; 0x146c <xTaskCheckForTimeOut+0x66>
    1448:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    144a:	e0 91 67 06 	lds	r30, 0x0667	; 0x800667 <xTickCount>
    144e:	f0 91 68 06 	lds	r31, 0x0668	; 0x800668 <xTickCount+0x1>
    1452:	bf 01       	movw	r22, r30
    1454:	64 1b       	sub	r22, r20
    1456:	75 0b       	sbc	r23, r21
    1458:	26 1b       	sub	r18, r22
    145a:	37 0b       	sbc	r19, r23
    145c:	2d 93       	st	X+, r18
    145e:	3c 93       	st	X, r19
			vTaskSetTimeOutState( pxTimeOut );
    1460:	0e 94 f8 09 	call	0x13f0	; 0x13f0 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    1464:	80 e0       	ldi	r24, 0x00	; 0
    1466:	03 c0       	rjmp	.+6      	; 0x146e <xTaskCheckForTimeOut+0x68>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    1468:	81 e0       	ldi	r24, 0x01	; 1
    146a:	01 c0       	rjmp	.+2      	; 0x146e <xTaskCheckForTimeOut+0x68>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    146c:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    146e:	0f 90       	pop	r0
    1470:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    1472:	08 95       	ret

00001474 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    1474:	81 e0       	ldi	r24, 0x01	; 1
    1476:	80 93 61 06 	sts	0x0661, r24	; 0x800661 <xMissedYield>
    147a:	08 95       	ret

0000147c <__udivmodsi4>:
    147c:	a1 e2       	ldi	r26, 0x21	; 33
    147e:	1a 2e       	mov	r1, r26
    1480:	aa 1b       	sub	r26, r26
    1482:	bb 1b       	sub	r27, r27
    1484:	fd 01       	movw	r30, r26
    1486:	0d c0       	rjmp	.+26     	; 0x14a2 <__udivmodsi4_ep>

00001488 <__udivmodsi4_loop>:
    1488:	aa 1f       	adc	r26, r26
    148a:	bb 1f       	adc	r27, r27
    148c:	ee 1f       	adc	r30, r30
    148e:	ff 1f       	adc	r31, r31
    1490:	a2 17       	cp	r26, r18
    1492:	b3 07       	cpc	r27, r19
    1494:	e4 07       	cpc	r30, r20
    1496:	f5 07       	cpc	r31, r21
    1498:	20 f0       	brcs	.+8      	; 0x14a2 <__udivmodsi4_ep>
    149a:	a2 1b       	sub	r26, r18
    149c:	b3 0b       	sbc	r27, r19
    149e:	e4 0b       	sbc	r30, r20
    14a0:	f5 0b       	sbc	r31, r21

000014a2 <__udivmodsi4_ep>:
    14a2:	66 1f       	adc	r22, r22
    14a4:	77 1f       	adc	r23, r23
    14a6:	88 1f       	adc	r24, r24
    14a8:	99 1f       	adc	r25, r25
    14aa:	1a 94       	dec	r1
    14ac:	69 f7       	brne	.-38     	; 0x1488 <__udivmodsi4_loop>
    14ae:	60 95       	com	r22
    14b0:	70 95       	com	r23
    14b2:	80 95       	com	r24
    14b4:	90 95       	com	r25
    14b6:	9b 01       	movw	r18, r22
    14b8:	ac 01       	movw	r20, r24
    14ba:	bd 01       	movw	r22, r26
    14bc:	cf 01       	movw	r24, r30
    14be:	08 95       	ret

000014c0 <memcpy>:
    14c0:	fb 01       	movw	r30, r22
    14c2:	dc 01       	movw	r26, r24
    14c4:	02 c0       	rjmp	.+4      	; 0x14ca <memcpy+0xa>
    14c6:	01 90       	ld	r0, Z+
    14c8:	0d 92       	st	X+, r0
    14ca:	41 50       	subi	r20, 0x01	; 1
    14cc:	50 40       	sbci	r21, 0x00	; 0
    14ce:	d8 f7       	brcc	.-10     	; 0x14c6 <memcpy+0x6>
    14d0:	08 95       	ret

000014d2 <memset>:
    14d2:	dc 01       	movw	r26, r24
    14d4:	01 c0       	rjmp	.+2      	; 0x14d8 <memset+0x6>
    14d6:	6d 93       	st	X+, r22
    14d8:	41 50       	subi	r20, 0x01	; 1
    14da:	50 40       	sbci	r21, 0x00	; 0
    14dc:	e0 f7       	brcc	.-8      	; 0x14d6 <memset+0x4>
    14de:	08 95       	ret

000014e0 <strncpy>:
    14e0:	fb 01       	movw	r30, r22
    14e2:	dc 01       	movw	r26, r24
    14e4:	41 50       	subi	r20, 0x01	; 1
    14e6:	50 40       	sbci	r21, 0x00	; 0
    14e8:	48 f0       	brcs	.+18     	; 0x14fc <strncpy+0x1c>
    14ea:	01 90       	ld	r0, Z+
    14ec:	0d 92       	st	X+, r0
    14ee:	00 20       	and	r0, r0
    14f0:	c9 f7       	brne	.-14     	; 0x14e4 <strncpy+0x4>
    14f2:	01 c0       	rjmp	.+2      	; 0x14f6 <strncpy+0x16>
    14f4:	1d 92       	st	X+, r1
    14f6:	41 50       	subi	r20, 0x01	; 1
    14f8:	50 40       	sbci	r21, 0x00	; 0
    14fa:	e0 f7       	brcc	.-8      	; 0x14f4 <strncpy+0x14>
    14fc:	08 95       	ret

000014fe <_exit>:
    14fe:	f8 94       	cli

00001500 <__stop_program>:
    1500:	ff cf       	rjmp	.-2      	; 0x1500 <__stop_program>
